<!DOCTYPE html>
<html lang="en">

<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-3J13LHWFT3"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-3J13LHWFT3');
    </script>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" href="img/logo_small.png">
    <title>Team Chat - ALL PLAYS</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="css/styles.css">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: {
                            50: '#eef2ff',
                            100: '#e0e7ff',
                            500: '#6366f1',
                            600: '#4f46e5',
                            700: '#4338ca',
                            800: '#3730a3',
                            900: '#312e81'
                        }
                    }
                }
            }
        }
    </script>
    <style>
        .chat-container {
            height: calc(100vh - 380px);
            min-height: 300px;
        }
        @media (max-width: 640px) {
            .chat-container {
                height: calc(100vh - 320px);
            }
        }
    </style>
</head>

<body class="bg-gray-50 text-gray-900">
    <div id="header-container"></div>

    <main class="container mx-auto px-4 py-6 max-w-4xl">
        <!-- Team Admin Banner -->
        <div id="team-banner" class="mb-6"></div>

        <!-- Chat Container -->
        <div class="bg-white rounded-2xl shadow-lg border border-gray-200 overflow-hidden flex flex-col">
            <!-- Chat Header -->
            <div class="p-4 border-b border-gray-100 bg-gray-50 flex items-center justify-between">
                <h2 class="text-lg font-bold text-gray-900">Team Chat</h2>
                <button id="refresh-btn"
                    class="flex items-center gap-2 px-3 py-1.5 text-sm font-medium text-gray-600 hover:text-primary-600 hover:bg-primary-50 rounded-lg transition">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                    </svg>
                    Refresh
                </button>
            </div>

            <!-- Load More Button (hidden by default) -->
            <div id="load-more-container" class="hidden px-4 py-2 border-b border-gray-100 bg-white">
                <button id="load-more-btn"
                    class="w-full text-sm text-primary-600 hover:text-primary-700 font-medium py-2">
                    Load older messages...
                </button>
            </div>

            <!-- Messages Area -->
            <div id="messages-container" class="chat-container overflow-y-auto p-4 space-y-4">
                <div class="text-center py-8">
                    <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-primary-600 mx-auto mb-2"></div>
                    <p class="text-sm text-gray-500">Loading messages...</p>
                </div>
            </div>

            <!-- Composer -->
            <div class="p-4 border-t border-gray-200 bg-gray-50">
                <div class="flex gap-2 items-start">
                    <div class="relative flex-1">
                        <div class="flex items-center gap-1 w-full rounded-lg border border-gray-300 bg-white px-2 focus-within:ring-2 focus-within:ring-primary-500 focus-within:border-primary-500">
                            <button id="voice-btn" type="button"
                                class="shrink-0 p-2 rounded-md text-gray-500 hover:text-primary-600 hover:bg-primary-50 transition"
                                title="Voice to text">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 1a3 3 0 00-3 3v8a3 3 0 006 0V4a3 3 0 00-3-3z"></path>
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 10v2a7 7 0 01-14 0v-2"></path>
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19v4"></path>
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 23h8"></path>
                                </svg>
                            </button>
                            <input type="text" id="message-input"
                                placeholder="Type a message..."
                                class="w-full px-2 py-2.5 border-0 focus:outline-none focus:ring-0"
                                maxlength="2000">
                            <input id="chat-image-input" type="file" accept="image/*" class="hidden">
                            <button id="image-btn" type="button"
                                class="shrink-0 p-2 rounded-md text-gray-500 hover:text-primary-600 hover:bg-primary-50 transition"
                                title="Attach image">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 7a2 2 0 012-2h14a2 2 0 012 2v10a2 2 0 01-2 2H5a2 2 0 01-2-2V7z"></path>
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.5 11.5a1.5 1.5 0 100-3 1.5 1.5 0 000 3z"></path>
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 15l-4-4L6 22"></path>
                                </svg>
                            </button>
                        </div>
                        <div id="mention-menu"
                            class="hidden absolute bottom-full left-0 mb-2 w-56 bg-white border border-gray-200 rounded-lg shadow-lg overflow-hidden">
                            <button type="button" id="mention-allplays"
                                class="w-full text-left px-3 py-2 hover:bg-gray-50 flex items-center gap-2">
                                <span class="inline-flex items-center justify-center w-7 h-7 rounded-full bg-primary-100 text-primary-700 font-bold text-xs">AP</span>
                                <span class="text-sm font-medium text-gray-900">@ALL PLAYS</span>
                            </button>
                        </div>
                    </div>
                    <button id="send-btn"
                        class="px-5 py-2.5 bg-primary-600 text-white rounded-lg font-medium hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500 disabled:opacity-50 disabled:cursor-not-allowed transition">
                        Send
                    </button>
                </div>
                <div id="voice-hint" class="hidden mt-2 text-xs text-primary-700 bg-primary-50 border border-primary-100 rounded-lg px-3 py-2">
                    Listening... tap mic again to stop.
                </div>
                <div id="chat-image-preview" class="hidden mt-2 p-2 border border-gray-200 rounded-lg bg-white">
                    <div class="flex items-center gap-3">
                        <img id="chat-image-preview-img" alt="Image preview" class="w-14 h-14 rounded-md object-cover border border-gray-200">
                        <div class="min-w-0 flex-1">
                            <p id="chat-image-preview-name" class="text-sm font-medium text-gray-800 truncate"></p>
                            <p id="chat-image-preview-size" class="text-xs text-gray-500"></p>
                        </div>
                        <button id="chat-image-remove-btn" type="button" class="text-sm text-red-600 hover:text-red-700 font-medium">
                            Remove
                        </button>
                    </div>
                </div>
                <div id="ai-thinking" class="hidden mt-2 text-sm text-indigo-600 flex items-center gap-2">
                    <div class="animate-spin rounded-full h-4 w-4 border-b-2 border-indigo-600"></div>
                    <span>ALL PLAYS is thinkingâ€¦</span>
                </div>
                <div id="send-error" class="hidden mt-2 text-sm text-red-600"></div>
                <div class="mt-1.5 text-xs text-gray-400">
                    <span class="hidden sm:inline">Formatting: </span><code class="bg-gray-100 px-1 rounded">*bold*</code> <code class="bg-gray-100 px-1 rounded">_italic_</code> <code class="bg-gray-100 px-1 rounded">~strike~</code> <code class="bg-gray-100 px-1 rounded">`code`</code> â€¢ URLs auto-link
                </div>
            </div>
        </div>
    </main>

    <div id="footer-container"></div>

    <!-- Edit Modal -->
    <div id="edit-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
        <div class="bg-white rounded-xl shadow-xl max-w-md w-full p-6">
            <h3 class="text-lg font-bold text-gray-900 mb-4">Edit Message</h3>
            <textarea id="edit-textarea" rows="3"
                class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary-500 resize-none"
                maxlength="2000"></textarea>
            <div class="flex justify-end gap-2 mt-4">
                <button id="edit-cancel-btn"
                    class="px-4 py-2 text-gray-600 hover:text-gray-800 font-medium">
                    Cancel
                </button>
                <button id="edit-save-btn"
                    class="px-4 py-2 bg-primary-600 text-white rounded-lg font-medium hover:bg-primary-700">
                    Save
                </button>
            </div>
        </div>
    </div>

    <script type="module">
        import { renderHeader, renderFooter, escapeHtml } from './js/utils.js?v=8';
        import { checkAuth } from './js/auth.js?v=9';
        import { getTeam, getUserProfile, getPlayers, getGames, getGameEvents, getAggregatedStatsForGames, getChatMessages, postChatMessage, editChatMessage, deleteChatMessage, canAccessTeamChat, canModerateChat, updateChatLastRead, subscribeToChatMessages, uploadChatImage, toggleChatReaction } from './js/db.js?v=20';
        import { renderTeamAdminBanner } from './js/team-admin-banner.js';
        import { getAI, getGenerativeModel, GoogleAIBackend } from './js/vendor/firebase-ai.js';
        import { getApp } from './js/vendor/firebase-app.js';

        renderFooter(document.getElementById('footer-container'));

        /**
         * Format message text with simple markdown-like syntax:
         * - Auto-link URLs
         * - *bold*
         * - _italic_
         * - ~strikethrough~
         * - `code`
         */
        function formatMessageText(text) {
            // First escape HTML to prevent XSS
            let formatted = escapeHtml(text);

            // Basic bullet formatting for lines starting with "- " or "* "
            formatted = formatted.replace(
                /(^|\n)\s*[-*]\s+(?=\S)/g,
                '$1&bull; '
            );

            // Highlight ALL PLAYS mention
            formatted = formatted.replace(
                /@all\s*plays/gi,
                '<span class="inline-flex items-center gap-1 px-1.5 py-0.5 rounded bg-indigo-50 text-indigo-700 font-semibold text-xs">@ALL PLAYS</span>'
            );

            // Auto-link URLs (must come before other formatting)
            // Matches http://, https://, and www. URLs
            formatted = formatted.replace(
                /(\bhttps?:\/\/[^\s<]+[^\s<.,;:!?"'\])>]|\bwww\.[^\s<]+[^\s<.,;:!?"'\])>])/gi,
                (url) => {
                    const href = url.startsWith('www.') ? 'https://' + url : url;
                    if (!isSafeUrl(href)) return url;
                    return `<a href="${escapeHtml(href)}" target="_blank" rel="noopener noreferrer" class="text-primary-600 hover:text-primary-800 underline">${url}</a>`;
                }
            );

            // Code (backticks) - must come before other inline formatting
            formatted = formatted.replace(
                /`([^`]+)`/g,
                '<code class="bg-gray-200 text-gray-800 px-1 py-0.5 rounded text-xs font-mono">$1</code>'
            );

            // Bold (*text*)
            formatted = formatted.replace(
                /\*([^*]+)\*/g,
                '<strong>$1</strong>'
            );

            // Italic (_text_)
            formatted = formatted.replace(
                /\b_([^_]+)_\b/g,
                '<em>$1</em>'
            );

            // Strikethrough (~text~)
            formatted = formatted.replace(
                /~([^~]+)~/g,
                '<del class="text-gray-500">$1</del>'
            );

            return formatted;
        }

        function isSafeUrl(href) {
            try {
                const url = new URL(href, window.location.origin);
                return url.protocol === 'http:' || url.protocol === 'https:';
            } catch {
                return false;
            }
        }

        // Simple header for parents (no edit options)
        function renderParentChatHeader(container, team) {
            const name = team?.name || 'Team';
            const photoUrl = team?.photoUrl || '';
            const sport = team?.sport || '';

            container.innerHTML = `
                <div class="bg-white rounded-2xl shadow-md border border-gray-200 overflow-hidden">
                    <div class="p-5 bg-gradient-to-r from-gray-50 to-white">
                        <div class="flex items-center gap-4">
                            ${photoUrl
                                ? `<img src="${escapeHtml(photoUrl)}" alt="${escapeHtml(name)}" class="w-14 h-14 rounded-xl object-cover border-2 border-gray-200 shadow-sm">`
                                : `<div class="w-14 h-14 rounded-xl bg-gradient-to-br from-primary-100 to-primary-200 flex items-center justify-center border-2 border-gray-200 shadow-sm">
                                    <span class="text-xl font-bold text-primary-600">${escapeHtml(name.charAt(0))}</span>
                                  </div>`
                            }
                            <div class="min-w-0 flex-1">
                                <div class="text-xl font-bold text-gray-900 truncate">${escapeHtml(name)}</div>
                                ${sport ? `<div class="text-sm text-gray-500">${escapeHtml(sport)}</div>` : ''}
                            </div>
                            <a href="parent-dashboard.html" class="inline-flex items-center gap-2 px-4 py-2 text-sm font-semibold text-gray-600 hover:text-primary-700 hover:bg-gray-100 rounded-lg transition">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v8a2 2 0 002 2h4"></path>
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 16l4-4m0 0l-4-4m4 4H9"></path>
                                </svg>
                                <span class="hidden sm:inline">Back</span>
                            </a>
                        </div>
                    </div>
                </div>
            `;
        }

        // State
        let currentUser = null;
        let currentUserProfile = null;
        let currentTeam = null;
        let teamId = null;
        let messages = [];
        let liveMessages = [];
        let olderMessages = [];
        let liveOldestDoc = null;
        let hasMoreMessages = true;
        let canModerate = false;
        let unsubscribeChat = null;
        let initialSnapshotLoaded = false;
        let pendingScrollToBottom = false;
        let aiInFlight = false;
        let aiThinkingStartedAt = null;
        let aiUiPending = false;
        const senderPhotoCache = new Map();
        const mentionState = { active: false, atPos: null };
        const AI_MENTION_REGEX = /@all\s*plays/ig;
        const AI_STATS_GAMES_LIMIT = 10;
        const AI_GAMES_CONTEXT_LIMIT = 20;
        const AI_EVENTS_GAMES_LIMIT = 3;
        const AI_EVENTS_PER_GAME_LIMIT = 25;
        const MAX_CHAT_IMAGE_SIZE = 5 * 1024 * 1024;
        const CHAT_REACTIONS = [
            { key: 'thumbs_up', emoji: 'ðŸ‘' },
            { key: 'heart', emoji: 'â¤ï¸' },
            { key: 'joy', emoji: 'ðŸ˜‚' },
            { key: 'wow', emoji: 'ðŸ˜®' },
            { key: 'sad', emoji: 'ðŸ˜¢' },
            { key: 'clap', emoji: 'ðŸ‘' }
        ];
        const CHAT_REACTION_BY_KEY = new Map(CHAT_REACTIONS.map(r => [r.key, r.emoji]));
        let aiModelCache = null;
        let activeVoiceRecognition = null;
        let voiceListening = false;
        let pendingImageFile = null;
        let activeReactionPickerMessageId = null;
        let activeReactionInfo = null;
        const pendingReactionOps = new Set();
        const reactionUserNameCache = new Map();
        const reactionLongPress = {
            timer: null,
            key: null,
            suppressUntil: 0
        };

        // Get teamId from URL
        function getTeamIdFromUrl() {
            const hash = window.location.hash;
            const params = new URLSearchParams(hash.replace('#', ''));
            return params.get('teamId');
        }

        // Initialize
        checkAuth(async (user) => {
            if (!user) {
                window.location.href = 'login.html';
                return;
            }

            currentUser = user;
            renderHeader(document.getElementById('header-container'), user);

            teamId = getTeamIdFromUrl();
            if (!teamId) {
                alert('No team specified');
                window.location.href = 'dashboard.html';
                return;
            }

            try {
                // Load team
                currentTeam = await getTeam(teamId);
                if (!currentTeam) {
                    alert('Team not found');
                    window.location.href = 'dashboard.html';
                    return;
                }
                currentTeam.id = teamId;

                // Load user profile
                currentUserProfile = await getUserProfile(user.uid);
                if (currentUserProfile?.photoUrl) {
                    senderPhotoCache.set(user.uid, currentUserProfile.photoUrl);
                }

                // Check access
                const userWithProfile = {
                    ...user,
                    parentOf: currentUserProfile?.parentOf || [],
                    isAdmin: currentUserProfile?.isAdmin || false
                };

                if (!canAccessTeamChat(userWithProfile, currentTeam)) {
                    alert('You do not have access to this team chat');
                    window.location.href = 'dashboard.html';
                    return;
                }

                canModerate = canModerateChat(userWithProfile, currentTeam);

                // Render team navigation banner with appropriate access level
                const accessLevel = canModerate ? 'full' : 'parent';
                const exitUrl = canModerate ? 'dashboard.html' : 'parent-dashboard.html';
                renderTeamAdminBanner(document.getElementById('team-banner'), {
                    team: currentTeam,
                    teamId: teamId,
                    active: 'chat',
                    accessLevel,
                    exitUrl
                });

                // Load messages (real-time)
                startRealtimeUpdates();

                // Setup event listeners
                setupEventListeners();

            } catch (error) {
                console.error('Error initializing chat:', error);
                showError('Failed to load chat. Please try again.');
            }
        });

        async function loadMessages(loadMore = false) {
            try {
                if (!loadMore) {
                    return;
                }

                const cursor = olderMessages.length > 0 ? olderMessages[0]._doc : liveOldestDoc;
                if (!cursor) {
                    hasMoreMessages = false;
                    updateLoadMoreButton();
                    return;
                }

                const newMessages = await getChatMessages(teamId, { limit: 50, startAfterDoc: cursor });

                if (newMessages.length < 50) {
                    hasMoreMessages = false;
                }

                const olderBatch = newMessages.reverse();
                if (olderBatch.length > 0) {
                    olderMessages = [...olderBatch, ...olderMessages];
                    await hydrateSenderPhotos(olderBatch);
                    await hydrateReactionUserNames(olderBatch);
                    messages = [...olderMessages, ...liveMessages];
                }

                renderMessages();
                updateLoadMoreButton();

            } catch (error) {
                console.error('Error loading messages:', error);
                document.getElementById('messages-container').innerHTML = `
                    <div class="text-center py-8">
                        <p class="text-red-500 mb-4">Failed to load messages</p>
                        <button onclick="location.reload()" class="text-primary-600 hover:text-primary-700 font-medium">
                            Retry
                        </button>
                    </div>
                `;
            }
        }

        function startRealtimeUpdates() {
            if (unsubscribeChat) {
                unsubscribeChat();
            }
            initialSnapshotLoaded = false;
            liveMessages = [];
            liveOldestDoc = null;

            unsubscribeChat = subscribeToChatMessages(teamId, { limit: 50 }, async (newMessages, oldestDoc) => {
                const container = document.getElementById('messages-container');
                const wasNearBottom = isNearBottom(container);

                liveOldestDoc = oldestDoc;
                liveMessages = newMessages.reverse();

                if (olderMessages.length === 0) {
                    hasMoreMessages = newMessages.length === 50;
                }

                await hydrateSenderPhotos(liveMessages);
                await hydrateReactionUserNames(liveMessages);
                messages = [...olderMessages, ...liveMessages];
                renderMessages();
                updateLoadMoreButton();

                if (!initialSnapshotLoaded) {
                    initialSnapshotLoaded = true;
                    scrollToBottom();
                    if (currentUser?.uid) {
                        updateChatLastRead(currentUser.uid, teamId).catch(err =>
                            console.warn('Failed to update last read:', err)
                        );
                    }
                } else if (pendingScrollToBottom || wasNearBottom) {
                    scrollToBottom();
                }
                pendingScrollToBottom = false;
            });
        }

        function renderMessages() {
            const container = document.getElementById('messages-container');

            if (messages.length === 0) {
                container.innerHTML = `
                    <div class="text-center py-12 text-gray-500">
                        <svg class="w-16 h-16 mx-auto mb-4 text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"></path>
                        </svg>
                        <p class="font-medium">No messages yet</p>
                        <p class="text-sm">Be the first to send a message!</p>
                    </div>
                `;
                return;
            }

            let html = messages.map(msg => renderMessage(msg)).join('');
            if (aiUiPending) {
                html += `
                    <div id="ai-thinking-placeholder" class="flex justify-start gap-2">
                        <img src="img/logo_small.png" class="w-8 h-8 rounded-full object-cover border border-indigo-200">
                        <div class="max-w-[75%]">
                            <div class="text-xs text-gray-500 mb-1">
                                <span class="font-medium">ALL PLAYS</span>
                                <span class="ml-1 italic">thinkingâ€¦</span>
                            </div>
                            <div class="bg-indigo-50 text-gray-900 border border-indigo-100 rounded-lg px-4 py-2 rounded-bl-sm">
                                <p class="text-sm">Working on thatâ€¦</p>
                            </div>
                        </div>
                    </div>
                `;
            }
            container.innerHTML = html;
        }

        async function hydrateSenderPhotos(messageList) {
            const missing = new Set();
            messageList.forEach(msg => {
                if (!msg.senderPhotoUrl && msg.senderId && !senderPhotoCache.has(msg.senderId)) {
                    missing.add(msg.senderId);
                }
            });

            if (missing.size === 0) return;

            await Promise.all(Array.from(missing).map(async (senderId) => {
                try {
                    const profile = await getUserProfile(senderId);
                    if (profile?.photoUrl) {
                        senderPhotoCache.set(senderId, profile.photoUrl);
                    } else {
                        senderPhotoCache.set(senderId, null);
                    }
                } catch (err) {
                    console.warn('Failed to load sender profile for chat avatar:', err);
                    senderPhotoCache.set(senderId, null);
                }
            }));

            messageList.forEach(msg => {
                if (!msg.senderPhotoUrl && msg.senderId && senderPhotoCache.has(msg.senderId)) {
                    msg.senderPhotoUrl = senderPhotoCache.get(msg.senderId);
                }
            });
        }

        async function hydrateReactionUserNames(messageList) {
            const missing = new Set();
            messageList.forEach((msg) => {
                const reactions = normalizeMessageReactions(msg);
                Object.values(reactions).forEach((users) => {
                    users.forEach((uid) => {
                        if (uid && uid !== currentUser.uid && !reactionUserNameCache.has(uid)) {
                            missing.add(uid);
                        }
                    });
                });
            });

            if (missing.size === 0) return;

            await Promise.all(Array.from(missing).map(async (uid) => {
                try {
                    const profile = await getUserProfile(uid);
                    const name = profile?.fullName || profile?.displayName || profile?.email || `User ${uid.slice(0, 6)}`;
                    reactionUserNameCache.set(uid, name);
                } catch (_) {
                    reactionUserNameCache.set(uid, `User ${uid.slice(0, 6)}`);
                }
            }));
        }

        function getReactionNames(users) {
            const names = users.map((uid) => (uid === currentUser.uid ? 'You' : (reactionUserNameCache.get(uid) || `User ${uid.slice(0, 6)}`)));
            if (names.length <= 4) return names.join(', ');
            return `${names.slice(0, 4).join(', ')} +${names.length - 4} more`;
        }

        function normalizeMessageReactions(msg) {
            const source = (msg && typeof msg.reactions === 'object' && msg.reactions) ? msg.reactions : {};
            const normalized = {};

            CHAT_REACTIONS.forEach(({ key, emoji }) => {
                const byKey = Array.isArray(source[key]) ? source[key] : [];
                const legacyByEmoji = Array.isArray(source[emoji]) ? source[emoji] : [];
                const users = Array.from(new Set([...byKey, ...legacyByEmoji])).filter(Boolean);
                if (users.length > 0) {
                    normalized[key] = users;
                }
            });

            return normalized;
        }

        function renderReactionControls(msg, { isOwn }) {
            const reactions = normalizeMessageReactions(msg);
            const pills = CHAT_REACTIONS
                .map(({ key, emoji }) => {
                    const users = reactions[key] || [];
                    const count = users.length;
                    if (count === 0) return '';
                    const active = users.includes(currentUser.uid);
                    const tooltipActive = activeReactionInfo?.messageId === msg.id && activeReactionInfo?.reactionKey === key;
                    const tooltipText = escapeHtml(getReactionNames(users));
                    return `
                        <div class="relative" data-reaction-ui="true">
                            <button type="button"
                                onclick="window.reactToMessage('${msg.id}', '${key}')"
                                onmouseenter="window.showReactionInfo('${msg.id}', '${key}')"
                                onmouseleave="window.hideReactionInfo('${msg.id}', '${key}')"
                                onfocus="window.showReactionInfo('${msg.id}', '${key}')"
                                onblur="window.hideReactionInfo('${msg.id}', '${key}')"
                                ontouchstart="window.startReactionLongPress(event, '${msg.id}', '${key}')"
                                ontouchend="window.endReactionLongPress()"
                                ontouchcancel="window.endReactionLongPress()"
                                class="inline-flex items-center gap-1 px-2 py-1 rounded-full border text-xs transition ${active ? 'border-primary-300 bg-primary-50 text-primary-700' : 'border-gray-200 bg-white text-gray-600 hover:border-gray-300'}">
                                <span>${emoji}</span>
                                <span class="font-semibold">${count}</span>
                            </button>
                            ${tooltipActive ? `
                                <div class="absolute bottom-full left-1/2 -translate-x-1/2 mb-2 z-30 px-2 py-1 rounded-md bg-gray-900 text-white text-xs whitespace-nowrap shadow-lg" data-reaction-ui="true">
                                    ${tooltipText}
                                </div>
                            ` : ''}
                        </div>
                    `;
                })
                .filter(Boolean)
                .join('');

            const pickerOpen = activeReactionPickerMessageId === msg.id;
            const picker = pickerOpen ? `
                <div class="absolute bottom-full ${isOwn ? 'right-0' : 'left-0'} mb-2 inline-flex items-center gap-1.5 px-2 py-1.5 rounded-full border border-gray-200 bg-white shadow-lg z-20" data-reaction-ui="true">
                    ${CHAT_REACTIONS.map(({ key, emoji }) => `
                        <button type="button" onclick="window.reactToMessage('${msg.id}', '${key}')"
                            class="w-8 h-8 rounded-full border border-gray-200 bg-white hover:bg-gray-50 text-sm" data-reaction-ui="true">
                            ${emoji}
                        </button>
                    `).join('')}
                </div>
            ` : '';

            const alignClass = isOwn ? 'justify-end' : 'justify-start';
            const addBtnState = pickerOpen ? 'opacity-100' : 'opacity-100 sm:opacity-0 sm:group-hover:opacity-100 sm:focus:opacity-100';
            return `
                <div class="mt-1 flex ${alignClass} gap-1.5 flex-wrap" data-reaction-ui="true">
                    <div class="relative inline-flex items-center gap-1.5" data-reaction-ui="true">
                        ${pills}
                        <button type="button" onclick="window.toggleReactionPicker('${msg.id}')" data-reaction-ui="true"
                            class="inline-flex items-center justify-center w-7 h-7 rounded-full border border-gray-200 bg-white text-gray-500 hover:text-primary-600 hover:border-primary-200 transition ${addBtnState}">
                            <span class="text-sm">ðŸ˜Š</span>
                        </button>
                        ${picker}
                    </div>
                </div>
            `;
        }

        function renderMessage(msg) {
            const isAi = msg.ai === true;
            const isOwn = !isAi && msg.senderId === currentUser.uid;
            const isDeleted = msg.deleted === true;
            const displayName = isAi ? (msg.aiName || 'ALL PLAYS') : (msg.senderName || msg.senderEmail || 'Unknown');
            const timestamp = msg.createdAt?.toDate ?
                msg.createdAt.toDate().toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' }) : '';
            const date = msg.createdAt?.toDate ?
                msg.createdAt.toDate().toLocaleDateString() : '';

            if (isDeleted) {
                return `
                    <div class="flex ${isOwn ? 'justify-end' : 'justify-start'}">
                        <div class="max-w-[75%] px-4 py-2 rounded-lg bg-gray-100 text-gray-400 italic text-sm">
                            Message removed
                        </div>
                    </div>
                `;
            }

            const avatar = isAi
                ? `<img src="img/logo_small.png" class="w-8 h-8 rounded-full object-cover border border-indigo-200">`
                : msg.senderPhotoUrl
                    ? `<img src="${escapeHtml(msg.senderPhotoUrl)}" class="w-8 h-8 rounded-full object-cover">`
                    : `<div class="w-8 h-8 rounded-full bg-gray-300 flex items-center justify-center">
                         <span class="text-xs font-bold text-gray-600">${escapeHtml(displayName.charAt(0).toUpperCase())}</span>
                       </div>`;

            const canEdit = isOwn && !!msg.text;
            const canDelete = !isAi && (isOwn || canModerate);
            const hasImage = msg.imageUrl && isSafeUrl(msg.imageUrl);
            const messageImage = hasImage ? `
                <a href="${escapeHtml(msg.imageUrl)}" target="_blank" rel="noopener noreferrer" class="block mb-2">
                    <img src="${escapeHtml(msg.imageUrl)}" alt="${escapeHtml(msg.imageName || 'Chat image')}" class="max-w-full max-h-72 rounded-lg border border-gray-200 object-cover">
                </a>
            ` : '';
            const messageText = msg.text ? `<p class="text-sm whitespace-pre-wrap break-words">${formatMessageText(msg.text)}</p>` : '';
            const reactionControls = renderReactionControls(msg, { isOwn });

            const actions = [];
            if (canEdit) {
                actions.push(`<button onclick="window.editMessage('${msg.id}')" class="text-gray-400 hover:text-primary-600 text-xs">Edit</button>`);
            }
            if (canDelete) {
                actions.push(`<button onclick="window.deleteMessage('${msg.id}')" class="text-gray-400 hover:text-red-600 text-xs">Delete</button>`);
            }

            const bubbleClass = isAi
                ? 'bg-indigo-50 text-gray-900 border border-indigo-100'
                : isOwn
                    ? 'bg-primary-100 text-gray-900'
                    : 'bg-gray-100 text-gray-900';

            if (isOwn) {
                return `
                    <div class="group flex justify-end gap-2">
                        <div class="max-w-[75%]">
                            <div class="text-xs text-gray-500 text-right mb-1">
                                ${msg.editedAt ? '<span class="italic">(edited)</span> ' : ''}${timestamp}
                            </div>
                            <div class="${bubbleClass} rounded-lg px-4 py-2 rounded-br-sm">
                                ${messageImage}${messageText}
                            </div>
                            ${reactionControls}
                            ${actions.length > 0 ? `
                                <div class="flex justify-end gap-2 mt-1">
                                    ${actions.join(' ')}
                                </div>
                            ` : ''}
                        </div>
                        ${avatar}
                    </div>
                `;
            } else {
                return `
                    <div class="group flex justify-start gap-2">
                        ${avatar}
                        <div class="max-w-[75%]">
                            <div class="text-xs text-gray-500 mb-1">
                                <span class="font-medium">${escapeHtml(displayName)}</span>
                                ${msg.editedAt ? '<span class="italic">(edited)</span>' : ''}
                                <span class="ml-1">${timestamp}</span>
                            </div>
                            <div class="${bubbleClass} rounded-lg px-4 py-2 rounded-bl-sm">
                                ${messageImage}${messageText}
                            </div>
                            ${reactionControls}
                            ${actions.length > 0 ? `
                                <div class="flex gap-2 mt-1">
                                    ${actions.join(' ')}
                                </div>
                            ` : ''}
                        </div>
                    </div>
                `;
            }
        }

        function updateLoadMoreButton() {
            const container = document.getElementById('load-more-container');
            const list = document.getElementById('messages-container');
            const totalMessages = olderMessages.length + liveMessages.length;
            if (list && hasMoreMessages && totalMessages >= 50 && isNearTop(list)) {
                container.classList.remove('hidden');
            } else {
                container.classList.add('hidden');
            }
        }

        function scrollToBottom() {
            const container = document.getElementById('messages-container');
            // Use double requestAnimationFrame to ensure scroll happens after full render
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    container.scrollTop = container.scrollHeight;
                });
            });
        }

        function isNearBottom(container) {
            const threshold = 80;
            return container.scrollHeight - container.scrollTop - container.clientHeight <= threshold;
        }

        function isNearTop(container) {
            const threshold = 120;
            return container.scrollTop <= threshold;
        }

        function showError(message) {
            const errorEl = document.getElementById('send-error');
            errorEl.textContent = message;
            errorEl.classList.remove('hidden');
            setTimeout(() => errorEl.classList.add('hidden'), 5000);
        }

        function showAiThinking(show) {
            const el = document.getElementById('ai-thinking');
            if (!el) return;
            if (show) {
                el.classList.remove('hidden');
                aiThinkingStartedAt = Date.now();
            } else {
                el.classList.add('hidden');
                aiThinkingStartedAt = null;
            }
        }

        async function hideAiThinkingWithMinDelay() {
            if (!aiThinkingStartedAt) {
                showAiThinking(false);
                return;
            }
            const minMs = 2000;
            const elapsed = Date.now() - aiThinkingStartedAt;
            if (elapsed < minMs) {
                await new Promise(resolve => setTimeout(resolve, minMs - elapsed));
            }
            showAiThinking(false);
        }

        function formatBytes(bytes) {
            if (!Number.isFinite(bytes) || bytes <= 0) return '';
            if (bytes < 1024) return `${bytes} B`;
            if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
            return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
        }

        function updateComposerState() {
            const input = document.getElementById('message-input');
            const sendBtn = document.getElementById('send-btn');
            sendBtn.disabled = !input.value.trim() && !pendingImageFile;
        }

        function setVoiceButtonState(isListening) {
            const voiceBtn = document.getElementById('voice-btn');
            const hint = document.getElementById('voice-hint');
            voiceBtn.classList.toggle('text-red-600', isListening);
            voiceBtn.classList.toggle('bg-red-50', isListening);
            hint.classList.toggle('hidden', !isListening);
        }

        function stopVoiceCapture() {
            if (activeVoiceRecognition && voiceListening) {
                try {
                    activeVoiceRecognition.stop();
                } catch (_) {}
            }
            voiceListening = false;
            activeVoiceRecognition = null;
            setVoiceButtonState(false);
        }

        function appendTranscriptToInput(transcript) {
            const input = document.getElementById('message-input');
            const clean = String(transcript || '').trim();
            if (!clean) return;
            const spacer = input.value.trim().length > 0 ? ' ' : '';
            input.value = `${input.value}${spacer}${clean}`.trimStart();
            input.focus();
            updateComposerState();
        }

        function toggleVoiceCapture() {
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                showError('Voice input is not supported in this browser.');
                return;
            }

            if (voiceListening && activeVoiceRecognition) {
                stopVoiceCapture();
                return;
            }

            const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
            const recognition = new SR();
            recognition.lang = 'en-US';
            recognition.interimResults = false;
            recognition.continuous = false;

            activeVoiceRecognition = recognition;
            voiceListening = true;
            setVoiceButtonState(true);

            recognition.onresult = (e) => {
                const transcript = e.results?.[0]?.[0]?.transcript || '';
                appendTranscriptToInput(transcript);
            };
            recognition.onerror = (event) => {
                if (event?.error !== 'no-speech' && event?.error !== 'aborted') {
                    showError('Voice recognition failed. Try again.');
                }
            };
            recognition.onend = () => {
                voiceListening = false;
                activeVoiceRecognition = null;
                setVoiceButtonState(false);
            };

            recognition.start();
        }

        function clearSelectedImage() {
            pendingImageFile = null;
            const input = document.getElementById('chat-image-input');
            const preview = document.getElementById('chat-image-preview');
            const previewImg = document.getElementById('chat-image-preview-img');
            const previewName = document.getElementById('chat-image-preview-name');
            const previewSize = document.getElementById('chat-image-preview-size');
            input.value = '';
            previewImg.src = '';
            previewName.textContent = '';
            previewSize.textContent = '';
            preview.classList.add('hidden');
            updateComposerState();
        }

        function setSelectedImage(file) {
            pendingImageFile = file;
            const preview = document.getElementById('chat-image-preview');
            const previewImg = document.getElementById('chat-image-preview-img');
            const previewName = document.getElementById('chat-image-preview-name');
            const previewSize = document.getElementById('chat-image-preview-size');

            previewName.textContent = file.name;
            previewSize.textContent = formatBytes(file.size);

            const reader = new FileReader();
            reader.onload = (e) => {
                previewImg.src = e.target?.result || '';
            };
            reader.readAsDataURL(file);
            preview.classList.remove('hidden');
            updateComposerState();
        }

        function handleImageSelection(event) {
            const file = event.target.files?.[0];
            if (!file) {
                clearSelectedImage();
                return;
            }
            if (!file.type.startsWith('image/')) {
                showError('Please select an image file.');
                clearSelectedImage();
                return;
            }
            if (file.size > MAX_CHAT_IMAGE_SIZE) {
                showError('Image must be 5MB or smaller.');
                clearSelectedImage();
                return;
            }
            setSelectedImage(file);
        }

        function hideMentionMenu() {
            const menu = document.getElementById('mention-menu');
            menu.classList.add('hidden');
            mentionState.active = false;
            mentionState.atPos = null;
        }

        function isMentionMenuOpen() {
            const menu = document.getElementById('mention-menu');
            return mentionState.active && menu && !menu.classList.contains('hidden');
        }

        function updateMentionMenu() {
            const input = document.getElementById('message-input');
            const menu = document.getElementById('mention-menu');
            const cursorPos = input.selectionStart || 0;
            const value = input.value || '';
            const atPos = value.lastIndexOf('@', cursorPos - 1);

            if (atPos === -1) {
                hideMentionMenu();
                return;
            }

            const query = value.slice(atPos + 1, cursorPos);
            if (query.includes(' ') || query.length > 20) {
                hideMentionMenu();
                return;
            }

            mentionState.active = true;
            mentionState.atPos = atPos;
            menu.classList.remove('hidden');
        }

        function insertMention() {
            const input = document.getElementById('message-input');
            const value = input.value || '';
            const cursorPos = input.selectionStart || value.length;
            const atPos = mentionState.atPos;
            if (atPos === null) return;

            const before = value.slice(0, atPos);
            const after = value.slice(cursorPos);
            const mentionText = '@ALL PLAYS ';
            input.value = `${before}${mentionText}${after}`;
            const newCursor = (before + mentionText).length;
            input.setSelectionRange(newCursor, newCursor);
            input.focus();
            hideMentionMenu();
        }

        function shouldFetchStats(question) {
            return /(stats|scorer|score|points|rebounds|assists|goals|saves|leader|leading|top|better|improv|improve|development|progress|player\s*#?\s*\d+)/i.test(question);
        }

        function shouldFetchEvents(question) {
            return /(play\s*by\s*play|play-by-play|timeline|game\s*log|event\s*log|events|possessions|highlights|what happened|sequence)/i.test(question);
        }

        function hasAiMention(text) {
            return (text || '').toLowerCase().includes('@all plays');
        }

        function isCompletedGame(game) {
            const status = (game.status || '').toLowerCase();
            if (status === 'final' || status === 'completed') return true;
            const homeScore = Number(game.homeScore || 0);
            const awayScore = Number(game.awayScore || 0);
            return homeScore > 0 || awayScore > 0;
        }

        function toDate(value) {
            if (!value) return null;
            if (value.toDate) return value.toDate();
            const date = new Date(value);
            return Number.isNaN(date.getTime()) ? null : date;
        }

        function truncateText(text, maxLen) {
            if (!text) return null;
            const clean = String(text).trim();
            if (clean.length <= maxLen) return clean;
            return `${clean.slice(0, maxLen).trim()}â€¦`;
        }

        function serializeGame(game) {
            const date = toDate(game.date);
            return {
                id: game.id,
                date: date ? date.toISOString() : null,
                opponent: game.opponent || null,
                location: game.location || null,
                status: game.status || null,
                homeScore: game.homeScore ?? null,
                awayScore: game.awayScore ?? null,
                summary: truncateText(game.summary, 700)
            };
        }

        function findMatchedPlayer(question, players) {
            const match = question.match(/player\s*#?\s*(\d{1,3})/i);
            if (!match) return null;
            const target = String(Number(match[1]));
            return players.find(p => String(p.number ?? '') === target) || null;
        }

        function serializeEvent(event, playersById) {
            const player = event.playerId ? playersById.get(event.playerId) : null;
            return {
                id: event.id,
                timestamp: event.timestamp ?? null,
                period: event.period ?? null,
                gameTime: event.gameTime ?? null,
                text: event.text || null,
                type: event.type || null,
                playerId: event.playerId || null,
                playerName: player?.name || null,
                playerNumber: player?.number ?? null,
                statKey: event.statKey || null,
                value: event.value ?? null,
                isOpponent: event.isOpponent === true
            };
        }

        async function buildAiContext(question, { fetchStats, fetchEvents }) {
            const [players, games] = await Promise.all([
                getPlayers(teamId),
                getGames(teamId)
            ]);
            const playersById = new Map(players.map(p => [p.id, p]));

            const now = new Date();
            const gamesWithDates = games
                .map(g => ({ ...g, _date: toDate(g.date) }))
                .filter(g => g._date);

            const upcomingGames = gamesWithDates
                .filter(g => g._date >= now)
                .sort((a, b) => a._date - b._date)
                .slice(0, 10)
                .map(serializeGame);

            const recentGames = gamesWithDates
                .filter(g => g._date < now)
                .sort((a, b) => b._date - a._date)
                .slice(0, AI_GAMES_CONTEXT_LIMIT)
                .map(serializeGame);

            let statsSummary = null;
            if (fetchStats) {
                const completedGames = gamesWithDates
                    .filter(isCompletedGame)
                    .sort((a, b) => b._date - a._date)
                    .slice(0, AI_STATS_GAMES_LIMIT);
                const totals = await getAggregatedStatsForGames(teamId, completedGames.map(g => g.id));

                statsSummary = {
                    gamesUsed: completedGames.map(serializeGame),
                    totalsByPlayer: Object.entries(totals).map(([playerId, stats]) => ({
                        id: playerId,
                        name: playersById.get(playerId)?.name || 'Unknown',
                        number: playersById.get(playerId)?.number || null,
                        stats
                    }))
                };
            }

            let eventsSummary = null;
            if (fetchEvents) {
                const recentCompleted = gamesWithDates
                    .filter(isCompletedGame)
                    .sort((a, b) => b._date - a._date)
                    .slice(0, AI_EVENTS_GAMES_LIMIT);

                const eventsByGame = await Promise.all(
                    recentCompleted.map(async (game) => {
                        const events = await getGameEvents(teamId, game.id, { limit: AI_EVENTS_PER_GAME_LIMIT });
                        const ordered = events
                            .slice()
                            .reverse()
                            .map(evt => serializeEvent(evt, playersById));
                        return {
                            game: serializeGame(game),
                            events: ordered
                        };
                    })
                );

                eventsSummary = {
                    gamesUsed: recentCompleted.map(serializeGame),
                    eventsByGame
                };
            }

            return {
                team: {
                    id: teamId,
                    name: currentTeam?.name || null,
                    sport: currentTeam?.sport || null
                },
                players: players.map(p => ({
                    id: p.id,
                    name: p.name || null,
                    number: p.number || null
                })),
                matchedPlayer: (() => {
                    const match = findMatchedPlayer(question, players);
                    if (!match) return null;
                    return {
                        id: match.id,
                        name: match.name || null,
                        number: match.number ?? null
                    };
                })(),
                gamesUpcoming: upcomingGames,
                gamesRecent: recentGames,
                stats: statsSummary,
                playByPlay: eventsSummary
            };
        }

        async function getAiModel() {
            if (aiModelCache) return aiModelCache;
            const firebaseApp = getApp();
            const ai = getAI(firebaseApp, { backend: new GoogleAIBackend() });
            aiModelCache = getGenerativeModel(ai, { model: "gemini-2.5-flash" });
            return aiModelCache;
        }

        function parseJsonObject(text) {
            const match = text.match(/\{[\s\S]*\}/);
            if (!match) return null;
            try {
                return JSON.parse(match[0]);
            } catch (err) {
                return null;
            }
        }

        async function inferDataNeeds(question) {
            if (shouldFetchStats(question) || shouldFetchEvents(question)) {
                return {
                    fetchStats: shouldFetchStats(question),
                    fetchEvents: shouldFetchEvents(question),
                    source: 'heuristic'
                };
            }
            try {
                const model = await getAiModel();
                const prompt = `You are a routing helper. Return ONLY valid JSON.\\n` +
                    `Determine whether stats are needed to answer the question.\\n` +
                    `If the question asks about performance, improvement, rankings, scoring, or a specific player number, set fetchStats=true.\\n` +
                    `Determine whether play-by-play events are needed (timeline, sequence, highlights, game log).\\n` +
                    `JSON format: {"fetchStats": true|false, "fetchEvents": true|false}\\n` +
                    `QUESTION: ${question}`;
                const result = await model.generateContent(prompt);
                const parsed = parseJsonObject(result.response.text().trim());
                if (parsed && typeof parsed.fetchStats === 'boolean') {
                    return {
                        fetchStats: parsed.fetchStats,
                        fetchEvents: parsed.fetchEvents === true,
                        source: 'router'
                    };
                }
            } catch (err) {
                console.warn('AI router failed, falling back to heuristic.', err);
            }
            return { fetchStats: false, fetchEvents: false, source: 'fallback' };
        }

        async function askAllPlays(question, { fetchStats, fetchEvents }) {
            const context = await buildAiContext(question, { fetchStats, fetchEvents });
            const prompt = `You are ALL PLAYS, a sports management expert for youth teams.\\n` +
                `You are speaking to coaches, admins, and parents.\\n` +
                `Use ONLY the provided DATA to answer. If the data is insufficient, say so.\\n` +
                `Respond in a clear, readable format with short paragraphs or bullet points.\\n` +
                `Limit to at most 6 bullets total.\\n` +
                `When you use bullets, start each bullet with "- " (dash + space).\\n` +
                `Use *bold* only for short labels, not full sentences.\\n` +
                `Do not use "*" as a bullet character.\\n` +
                `When referencing dates/times, prefer a readable format (e.g., \"Tue Jan 6, 7:07 PM\").\\n` +
                `If the question is about stats, summarize with top performers and include key numbers.\\n` +
                `If game summaries are provided, use them to mention recent performance or highlights.\\n` +
                `If play-by-play events are provided, use them to answer timeline or highlight questions.\\n` +
                `If individual stats are missing, give 3-5 general improvement tips aligned to the team's sport and ask a short follow-up question.\\n\\n` +
                `QUESTION:\\n${question}\\n\\n` +
                `DATA (JSON):\\n${JSON.stringify(context)}\\n`;

            const model = await getAiModel();
            const result = await model.generateContent(prompt);
            return result.response.text();
        }

        async function handleAiMention(rawText) {
            if (aiInFlight) return;
            const question = rawText.replace(AI_MENTION_REGEX, '').trim();
            if (!question) {
                showError('Ask a question after @ALL PLAYS.');
                return;
            }

            aiInFlight = true;
            showAiThinking(true);
            try {
                const needs = await inferDataNeeds(question);
                const responseText = await askAllPlays(question, needs);
                await postChatMessage(teamId, {
                    text: responseText,
                    senderId: currentUser.uid,
                    senderName: null,
                    senderEmail: null,
                    senderPhotoUrl: null,
                    ai: true,
                    aiName: 'ALL PLAYS',
                    aiQuestion: question,
                    aiMeta: {
                        statsGameLimit: AI_STATS_GAMES_LIMIT,
                        gamesContextLimit: AI_GAMES_CONTEXT_LIMIT,
                        statsRequested: needs.fetchStats,
                        eventsGameLimit: AI_EVENTS_GAMES_LIMIT,
                        eventsPerGameLimit: AI_EVENTS_PER_GAME_LIMIT,
                        eventsRequested: needs.fetchEvents,
                        statsRequestSource: needs.source
                    }
                });
            } catch (error) {
                console.error('ALL PLAYS error:', error);
                showError('ALL PLAYS could not answer. Please try again.');
            } finally {
                aiInFlight = false;
                await hideAiThinkingWithMinDelay();
                aiUiPending = false;
                renderMessages();
            }
        }

        window.toggleReactionPicker = function(messageId) {
            activeReactionPickerMessageId = activeReactionPickerMessageId === messageId ? null : messageId;
            activeReactionInfo = null;
            renderMessages();
        };

        window.showReactionInfo = function(messageId, reactionKey) {
            if (activeReactionInfo?.messageId === messageId && activeReactionInfo?.reactionKey === reactionKey) return;
            activeReactionInfo = { messageId, reactionKey };
            renderMessages();
        };

        window.hideReactionInfo = function(messageId, reactionKey) {
            if (!activeReactionInfo) return;
            if (activeReactionInfo.messageId !== messageId || activeReactionInfo.reactionKey !== reactionKey) return;
            activeReactionInfo = null;
            renderMessages();
        };

        window.startReactionLongPress = function(event, messageId, reactionKey) {
            if (!event?.touches || event.touches.length !== 1) return;
            if (reactionLongPress.timer) {
                clearTimeout(reactionLongPress.timer);
                reactionLongPress.timer = null;
            }
            const opKey = `${messageId}:${reactionKey}`;
            reactionLongPress.key = opKey;
            reactionLongPress.timer = setTimeout(() => {
                reactionLongPress.suppressUntil = Date.now() + 650;
                activeReactionInfo = { messageId, reactionKey };
                renderMessages();
            }, 450);
        };

        window.endReactionLongPress = function() {
            if (reactionLongPress.timer) {
                clearTimeout(reactionLongPress.timer);
                reactionLongPress.timer = null;
            }
        };

        window.reactToMessage = async function(messageId, reactionKey) {
            const msg = messages.find(m => m.id === messageId);
            if (!msg || msg.deleted) return;
            if (!CHAT_REACTION_BY_KEY.has(reactionKey)) return;

            const opKey = `${messageId}:${reactionKey}`;
            if (reactionLongPress.key === opKey && Date.now() < reactionLongPress.suppressUntil) return;
            if (pendingReactionOps.has(opKey)) return;
            pendingReactionOps.add(opKey);

            try {
                await toggleChatReaction(teamId, messageId, reactionKey, currentUser.uid);
                activeReactionPickerMessageId = null;
                activeReactionInfo = null;
            } catch (error) {
                console.error('Error toggling reaction:', error);
                showError('Failed to update reaction. Please try again.');
            } finally {
                pendingReactionOps.delete(opKey);
            }
        };

        function setupEventListeners() {
            // Send button
            document.getElementById('send-btn').addEventListener('click', triggerSend);
            document.getElementById('voice-btn').addEventListener('click', toggleVoiceCapture);
            document.getElementById('image-btn').addEventListener('click', () => {
                document.getElementById('chat-image-input').click();
            });
            document.getElementById('chat-image-input').addEventListener('change', handleImageSelection);
            document.getElementById('chat-image-remove-btn').addEventListener('click', clearSelectedImage);

            // Enter key to send
            document.getElementById('message-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    triggerSend();
                }
            });

            // Refresh button
            document.getElementById('refresh-btn').addEventListener('click', async () => {
                const btn = document.getElementById('refresh-btn');
                btn.disabled = true;
                document.getElementById('messages-container').innerHTML = `
                    <div class="text-center py-8">
                        <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-primary-600 mx-auto mb-2"></div>
                        <p class="text-sm text-gray-500">Loading messages...</p>
                    </div>
                `;
                messages = [];
                olderMessages = [];
                liveMessages = [];
                liveOldestDoc = null;
                hasMoreMessages = true;
                activeReactionPickerMessageId = null;
                activeReactionInfo = null;
                startRealtimeUpdates();
                btn.disabled = false;
            });

            // Load more button
            document.getElementById('load-more-btn').addEventListener('click', async () => {
                const btn = document.getElementById('load-more-btn');
                btn.disabled = true;
                btn.textContent = 'Loading...';

                const container = document.getElementById('messages-container');
                const scrollHeightBefore = container.scrollHeight;

                await loadMessages(true);

                // Maintain scroll position
                const scrollHeightAfter = container.scrollHeight;
                container.scrollTop = scrollHeightAfter - scrollHeightBefore;

                btn.disabled = false;
                btn.textContent = 'Load older messages...';
            });

            // Show load-older only when scrolling up
            const messagesContainer = document.getElementById('messages-container');
            if (messagesContainer) {
                messagesContainer.addEventListener('scroll', () => {
                    updateLoadMoreButton();
                });
            }

            // Edit modal
            document.getElementById('edit-cancel-btn').addEventListener('click', closeEditModal);
            document.getElementById('edit-save-btn').addEventListener('click', saveEdit);

            // Close modal on backdrop click
            document.getElementById('edit-modal').addEventListener('click', (e) => {
                if (e.target === e.currentTarget) {
                    closeEditModal();
                }
            });

            // Disable send when empty
            const input = document.getElementById('message-input');
            const sendBtn = document.getElementById('send-btn');
            input.addEventListener('input', () => {
                updateComposerState();
                updateMentionMenu();
            });
            input.addEventListener('keydown', (e) => {
                if (isMentionMenuOpen()) {
                    const acceptKeys = ['Tab', 'ArrowDown', 'ArrowUp'];
                    if (acceptKeys.includes(e.key) || (e.key === 'Enter' && !e.shiftKey)) {
                        e.preventDefault();
                        e.stopPropagation();
                        insertMention();
                        return;
                    }
                }
                if (e.key === 'Escape') {
                    hideMentionMenu();
                }
            });
            input.addEventListener('blur', () => {
                setTimeout(() => hideMentionMenu(), 150);
            });
            document.getElementById('mention-allplays').addEventListener('click', insertMention);
            document.addEventListener('click', (e) => {
                const menu = document.getElementById('mention-menu');
                if (!menu.contains(e.target) && e.target !== input) {
                    hideMentionMenu();
                }
                if (!e.target.closest('[data-reaction-ui="true"]')) {
                    const hadPicker = activeReactionPickerMessageId !== null;
                    const hadInfo = activeReactionInfo !== null;
                    activeReactionPickerMessageId = null;
                    activeReactionInfo = null;
                    if (hadPicker || hadInfo) {
                        renderMessages();
                    }
                }
            });
            document.addEventListener('touchend', () => window.endReactionLongPress(), { passive: true });
            window.addEventListener('beforeunload', stopVoiceCapture);
            sendBtn.disabled = true;
            updateComposerState();
        }

        function triggerSend() {
            const input = document.getElementById('message-input');
            const text = input.value.trim();
            if (/@all\s*plays/i.test(text)) {
                aiUiPending = true;
                renderMessages();
                scrollToBottom();
                showAiThinking(true);
            }
            sendMessage();
        }

        async function sendMessage() {
            const input = document.getElementById('message-input');
            const sendBtn = document.getElementById('send-btn');
            const voiceBtn = document.getElementById('voice-btn');
            const imageBtn = document.getElementById('image-btn');
            const text = input.value.trim();
            const imageFile = pendingImageFile;
            const wantsAi = /@all\s*plays/i.test(text);

            if (!text && !imageFile) return;

            sendBtn.disabled = true;
            sendBtn.textContent = imageFile ? 'Uploading...' : 'Sending...';
            voiceBtn.disabled = true;
            imageBtn.disabled = true;
            stopVoiceCapture();

            try {
                let imagePayload = null;
                if (imageFile) {
                    imagePayload = await uploadChatImage(teamId, imageFile);
                }
                pendingScrollToBottom = true;
                await postChatMessage(teamId, {
                    text,
                    senderId: currentUser.uid,
                    senderName: currentUserProfile?.fullName || null,
                    senderEmail: currentUser.email,
                    senderPhotoUrl: currentUserProfile?.photoUrl || null,
                    imageUrl: imagePayload?.url || null,
                    imagePath: imagePayload?.path || null,
                    imageName: imagePayload?.name || null,
                    imageType: imagePayload?.type || null,
                    imageSize: imagePayload?.size || null
                });

                input.value = '';
                clearSelectedImage();
                document.getElementById('send-error').classList.add('hidden');
                scrollToBottom();
                hideMentionMenu();

                if (wantsAi) {
                    handleAiMention(text);
                }

            } catch (error) {
                console.error('Error sending message:', error);
                showError('Failed to send message. Please try again.');
                pendingScrollToBottom = false;
            } finally {
                voiceBtn.disabled = false;
                imageBtn.disabled = false;
                sendBtn.textContent = 'Send';
                updateComposerState();
            }
        }

        // Edit functionality
        let editingMessageId = null;

        window.editMessage = function(messageId) {
            const msg = messages.find(m => m.id === messageId);
            if (!msg || msg.deleted || !msg.text) return;

            editingMessageId = messageId;
            document.getElementById('edit-textarea').value = msg.text;
            document.getElementById('edit-modal').classList.remove('hidden');
            document.getElementById('edit-textarea').focus();
        };

        function closeEditModal() {
            document.getElementById('edit-modal').classList.add('hidden');
            editingMessageId = null;
        }

        async function saveEdit() {
            if (!editingMessageId) return;

            const newText = document.getElementById('edit-textarea').value.trim();
            if (!newText) {
                alert('Message cannot be empty');
                return;
            }

            const saveBtn = document.getElementById('edit-save-btn');
            saveBtn.disabled = true;
            saveBtn.textContent = 'Saving...';

            try {
                await editChatMessage(teamId, editingMessageId, newText);
                closeEditModal();

            } catch (error) {
                console.error('Error editing message:', error);
                alert('Failed to edit message. Please try again.');
            } finally {
                saveBtn.disabled = false;
                saveBtn.textContent = 'Save';
            }
        }

        // Delete functionality
        window.deleteMessage = async function(messageId) {
            if (!confirm('Delete this message?')) return;

            try {
                await deleteChatMessage(teamId, messageId);

            } catch (error) {
                console.error('Error deleting message:', error);
                alert('Failed to delete message. Please try again.');
            }
        };
    </script>
</body>

</html>
