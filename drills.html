<!DOCTYPE html>
<html lang="en">

<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-3J13LHWFT3"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-3J13LHWFT3');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" href="img/logo_small.png">
    <title>Practice Command Center - ALL PLAYS</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="css/styles.css">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: {
                            50: '#eef2ff', 100: '#e0e7ff', 200: '#c7d2fe', 300: '#a5b4fc',
                            400: '#818cf8', 500: '#6366f1', 600: '#4f46e5', 700: '#4338ca',
                            800: '#3730a3', 900: '#312e81'
                        }
                    }
                }
            }
        }
    </script>
    <style>
        .type-warmup { background: #dcfce7; color: #166534; }
        .type-tactical { background: #dbeafe; color: #1e40af; }
        .type-technical { background: #f3e8ff; color: #6b21a8; }
        .type-physical { background: #ffedd5; color: #9a3412; }
        .type-game { background: #fee2e2; color: #991b1b; }
        .bar-warmup { background: #4ade80; }
        .bar-tactical { background: #60a5fa; }
        .bar-technical { background: #a78bfa; }
        .bar-physical { background: #fb923c; }
        .bar-game { background: #f87171; }
        .drag-handle { cursor: grab; }
        .drag-handle:active { cursor: grabbing; }
        .card-hover:hover { transform: translateY(-2px); box-shadow: 0 8px 25px rgba(0,0,0,0.1); }
        .card-hover { transition: all 0.2s ease; }
        .scroll-thin::-webkit-scrollbar { width: 4px; }
        .scroll-thin::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 2px; }
        .expand-content { max-height: 0; overflow: hidden; transition: max-height 0.3s ease; }
        .expand-content.open { max-height: 800px; }
        .pulse-ring { animation: pulse-ring 2s cubic-bezier(0.215, 0.61, 0.355, 1) infinite; }
        @keyframes pulse-ring {
            0% { box-shadow: 0 0 0 0 rgba(99, 102, 241, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(99, 102, 241, 0); }
            100% { box-shadow: 0 0 0 0 rgba(99, 102, 241, 0); }
        }
        .chat-bubble-user { background: #e0e7ff; border-radius: 16px 16px 4px 16px; }
        .chat-bubble-ai { background: #f1f5f9; border-radius: 16px 16px 16px 4px; }
        .practice-canvas-height { height: calc(100vh - 260px); min-height: 400px; }
        .attendance-btn { border: 1px solid #4b5563; color: #9ca3af; transition: all 0.15s ease; }
        .attendance-btn.active-present { background: #14532d; border-color: #22c55e; color: #bbf7d0; }
        .attendance-btn.active-late { background: #78350f; border-color: #f59e0b; color: #fde68a; }
        .attendance-btn.active-absent { background: #7f1d1d; border-color: #ef4444; color: #fecaca; }
    </style>
</head>

<body class="bg-gray-50 text-gray-900">
    <div id="header-container"></div>

    <main class="container mx-auto px-4 py-6">
        <!-- Team Admin Banner -->
        <div id="team-banner" class="mb-4"></div>

        <!-- Loading State -->
        <div id="loading-state" class="text-center py-16 bg-white rounded-2xl shadow-md border border-gray-200">
            <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-primary-600 mx-auto mb-4"></div>
            <p class="text-gray-500">Loading Practice Command Center...</p>
        </div>

        <!-- Main Content (hidden until loaded) -->
        <div id="main-content" class="hidden">

            <!-- Mode Toggle Bar -->
            <div class="bg-white rounded-xl shadow-sm border border-gray-200 p-3 mb-4 flex flex-wrap items-center justify-between gap-3">
                <div class="flex items-center gap-2">
                    <button id="btn-mode-plan" onclick="setMode('planning')" class="px-4 py-2 text-sm font-medium rounded-lg bg-primary-600 text-white">Planning</button>
                    <button id="btn-mode-practice" onclick="setMode('practice')" class="px-4 py-2 text-sm font-medium rounded-lg bg-gray-100 text-gray-600 hover:bg-gray-200">Practice</button>
                    <button id="btn-mode-library" onclick="setMode('library')" class="px-4 py-2 text-sm font-medium rounded-lg bg-gray-100 text-gray-600 hover:bg-gray-200">Drill Library</button>
                </div>
                <div class="flex items-center gap-2" id="session-meta-bar">
                    <input type="date" id="session-date" class="text-sm border border-gray-200 rounded-lg px-2 py-1.5 focus:ring-2 focus:ring-primary-500">
                    <div class="flex items-center gap-1">
                        <input type="number" id="session-duration" value="60" min="15" max="180" step="5" class="w-14 text-sm text-center border border-gray-200 rounded-lg px-1 py-1.5 focus:ring-2 focus:ring-primary-500">
                        <span class="text-xs text-gray-500">min</span>
                    </div>
                    <span id="timeline-gap-banner" class="text-[10px] font-medium px-2 py-1 rounded-full bg-amber-100 text-amber-700">Gap: 60 min</span>
                    <button id="btn-share-session" onclick="sharePracticePlan()" class="px-3 py-1.5 text-xs font-medium rounded-lg bg-white text-gray-700 border border-gray-200 hover:bg-gray-50 flex items-center gap-1">
                        <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.684 13.342A3 3 0 017.5 9h9a3 3 0 011.184 5.342M15.316 10.658A3 3 0 0116.5 15h-9a3 3 0 01-1.184-5.342"/></svg>
                        Share
                    </button>
                    <button id="btn-save-session" onclick="saveSession()" class="px-3 py-1.5 text-xs font-medium rounded-lg bg-primary-50 text-primary-700 border border-primary-200 hover:bg-primary-100">Save Draft</button>
                    <button onclick="setMode('practice')" class="px-3 py-1.5 text-xs font-medium rounded-lg bg-primary-600 text-white hover:bg-primary-700 flex items-center gap-1">
                        <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"/><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/></svg>
                        Start Practice
                    </button>
                </div>
            </div>

            <!-- ==================== PLANNING MODE ==================== -->
            <div id="view-planning" class="grid grid-cols-12 gap-4">
                <!-- LEFT: Context Rail -->
                <div class="col-span-12 lg:col-span-3 bg-white rounded-xl border border-gray-200 p-4 overflow-y-auto scroll-thin practice-canvas-height">
                    <h3 class="text-xs font-bold uppercase tracking-wider text-gray-400 mb-3">Game Intelligence</h3>
                    <div id="context-games" class="space-y-3 mb-6">
                        <p class="text-xs text-gray-400 italic">Loading recent games...</p>
                    </div>
                    <h3 class="text-xs font-bold uppercase tracking-wider text-gray-400 mb-3">Stat Trends</h3>
                    <div id="context-trends" class="space-y-2 mb-6">
                        <p class="text-xs text-gray-400 italic">No trend data available yet.</p>
                    </div>
                    <h3 class="text-xs font-bold uppercase tracking-wider text-gray-400 mb-3">Narrative Readout</h3>
                    <div id="context-ai-narrative" class="space-y-2 mb-6">
                        <p class="text-xs text-gray-400 italic">Evaluating recent game narratives...</p>
                    </div>
                    <h3 class="text-xs font-bold uppercase tracking-wider text-gray-400 mb-3">Player Highlights</h3>
                    <div id="context-players" class="space-y-2">
                        <p class="text-xs text-gray-400 italic">Loading player context...</p>
                    </div>
                    <h3 class="text-xs font-bold uppercase tracking-wider text-gray-400 mb-3 mt-6">Coach Focus</h3>
                    <div id="context-coach-focus" class="space-y-2">
                        <p class="text-xs text-gray-400 italic">Preparing focus recommendation...</p>
                    </div>
                    <h3 class="text-xs font-bold uppercase tracking-wider text-gray-400 mb-3 mt-6">Last Practice Notes</h3>
                    <div id="context-last-practice-notes" class="space-y-2">
                        <p class="text-xs text-gray-400 italic">Loading notes from the previous practice...</p>
                    </div>
                </div>

                <!-- CENTER: AI Coach Chat -->
                <div class="col-span-12 lg:col-span-4 bg-white rounded-xl border border-gray-200 flex flex-col practice-canvas-height">
                    <div class="p-4 border-b border-gray-100">
                        <div class="flex items-center gap-2">
                            <div class="w-8 h-8 bg-gradient-to-br from-primary-400 to-primary-600 rounded-full flex items-center justify-center">
                                <svg class="w-4 h-4 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"/></svg>
                            </div>
                            <div>
                                <h3 class="text-sm font-semibold text-gray-800">ALL PLAYS COACH</h3>
                                <p class="text-xs text-gray-400">Powered by Gemini 2.5 Flash</p>
                            </div>
                        </div>
                    </div>
                    <div id="chat-messages" class="flex-1 overflow-y-auto p-4 space-y-4 scroll-thin">
                        <div class="chat-bubble-ai px-4 py-3 max-w-[90%]">
                            <p class="text-sm text-gray-700">Welcome! I can help plan your practice session. Try:</p>
                            <ul class="text-sm text-gray-500 mt-2 space-y-1 list-disc pl-4">
                                <li>"Plan for 8 kids, focus on finishing"</li>
                                <li>"Add a rondo drill after warm-up"</li>
                                <li>"Shorten the session to 45 minutes"</li>
                            </ul>
                        </div>
                    </div>
                    <div class="p-4 border-t border-gray-100">
                        <div class="flex items-center gap-2">
                            <input type="text" id="chat-input" placeholder="Ask ALL PLAYS..." class="flex-1 px-4 py-2.5 border border-gray-200 rounded-xl text-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent" onkeydown="if(event.key==='Enter')sendChat()">
                            <button id="chat-send-btn" onclick="sendChat()" class="p-2.5 bg-primary-600 text-white rounded-xl hover:bg-primary-700 disabled:opacity-60 disabled:cursor-not-allowed">
                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"/></svg>
                            </button>
                        </div>
                    </div>
                </div>

                <!-- RIGHT: Practice Canvas -->
                <div class="col-span-12 lg:col-span-5 bg-white rounded-xl border border-gray-200 p-4 overflow-y-auto scroll-thin practice-canvas-height">
                    <div class="flex items-center justify-between mb-4">
                        <h3 class="text-sm font-bold text-gray-700">Practice Timeline</h3>
                        <div class="flex items-center gap-2 flex-wrap justify-end">
                            <span id="canvas-total" class="text-xs text-gray-400">Total: 0 min</span>
                            <span id="canvas-gap" class="text-xs font-medium px-2 py-1 rounded-full bg-gray-100 text-gray-600">Unallocated: 60 min</span>
                            <button onclick="generateHomePacket()" class="px-2.5 py-1 text-xs font-medium rounded-lg bg-white border border-gray-200 hover:bg-gray-50 text-gray-600 flex items-center gap-1">
                                <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6"/></svg>
                                Home Packet
                            </button>
                        </div>
                    </div>
                    <div id="canvas-blocks" class="space-y-3">
                        <p id="canvas-empty" class="text-sm text-gray-400 text-center py-8">No drills added yet. Browse the library or ask the AI Coach to build a plan.</p>
                    </div>
                    <button onclick="setMode('library')" class="w-full mt-3 py-3 border-2 border-dashed border-gray-300 rounded-xl text-sm text-gray-400 hover:border-primary-300 hover:text-primary-500 hover:bg-primary-50 transition flex items-center justify-center gap-2">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"/></svg>
                        Add Drill from Library
                    </button>
                </div>
            </div>

            <!-- ==================== PRACTICE MODE ==================== -->
            <div id="view-practice" class="hidden">
                <div class="min-h-[calc(100vh-260px)] bg-gray-900 text-white rounded-xl flex flex-col">
                    <div class="flex items-center justify-between px-6 py-3 bg-gray-800 rounded-t-xl">
                        <div class="flex items-center gap-3">
                            <div class="w-2 h-2 rounded-full bg-green-400 pulse-ring"></div>
                            <span class="text-sm font-medium text-gray-300">Practice Active</span>
                        </div>
                        <div class="flex items-center gap-3">
                            <span id="practice-drill-counter" class="text-xs text-gray-400">Drill 1 of 0</span>
                            <span id="practice-attendance-summary" class="text-[10px] font-medium px-2 py-1 rounded-full bg-gray-700 text-gray-200">Checked in: 0/0</span>
                            <button onclick="setMode('planning')" class="px-3 py-1.5 text-xs font-medium rounded-lg bg-gray-700 text-gray-300 hover:bg-gray-600">Exit to Planning</button>
                            <button onclick="completePractice()" class="px-3 py-1.5 text-xs font-medium rounded-lg bg-emerald-600 text-white hover:bg-emerald-500">Complete Practice</button>
                        </div>
                    </div>
                    <div class="flex-1 flex flex-col items-center justify-center px-6 py-8">
                        <div class="text-center mb-6">
                            <span id="practice-type-badge" class="type-warmup text-xs font-bold px-3 py-1 rounded-full uppercase">Warm-up</span>
                            <h2 id="practice-drill-title" class="text-3xl font-bold mt-3">No Drills</h2>
                            <p id="practice-drill-desc" class="text-gray-400 text-sm mt-1">Add drills to get started</p>
                        </div>
                        <div class="relative mb-6">
                            <div class="w-56 h-56 sm:w-64 sm:h-64 rounded-full border-4 border-primary-500 flex items-center justify-center bg-gray-800/50">
                                <div class="text-center">
                                    <div id="practice-timer" class="text-6xl sm:text-7xl font-mono font-bold tracking-tight">0:00</div>
                                    <div class="text-sm text-gray-400 mt-1">remaining</div>
                                </div>
                            </div>
                        </div>
                        <div class="flex items-center gap-4 mb-8">
                            <button onclick="practicePrev()" class="w-14 h-14 rounded-full bg-gray-700 hover:bg-gray-600 flex items-center justify-center">
                                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12.066 11.2a1 1 0 000 1.6l5.334 4A1 1 0 0019 16V8a1 1 0 00-1.6-.8l-5.333 4zM4.066 11.2a1 1 0 000 1.6l5.334 4A1 1 0 0011 16V8a1 1 0 00-1.6-.8l-5.334 4z"/></svg>
                            </button>
                            <button id="practice-play-btn" onclick="practiceToggle()" class="w-16 h-16 rounded-full bg-primary-600 hover:bg-primary-700 flex items-center justify-center shadow-lg shadow-primary-500/30">
                                <svg id="practice-play-icon" class="w-8 h-8" fill="currentColor" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
                            </button>
                            <button onclick="practiceNext()" class="w-14 h-14 rounded-full bg-gray-700 hover:bg-gray-600 flex items-center justify-center">
                                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11.933 12.8a1 1 0 000-1.6L6.6 7.2A1 1 0 005 8v8a1 1 0 001.6.8l5.333-4zM19.933 12.8a1 1 0 000-1.6l-5.333-4A1 1 0 0013 8v8a1 1 0 001.6.8l5.333-4z"/></svg>
                            </button>
                        </div>
                        <button id="practice-next-btn" onclick="practiceNext()" class="w-full max-w-md bg-gradient-to-r from-primary-600 to-primary-700 hover:from-primary-500 hover:to-primary-600 text-white rounded-2xl px-6 py-5 flex items-center justify-between shadow-lg shadow-primary-500/20 transition-all hidden">
                            <div class="text-left">
                                <p class="text-xs text-primary-200 uppercase tracking-wider font-medium">Next Up</p>
                                <p id="practice-next-title" class="text-lg font-bold"></p>
                                <p id="practice-next-meta" class="text-sm text-primary-200"></p>
                            </div>
                            <svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 7l5 5m0 0l-5 5m5-5H6"/></svg>
                        </button>
                        <div class="w-full max-w-md mt-6">
                            <div class="flex justify-between text-xs text-gray-500 mb-1">
                                <span>Session Progress</span>
                                <span id="practice-progress-text">0 of 0 min</span>
                            </div>
                            <div class="w-full bg-gray-700 rounded-full h-2">
                                <div id="practice-progress-bar" class="bg-primary-500 h-2 rounded-full transition-all" style="width: 0%"></div>
                            </div>
                        </div>
                        <div class="w-full max-w-md mt-6 bg-gray-800 border border-gray-700 rounded-2xl p-4">
                            <div class="flex items-center justify-between mb-3">
                                <div>
                                    <p class="text-xs uppercase tracking-wider text-gray-400">Coach Notes</p>
                                    <p class="text-sm font-semibold text-white">Quick Note + Voice Note</p>
                                </div>
                                <button id="notes-toggle-btn" onclick="toggleNotesPanel()" class="text-xs px-2 py-1 rounded-lg bg-gray-700 text-gray-200 hover:bg-gray-600">Collapse</button>
                            </div>
                            <div id="notes-panel-content">
                                <div id="practice-note" class="bg-gray-900 rounded-xl px-4 py-3 border border-gray-700 mb-3 hidden">
                                    <p class="text-xs text-gray-400 mb-1">Coach Note</p>
                                    <p id="practice-note-text" class="text-sm text-gray-200 whitespace-pre-line"></p>
                                </div>
                                <button id="voice-note-btn" onclick="startVoiceNote()" class="flex items-center gap-2 text-sm text-gray-400 hover:text-white">
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z"/></svg>
                                    <span>Start voice note</span>
                                </button>
                                <p id="voice-note-hint" class="mt-1 text-xs text-gray-500">Tap Start voice note, speak, then tap Stop voice note.</p>
                                <div class="mt-3 bg-gray-800 border border-gray-700 rounded-xl p-3">
                                    <p class="text-xs text-gray-400 mb-2">Quick Note</p>
                                    <div class="flex gap-2">
                                        <input type="text" id="practice-free-note-input" placeholder="Type a quick coaching note..." class="flex-1 px-3 py-2 rounded-lg bg-gray-900 border border-gray-700 text-sm text-gray-100 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-primary-500">
                                        <button onclick="addFreeTextNote()" class="px-3 py-2 text-xs font-semibold rounded-lg bg-gray-700 text-gray-100 hover:bg-gray-600">Add</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="w-full max-w-md mt-6 bg-gray-800 border border-gray-700 rounded-2xl p-4">
                            <div class="flex items-center justify-between mb-3">
                                <div>
                                    <p class="text-xs uppercase tracking-wider text-gray-400">Attendance</p>
                                    <p class="text-sm font-semibold text-white">Live Check-in</p>
                                </div>
                                <div class="flex items-center gap-2">
                                    <span id="attendance-count" class="text-xs font-medium px-2 py-1 rounded-lg bg-gray-700 text-gray-200">0 / 0 checked in</span>
                                    <button id="attendance-toggle-btn" onclick="toggleAttendancePanel()" class="text-xs px-2 py-1 rounded-lg bg-gray-700 text-gray-200 hover:bg-gray-600">Collapse</button>
                                </div>
                            </div>
                            <div id="attendance-list" class="space-y-2 text-sm max-h-64 overflow-y-auto scroll-thin"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- ==================== DRILL LIBRARY ==================== -->
            <div id="view-library" class="hidden">
                <div class="flex items-center justify-between mb-4">
                    <div>
                        <h2 class="text-xl font-bold text-gray-800">Drill Library</h2>
                        <p class="text-sm text-gray-500">Browse, filter, and save drills for your team</p>
                    </div>
                    <button id="btn-new-drill" onclick="showDrillForm()" class="px-4 py-2 bg-primary-600 text-white text-sm font-medium rounded-lg hover:bg-primary-700 flex items-center gap-2">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"/></svg>
                        New Drill
                    </button>
                </div>
                <div class="flex gap-1 mb-4 border-b border-gray-200">
                    <button onclick="setLibTab('community')" id="lib-tab-community" class="px-4 py-2.5 text-sm font-medium text-primary-600 border-b-2 border-primary-600">Community</button>
                    <button onclick="setLibTab('mydrills')" id="lib-tab-mydrills" class="px-4 py-2.5 text-sm font-medium text-gray-500 hover:text-gray-700">My Drills</button>
                    <button onclick="setLibTab('favorites')" id="lib-tab-favorites" class="px-4 py-2.5 text-sm font-medium text-gray-500 hover:text-gray-700 flex items-center gap-1">
                        Favorites <span id="fav-count-badge" class="bg-primary-100 text-primary-700 text-[10px] font-bold px-1.5 py-0.5 rounded-full hidden">0</span>
                    </button>
                </div>
                <!-- Filter Bar -->
                <div class="flex flex-wrap items-center gap-3 mb-4 bg-white rounded-xl p-3 border border-gray-200">
                    <select id="filter-type" onchange="loadLibrary()" class="px-3 py-2 border border-gray-200 rounded-lg text-sm text-gray-600 focus:ring-2 focus:ring-primary-500 bg-white">
                        <option value="">All Types</option>
                    </select>
                    <select id="filter-level" onchange="loadLibrary()" class="px-3 py-2 border border-gray-200 rounded-lg text-sm text-gray-600 focus:ring-2 focus:ring-primary-500 bg-white">
                        <option value="">All Levels</option>
                    </select>
                    <select id="filter-skill" onchange="loadLibrary()" class="px-3 py-2 border border-gray-200 rounded-lg text-sm text-gray-600 focus:ring-2 focus:ring-primary-500 bg-white">
                        <option value="">All Skills</option>
                    </select>
                    <div class="flex-1 min-w-[180px]">
                        <div class="relative">
                            <svg class="w-4 h-4 absolute left-3 top-1/2 -translate-y-1/2 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/></svg>
                            <input type="text" id="filter-search" placeholder="Search drills..." oninput="debounceSearch()" class="w-full pl-9 pr-4 py-2 border border-gray-200 rounded-lg text-sm focus:ring-2 focus:ring-primary-500 focus:border-transparent">
                        </div>
                    </div>
                    <span id="lib-result-count" class="text-xs text-gray-400"></span>
                </div>
                <!-- Drill Cards Grid -->
                <div id="lib-cards" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
                    <div class="col-span-full text-center py-12">
                        <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-primary-600 mx-auto mb-3"></div>
                        <p class="text-sm text-gray-400">Loading drills...</p>
                    </div>
                </div>
                <div id="lib-load-more" class="text-center mt-6 hidden">
                    <button onclick="loadMoreDrills()" class="px-6 py-2 text-sm font-medium text-gray-500 bg-white border border-gray-200 rounded-lg hover:bg-gray-50">Load More Drills</button>
                </div>
            </div>

            <!-- ==================== DRILL DETAIL MODAL ==================== -->
            <div id="drill-detail-modal" class="hidden fixed inset-0 z-50">
                <div class="fixed inset-0 bg-black/50" onclick="closeDrillDetail()"></div>
                <div class="fixed inset-y-0 right-0 w-full max-w-2xl bg-white shadow-2xl overflow-y-auto">
                    <div class="sticky top-0 bg-white border-b border-gray-200 px-6 py-4 flex items-center justify-between z-10">
                        <div class="flex items-center gap-3">
                            <span id="detail-type-badge" class="type-technical text-xs font-bold px-2.5 py-1 rounded-full uppercase"></span>
                            <span id="detail-source-label" class="text-xs text-gray-400"></span>
                        </div>
                        <div class="flex items-center gap-2">
                            <button id="detail-fav-btn" onclick="toggleDetailFav()" class="p-1"><svg class="w-6 h-6 text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z"/></svg></button>
                            <button onclick="addDetailToCanvas()" class="px-3 py-1.5 text-xs font-medium rounded-lg bg-primary-600 text-white hover:bg-primary-700">Add to Canvas</button>
                            <button id="detail-edit-btn" onclick="editDrill()" class="px-3 py-1.5 text-xs font-medium rounded-lg bg-gray-100 text-gray-600 hover:bg-gray-200 hidden">Edit</button>
                            <button id="detail-delete-btn" onclick="deleteDrillConfirm()" class="px-3 py-1.5 text-xs font-medium rounded-lg bg-red-50 text-red-600 hover:bg-red-100 hidden">Delete</button>
                            <button onclick="closeDrillDetail()" class="text-gray-400 hover:text-gray-600 p-1">
                                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>
                            </button>
                        </div>
                    </div>
                    <div id="detail-content" class="px-6 py-6"></div>
                </div>
            </div>

            <!-- ==================== CREATE/EDIT DRILL MODAL ==================== -->
            <div id="drill-form-modal" class="hidden fixed inset-0 z-50">
                <div class="fixed inset-0 bg-black/50" onclick="closeDrillForm()"></div>
                <div class="fixed inset-y-0 right-0 w-full max-w-xl bg-white shadow-2xl overflow-y-auto">
                    <div class="sticky top-0 bg-white border-b border-gray-200 px-6 py-4 flex items-center justify-between z-10">
                        <h2 id="form-title" class="text-lg font-bold">New Drill</h2>
                        <button onclick="closeDrillForm()" class="text-gray-400 hover:text-gray-600">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>
                        </button>
                    </div>
                    <form id="drill-form" onsubmit="submitDrillForm(event)" class="px-6 py-6 space-y-4">
                        <input type="hidden" id="form-drill-id" value="">
                        <div class="border border-indigo-100 bg-indigo-50/50 rounded-xl p-3">
                            <div class="flex items-center gap-2 mb-2">
                                <img src="img/logo_small.png" alt="ALL PLAYS COACH" class="w-5 h-5 rounded-full object-cover border border-indigo-200">
                                <p class="text-xs font-semibold text-indigo-700">ALL PLAYS COACH Drill Assistant</p>
                            </div>
                            <div id="form-ai-messages" class="max-h-36 overflow-y-auto space-y-2 bg-white border border-indigo-100 rounded-lg p-2 text-xs"></div>
                            <div class="mt-2 flex items-center gap-2">
                                <input type="text" id="form-ai-input" placeholder="Ask ALL PLAYS to fill this drill..." class="flex-1 px-3 py-2 border border-indigo-100 rounded-lg text-xs focus:outline-none focus:ring-2 focus:ring-primary-500" onkeydown="if(event.key==='Enter'){event.preventDefault();askFormAi();}">
                                <button type="button" id="form-ai-send-btn" onclick="askFormAi()" class="px-3 py-2 text-xs font-semibold rounded-lg bg-primary-600 text-white hover:bg-primary-700">Ask</button>
                            </div>
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">Title *</label>
                            <input type="text" id="form-drill-title" required class="w-full px-3 py-2 border border-gray-200 rounded-lg text-sm focus:ring-2 focus:ring-primary-500">
                        </div>
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-1">Type</label>
                                <select id="form-drill-type" class="w-full px-3 py-2 border border-gray-200 rounded-lg text-sm"></select>
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-1">Level</label>
                                <select id="form-drill-level" class="w-full px-3 py-2 border border-gray-200 rounded-lg text-sm"></select>
                            </div>
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">Skills (comma-separated)</label>
                            <input type="text" id="form-drill-skills" placeholder="passing, shooting, dribbling" class="w-full px-3 py-2 border border-gray-200 rounded-lg text-sm">
                        </div>
                        <div class="grid grid-cols-3 gap-4">
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-1">Duration (min)</label>
                                <input type="number" id="form-drill-duration" min="1" max="120" value="15" class="w-full px-3 py-2 border border-gray-200 rounded-lg text-sm">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-1">Players</label>
                                <input type="text" id="form-drill-players" placeholder="8-16" class="w-full px-3 py-2 border border-gray-200 rounded-lg text-sm">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-1">Cones</label>
                                <input type="number" id="form-drill-cones" min="0" value="0" class="w-full px-3 py-2 border border-gray-200 rounded-lg text-sm">
                            </div>
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">Description</label>
                            <textarea id="form-drill-desc" rows="2" class="w-full px-3 py-2 border border-gray-200 rounded-lg text-sm"></textarea>
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">Instructions</label>
                            <textarea id="form-drill-instructions" rows="6" placeholder="Setup, exercise, progressions, coaching points..." class="w-full px-3 py-2 border border-gray-200 rounded-lg text-sm"></textarea>
                        </div>
                        <label class="flex items-center gap-2">
                            <input type="checkbox" id="form-publish-community" class="rounded text-primary-600">
                            <span class="text-sm text-gray-700">Publish to Community Library</span>
                        </label>
                        <div class="flex gap-3 pt-2">
                            <button type="submit" class="flex-1 px-4 py-2.5 bg-primary-600 text-white text-sm font-medium rounded-lg hover:bg-primary-700">Save Drill</button>
                            <button type="button" onclick="closeDrillForm()" class="px-4 py-2.5 bg-gray-100 text-gray-600 text-sm font-medium rounded-lg hover:bg-gray-200">Cancel</button>
                        </div>
                    </form>
                </div>
            </div>

            <!-- ==================== HOME PACKET MODAL ==================== -->
            <div id="home-packet-modal" class="hidden fixed inset-0 z-50">
                <div class="fixed inset-0 bg-black/50" onclick="closeHomePacket()"></div>
                <div class="fixed inset-y-0 right-0 w-full max-w-lg bg-white shadow-2xl overflow-y-auto">
                    <div class="sticky top-0 bg-white border-b border-gray-200 px-6 py-4 flex items-center justify-between z-10">
                        <div class="flex items-center gap-2">
                            <svg class="w-5 h-5 text-blue-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6"/></svg>
                            <h2 class="text-lg font-bold">Home Practice Packet</h2>
                        </div>
                        <button onclick="closeHomePacket()" class="text-gray-400 hover:text-gray-600">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>
                        </button>
                    </div>
                    <div class="px-6 py-4 border-b border-gray-100 bg-blue-50">
                        <p class="text-xs text-blue-700">Build the at-home timeline: drag to reorder and edit minutes.</p>
                        <div class="mt-2 flex items-center justify-between">
                            <span class="text-xs font-semibold text-blue-800">Total Time</span>
                            <span id="home-packet-total" class="text-xs font-bold px-2 py-1 rounded bg-white text-blue-700 border border-blue-200">0 min</span>
                        </div>
                        <div id="home-packet-completion-summary" class="mt-2 text-[11px] text-emerald-800 bg-emerald-50 border border-emerald-100 rounded px-2 py-1 hidden"></div>
                        <div id="home-packet-add-form" class="mt-3">
                            <div class="flex items-center gap-2">
                                <button id="home-packet-open-library-btn" onclick="openHomePacketLibrary()" class="px-3 py-2 text-xs font-semibold rounded-lg bg-blue-600 text-white hover:bg-blue-700">Add From Library</button>
                                <input type="text" id="home-packet-library-search" placeholder="Search drills..." class="flex-1 px-2 py-1.5 text-xs border border-blue-200 rounded bg-white" oninput="refreshHomePacketLibrary()">
                            </div>
                            <div id="home-packet-library-results" class="hidden mt-2 bg-white border border-blue-100 rounded-lg max-h-48 overflow-y-auto divide-y divide-blue-50"></div>
                        </div>
                    </div>
                    <div id="home-packet-content" class="px-6 py-6 space-y-3"></div>
                    <div class="sticky bottom-0 bg-white border-t border-gray-200 px-6 py-4 flex items-center justify-between gap-2">
                        <button onclick="resetHomePacketFromTimeline()" class="px-3 py-2 text-xs font-semibold rounded-lg bg-gray-100 text-gray-700 hover:bg-gray-200">Reset From Timeline</button>
                        <button onclick="saveHomePacket()" class="px-3 py-2 text-xs font-semibold rounded-lg bg-blue-600 text-white hover:bg-blue-700">Save Home Packet</button>
                    </div>
                </div>
            </div>

            <!-- Toast -->
            <div id="toast" class="hidden fixed bottom-6 right-6 z-50 px-4 py-3 rounded-xl shadow-lg text-sm font-medium transition-all"></div>
        </div>
    </main>

    <div id="footer-container"></div>

    <script type="module">
        import {
            getTeam, getGames, getPlayers, getUserProfile,
            getGameEvents, getAggregatedStatsForGames,
            getDrills, getTeamDrills, getDrill, createDrill, updateDrill, deleteDrill,
            getDrillFavorites, addDrillFavorite, removeDrillFavorite,
            createPracticeSession, updatePracticeSession,
            getPracticeSessionByEvent, upsertPracticeSessionForEvent, updatePracticeAttendance, getPracticeSessions, getPracticePacketCompletions
        } from './js/db.js?v=19';
        import { renderHeader, renderFooter, escapeHtml, shareOrCopy } from './js/utils.js?v=8';
        import { requireAuth } from './js/auth.js?v=9';
        import { renderTeamAdminBanner, getTeamAccessInfo } from './js/team-admin-banner.js?v=3';
        import { DRILL_TYPES, DRILL_LEVELS, DRILL_TYPE_COLORS, getAllSkillTags } from './js/drill-constants.js?v=1';
        import { getAI, getGenerativeModel, GoogleAIBackend } from './js/vendor/firebase-ai.js';
        import { getApp } from './js/vendor/firebase-app.js';

        // ==================== STATE ====================
        const state = {
            teamId: null, team: null, user: null, accessLevel: 'full',
            eventId: null, sourcePage: null,
            favoriteIds: new Set(),
            canvasBlocks: [],
            sessionId: null,
            playerRoster: [],
            attendance: null,
            aiChatHistory: [],
            recentGames: [],
            allGames: [],
            aiRawGameContext: null,
            aiDrillContext: null,
            aiDrillUniverse: null,
            aiDrillUniverseLoadedAt: 0,
            lastPracticeSeed: null,
            gameIntelligence: null,
            chatAvatarCache: new Map(),
            chatAvatarHydrating: false,
            formAiHistory: [],
            currentMode: 'planning',
            libTab: 'community',
            libLastDoc: null,
            currentDetailDrill: null,
            practiceAttendanceCollapsed: false,
            practiceNotesCollapsed: false,
            activeVoiceRecognition: null,
            voiceListening: false,
            durationManuallyEdited: false,
            homePacketBlocks: [],
            homePacketDragIndex: null,
            homePacketLibraryOpen: false,
            homePacketCompletions: [],
            // Practice mode
            practiceIndex: 0,
            practiceRunning: false,
            practiceTimer: null,
            practiceSecondsLeft: 0
        };

        // Expose to inline handlers
        window.setMode = setMode;
        window.setLibTab = setLibTab;
        window.loadLibrary = loadLibrary;
        window.loadMoreDrills = loadMoreDrills;
        window.debounceSearch = debounceSearch;
        window.showDrillForm = showDrillForm;
        window.closeDrillForm = closeDrillForm;
        window.submitDrillForm = submitDrillForm;
        window.closeDrillDetail = closeDrillDetail;
        window.toggleDetailFav = toggleDetailFav;
        window.addDetailToCanvas = addDetailToCanvas;
        window.editDrill = editDrillFromDetail;
        window.deleteDrillConfirm = deleteDrillConfirm;
        window.saveSession = saveSession;
        window.sendChat = sendChat;
        window.generateHomePacket = generateHomePacket;
        window.closeHomePacket = closeHomePacket;
        window.saveHomePacket = saveHomePacket;
        window.resetHomePacketFromTimeline = resetHomePacketFromTimeline;
        window.openHomePacketLibrary = openHomePacketLibrary;
        window.refreshHomePacketLibrary = refreshHomePacketLibrary;
        window.addHomePacketFromLibrary = addHomePacketFromLibrary;
        window.startDragHomePacket = startDragHomePacket;
        window.allowDropHomePacket = allowDropHomePacket;
        window.dropHomePacket = dropHomePacket;
        window.removeHomePacketBlock = removeHomePacketBlock;
        window.practiceToggle = practiceToggle;
        window.practiceNext = practiceNext;
        window.practicePrev = practicePrev;
        window.startVoiceNote = startVoiceNote;
        window.removeCanvasBlock = removeCanvasBlock;
        window.setAttendanceStatus = setAttendanceStatus;
        window.startDragBlock = startDragBlock;
        window.allowDropBlock = allowDropBlock;
        window.dropBlock = dropBlock;
        window.acceptAiProposal = acceptAiProposal;
        window.dismissAiProposal = dismissAiProposal;
        window.toggleProposalBlock = toggleProposalBlock;
        window.selectAllProposalBlocks = selectAllProposalBlocks;
        window.sharePracticePlan = sharePracticePlan;
        window.askFormAi = askFormAi;
        window.toggleAttendancePanel = toggleAttendancePanel;
        window.toggleNotesPanel = toggleNotesPanel;
        window.addFreeTextNote = addFreeTextNote;
        window.completePractice = completePractice;

        function parseHashParams() {
            const raw = window.location.hash.startsWith('#') ? window.location.hash.slice(1) : '';
            const params = new URLSearchParams(raw);
            return {
                teamId: params.get('teamId'),
                eventId: params.get('eventId'),
                source: params.get('source'),
                eventDate: params.get('eventDate'),
                eventDuration: params.get('eventDuration'),
                eventLocation: params.get('eventLocation'),
                eventTitle: params.get('eventTitle')
            };
        }

        // ==================== INIT ====================
        renderFooter(document.getElementById('footer-container'));

        async function init() {
            try {
                const user = await requireAuth();
                const profile = await getUserProfile(user.uid);
                if (profile?.isAdmin) user.isAdmin = true;
                if (profile?.parentOf) user.parentOf = profile.parentOf;
                const resolvedPhoto = user.photoURL
                    || profile?.photoUrl
                    || profile?.photoURL
                    || (Array.isArray(user.providerData) ? user.providerData.find(p => p?.photoURL)?.photoURL : null)
                    || null;
                if (resolvedPhoto) {
                    user.photoURL = resolvedPhoto;
                    user.photoUrl = resolvedPhoto;
                    state.chatAvatarCache.set(user.uid, resolvedPhoto);
                }
                state.user = user;

                renderHeader(document.getElementById('header-container'), user);

                const hashParams = parseHashParams();
                state.teamId = hashParams.teamId;
                state.eventId = hashParams.eventId;
                state.sourcePage = hashParams.source || 'drills';
                state.eventMeta = {
                    date: hashParams.eventDate || null,
                    duration: hashParams.eventDuration ? parseInt(hashParams.eventDuration, 10) : null,
                    location: hashParams.eventLocation || null,
                    title: hashParams.eventTitle || null
                };
                if (!state.teamId) { location.href = 'dashboard.html'; return; }

                state.team = await getTeam(state.teamId);
                if (!state.team) { location.href = 'dashboard.html'; return; }

                const access = getTeamAccessInfo(user, state.team);
                state.accessLevel = access.accessLevel;
                if (!access.hasAccess) { location.href = access.exitUrl; return; }

                renderTeamAdminBanner(document.getElementById('team-banner'), {
                    team: state.team, teamId: state.teamId,
                    active: 'drills', accessLevel: state.accessLevel,
                    exitUrl: access.exitUrl
                });

                // Set today's date
                document.getElementById('session-date').value = new Date().toISOString().split('T')[0];
                if (state.eventMeta?.date) {
                    document.getElementById('session-date').value = state.eventMeta.date;
                }
                if (state.eventMeta?.duration && Number.isFinite(state.eventMeta.duration)) {
                    document.getElementById('session-duration').value = String(Math.max(15, state.eventMeta.duration));
                }
                if (state.eventId) {
                    const dateInput = document.getElementById('session-date');
                    dateInput.disabled = true;
                    dateInput.classList.add('bg-gray-100', 'text-gray-500', 'cursor-not-allowed');
                    dateInput.title = 'Date is locked to the selected practice event';
                }
                document.getElementById('session-duration').addEventListener('input', () => {
                    state.durationManuallyEdited = true;
                    updateTimelineAllocation();
                });

                // Populate filter dropdowns
                populateFilters();

                // Hide admin-only buttons for parents
                if (state.accessLevel !== 'full') {
                    document.getElementById('btn-new-drill').classList.add('hidden');
                    document.getElementById('session-meta-bar').classList.add('hidden');
                }

                // First paint: show tile layout immediately, then hydrate each tile asynchronously.
                renderCanvas();
                renderChatHistory();
                updateTimelineAllocation();
                document.getElementById('loading-state').classList.add('hidden');
                document.getElementById('main-content').classList.remove('hidden');

                // Background hydration: attendance/favorites/session/context load independently.
                const attendancePromise = initializeAttendance().catch((err) => {
                    console.warn('Attendance initialization failed:', err);
                    showToast('Could not load attendance yet', 'error');
                });
                const lastPracticeSeedPromise = loadLastPracticeSeed().then((seed) => {
                    // New ad-hoc planning: default duration from previous practice when not manually edited.
                    if (!state.eventId && seed?.duration && !state.durationManuallyEdited) {
                        const durationInput = document.getElementById('session-duration');
                        if (durationInput && (!durationInput.value || parseInt(durationInput.value, 10) === 60)) {
                            durationInput.value = String(seed.duration);
                            updateTimelineAllocation();
                        }
                    }
                }).catch((err) => {
                    console.warn('Last practice seed load failed:', err);
                });

                if (state.accessLevel === 'full') {
                    getDrillFavorites(state.teamId)
                        .then((favoriteIds) => {
                            state.favoriteIds = new Set(favoriteIds || []);
                            const badge = document.getElementById('fav-count-badge');
                            if (state.favoriteIds.size > 0) {
                                badge.textContent = state.favoriteIds.size;
                                badge.classList.remove('hidden');
                            }
                        })
                        .catch((err) => {
                            console.warn('Favorites load failed:', err);
                        });
                }

                const sessionPromise = state.eventId
                    ? Promise.all([attendancePromise, lastPracticeSeedPromise]).then(() => loadOrCreateEventSession())
                    : Promise.resolve();

                sessionPromise
                    .catch((err) => {
                        console.warn('Session hydration failed:', err);
                        showToast('Could not load saved practice session', 'error');
                    })
                    .finally(() => {
                        loadContextRail().catch((err) => {
                            console.warn('Context rail load failed:', err);
                        });
                    });

            } catch (err) {
                console.error('Init error:', err);
                document.getElementById('loading-state').innerHTML = `
                    <div class="text-center py-16">
                        <p class="text-red-500 font-medium mb-2">Failed to load</p>
                        <p class="text-sm text-gray-500">${escapeHtml(err.message)}</p>
                        <button onclick="location.reload()" class="mt-4 px-4 py-2 bg-primary-600 text-white rounded-lg text-sm">Retry</button>
                    </div>`;
            }
        }
        init();

        async function loadLastPracticeSeed() {
            const notesPanel = document.getElementById('context-last-practice-notes');
            try {
                const sessions = await getPracticeSessions(state.teamId);
                const sorted = (sessions || []).slice().sort((a, b) => {
                    const aDate = a?.date?.toDate ? a.date.toDate() : new Date(a?.date || 0);
                    const bDate = b?.date?.toDate ? b.date.toDate() : new Date(b?.date || 0);
                    return bDate - aDate;
                });
                const previous = sorted.find(s => s?.id && (!state.eventId || s.eventId !== state.eventId));
                if (!previous) {
                    state.lastPracticeSeed = null;
                    renderLastPracticeNotes();
                    return null;
                }

                const blocks = Array.isArray(previous.blocks) ? previous.blocks : [];
                const extractedNotes = blocks
                    .flatMap((b, idx) => {
                        const title = (b.drillTitle || b.title || `Block ${idx + 1}`).trim();
                        const logs = Array.isArray(b.notesLog) ? b.notesLog.map(n => (n?.text || '').trim()).filter(Boolean) : [];
                        const direct = (b.notes || '').trim();
                        const all = [...logs, ...(direct ? [direct] : [])];
                        return all.slice(0, 2).map(t => ({ title, text: t }));
                    })
                    .filter(n => n.text)
                    .slice(0, 8);

                const fallbackDuration = previous.duration
                    || blocks.reduce((sum, b) => sum + (parseInt(b.duration, 10) || 0), 0)
                    || 60;
                const previousDate = previous?.date?.toDate ? previous.date.toDate() : (previous?.date ? new Date(previous.date) : null);

                state.lastPracticeSeed = {
                    sessionId: previous.id,
                    eventId: previous.eventId || null,
                    duration: Math.max(15, parseInt(fallbackDuration, 10) || 60),
                    date: previousDate && !Number.isNaN(previousDate.getTime()) ? previousDate : null,
                    notes: extractedNotes
                };
                renderLastPracticeNotes();
                return state.lastPracticeSeed;
            } catch (err) {
                console.warn('Failed loading previous practice seed:', err);
                if (notesPanel) notesPanel.innerHTML = '<p class="text-xs text-gray-400 italic">Previous practice notes unavailable.</p>';
                return null;
            }
        }

        function renderLastPracticeNotes() {
            const panel = document.getElementById('context-last-practice-notes');
            if (!panel) return;
            const seed = state.lastPracticeSeed;
            if (!seed || !Array.isArray(seed.notes) || seed.notes.length === 0) {
                panel.innerHTML = '<p class="text-xs text-gray-400 italic">No notes found on the previous practice.</p>';
                return;
            }
            panel.innerHTML = seed.notes.map(n => `
                <div class="bg-gray-50 rounded-lg p-3 border border-gray-100">
                    <p class="text-[11px] uppercase tracking-wide text-gray-400 mb-1">${escapeHtml(n.title || 'Note')}</p>
                    <p class="text-xs text-gray-700">${escapeHtml(n.text || '')}</p>
                </div>
            `).join('');
        }

        async function initializeAttendance() {
            const roster = await getPlayers(state.teamId);
            state.playerRoster = roster || [];
            state.attendance = {
                rosterSize: state.playerRoster.length,
                checkedInCount: state.playerRoster.length,
                updatedAt: new Date(),
                editedAt: null,
                players: state.playerRoster.map(p => ({
                    playerId: p.id,
                    displayName: p.name || `#${p.number || ''}`.trim() || 'Unknown Player',
                    status: 'present',
                    checkedInAt: new Date(),
                    note: null
                }))
            };
            renderAttendancePanel();
        }

        async function loadOrCreateEventSession() {
            const existing = await getPracticeSessionByEvent(state.teamId, state.eventId);
            if (existing) {
                applySessionData(existing);
                return;
            }
            const sessionDate = document.getElementById('session-date').value;
            const durationInput = document.getElementById('session-duration');
            let sessionDuration = parseInt(durationInput?.value, 10) || 60;
            if (!state.eventMeta?.duration && state.lastPracticeSeed?.duration && !state.durationManuallyEdited) {
                sessionDuration = state.lastPracticeSeed.duration;
                if (durationInput) durationInput.value = String(sessionDuration);
            }
            state.sessionId = await upsertPracticeSessionForEvent(state.teamId, state.eventId, {
                sourcePage: state.sourcePage || 'edit-schedule',
                date: sessionDate ? new Date(sessionDate) : new Date(),
                duration: sessionDuration,
                location: state.eventMeta?.location || null,
                title: state.eventMeta?.title || 'Practice',
                blocks: [],
                attendance: state.attendance,
                aiContext: {
                    lastPractice: state.lastPracticeSeed ? {
                        sessionId: state.lastPracticeSeed.sessionId,
                        date: state.lastPracticeSeed.date || null,
                        duration: state.lastPracticeSeed.duration,
                        notes: state.lastPracticeSeed.notes || []
                    } : null
                }
            });
            const created = await getPracticeSessionByEvent(state.teamId, state.eventId);
            if (created) applySessionData(created);
        }

        function applySessionData(session) {
            state.sessionId = session.id;
            state.canvasBlocks = Array.isArray(session.blocks) ? session.blocks.slice().sort((a, b) => (a.order || 0) - (b.order || 0)) : [];
            if (state.eventId && state.eventMeta?.date) {
                // For schedule-linked sessions, keep date aligned with the source practice event.
                document.getElementById('session-date').value = state.eventMeta.date;
            } else if (session.date) {
                const d = session.date.toDate ? session.date.toDate() : new Date(session.date);
                if (!isNaN(d.getTime())) document.getElementById('session-date').value = d.toISOString().split('T')[0];
            }
            if (state.eventId && state.eventMeta?.duration && Number.isFinite(state.eventMeta.duration)) {
                document.getElementById('session-duration').value = String(Math.max(15, state.eventMeta.duration));
            } else if (session.duration) {
                document.getElementById('session-duration').value = session.duration;
            }
            if (session.attendance) {
                state.attendance = {
                    rosterSize: session.attendance.rosterSize || 0,
                    checkedInCount: session.attendance.checkedInCount || 0,
                    updatedAt: session.attendance.updatedAt || new Date(),
                    editedAt: session.attendance.editedAt || null,
                    players: (session.attendance.players || []).map(p => ({
                        playerId: p.playerId,
                        displayName: p.displayName || 'Unknown Player',
                        status: p.status || 'absent',
                        checkedInAt: p.checkedInAt || null,
                        note: p.note || null
                    }))
                };
            }
            state.aiChatHistory = Array.isArray(session.aiChatHistory) ? session.aiChatHistory : [];
            state.gameIntelligence = session.aiContext?.gameIntelligence || state.gameIntelligence || null;
            if (session.homePacketContent?.blocks) {
                state.homePacketBlocks = normalizeHomePacketBlocks(session.homePacketContent.blocks);
            }
            if (session.aiContext?.lastPractice) {
                const lp = session.aiContext.lastPractice;
                state.lastPracticeSeed = {
                    sessionId: lp.sessionId || null,
                    eventId: lp.eventId || null,
                    duration: lp.duration || state.lastPracticeSeed?.duration || 60,
                    date: lp.date || state.lastPracticeSeed?.date || null,
                    notes: Array.isArray(lp.notes) ? lp.notes : (state.lastPracticeSeed?.notes || [])
                };
            }
            renderCanvas();
            renderAttendancePanel();
            renderLastPracticeNotes();
            renderChatHistory();
            loadHomePacketCompletions().then(() => {
                renderHomePacketEditor();
            }).catch(() => {});
        }

        // ==================== MODE SWITCHING ====================
        function setMode(mode) {
            state.currentMode = mode;
            ['planning', 'practice', 'library'].forEach(m => {
                const el = document.getElementById(`view-${m}`);
                if (el) el.classList.toggle('hidden', m !== mode);
                const btn = document.getElementById(`btn-mode-${m}`);
                if (btn) {
                    btn.classList.toggle('bg-primary-600', m === mode);
                    btn.classList.toggle('text-white', m === mode);
                    btn.classList.toggle('bg-gray-100', m !== mode);
                    btn.classList.toggle('text-gray-600', m !== mode);
                }
            });
            if (mode === 'practice') {
                initPracticeMode();
                markPracticeStatus('active').catch(err => {
                    console.warn('Failed to set practice active:', err);
                });
            }
            if (mode !== 'practice') stopActiveVoiceRecognition();
            if (mode === 'library') loadLibrary();
        }

        // ==================== FILTER SETUP ====================
        function populateFilters() {
            const typeSelect = document.getElementById('filter-type');
            DRILL_TYPES.forEach(t => {
                const opt = document.createElement('option');
                opt.value = t; opt.textContent = t;
                typeSelect.appendChild(opt);
            });
            const levelSelect = document.getElementById('filter-level');
            DRILL_LEVELS.forEach(l => {
                const opt = document.createElement('option');
                opt.value = l; opt.textContent = l;
                levelSelect.appendChild(opt);
            });
            const skillSelect = document.getElementById('filter-skill');
            const sport = state.team?.sport || 'Soccer';
            getAllSkillTags(sport).forEach(s => {
                const opt = document.createElement('option');
                opt.value = s; opt.textContent = s;
                skillSelect.appendChild(opt);
            });
            // Populate form dropdowns too
            const formType = document.getElementById('form-drill-type');
            DRILL_TYPES.forEach(t => { formType.innerHTML += `<option value="${t}">${t}</option>`; });
            const formLevel = document.getElementById('form-drill-level');
            DRILL_LEVELS.forEach(l => { formLevel.innerHTML += `<option value="${l}">${l}</option>`; });
        }

        // ==================== CONTEXT RAIL ====================
        async function loadContextRail() {
            try {
                const games = await getGames(state.teamId);
                const nonPracticeGames = games.filter(g => g.type !== 'practice');
                state.allGames = nonPracticeGames;
                state.aiRawGameContext = null;
                const recent = nonPracticeGames.slice(-3).reverse();
                state.recentGames = recent;
                const container = document.getElementById('context-games');
                const trends = document.getElementById('context-trends');
                const playersPanel = document.getElementById('context-players');
                const narrativePanel = document.getElementById('context-ai-narrative');
                const focusPanel = document.getElementById('context-coach-focus');
                if (recent.length === 0) {
                    container.innerHTML = '<p class="text-xs text-gray-400 italic">No recent games.</p>';
                    trends.innerHTML = '<p class="text-xs text-gray-400 italic">No trend data available yet.</p>';
                    playersPanel.innerHTML = renderPlayerHighlights([]);
                    narrativePanel.innerHTML = '<p class="text-xs text-gray-400 italic">No recent game narratives available.</p>';
                    focusPanel.innerHTML = '<p class="text-xs text-gray-400 italic">Need recent games to recommend focus.</p>';
                    state.gameIntelligence = null;
                    return;
                }
                container.innerHTML = recent.map(g => {
                    const d = g.date?.toDate ? g.date.toDate() : new Date(g.date);
                    const dateStr = d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                    const hs = g.homeScore || 0, as = g.awayScore || 0;
                    const result = hs > as ? 'W' : hs < as ? 'L' : 'D';
                    const resultColor = result === 'W' ? 'text-green-600' : result === 'L' ? 'text-red-600' : 'text-yellow-600';
                    return `<div class="bg-gray-50 rounded-lg p-3 border border-gray-100">
                        <div class="flex items-center justify-between mb-1">
                            <span class="text-xs font-semibold text-gray-700">${escapeHtml(g.opponent || 'Unknown')}</span>
                            <span class="text-xs font-bold ${resultColor}">${result} ${hs}-${as}</span>
                        </div>
                        <p class="text-xs text-gray-500">${dateStr}${g.summary ? ' &middot; ' + escapeHtml(g.summary.substring(0, 80)) : ''}</p>
                    </div>`;
                }).join('');

                const gf = recent.reduce((s, g) => s + (g.homeScore || 0), 0);
                const ga = recent.reduce((s, g) => s + (g.awayScore || 0), 0);
                const avgGf = (gf / recent.length).toFixed(1);
                const avgGa = (ga / recent.length).toFixed(1);
                const record = recent.reduce((acc, g) => {
                    const hs = g.homeScore || 0, as = g.awayScore || 0;
                    if (hs > as) acc.w += 1;
                    else if (hs < as) acc.l += 1;
                    else acc.d += 1;
                    return acc;
                }, { w: 0, l: 0, d: 0 });
                trends.innerHTML = `
                    <div class="bg-gray-50 rounded-lg p-3 border border-gray-100">
                        <p class="text-[11px] uppercase tracking-wide text-gray-400 mb-1">Last 3 Record</p>
                        <p class="text-sm font-semibold text-gray-700">${record.w}-${record.l}-${record.d}</p>
                    </div>
                    <div class="bg-gray-50 rounded-lg p-3 border border-gray-100">
                        <p class="text-[11px] uppercase tracking-wide text-gray-400 mb-1">Goals For / Game</p>
                        <p class="text-sm font-semibold text-green-700">${avgGf}</p>
                    </div>
                    <div class="bg-gray-50 rounded-lg p-3 border border-gray-100">
                        <p class="text-[11px] uppercase tracking-wide text-gray-400 mb-1">Goals Against / Game</p>
                        <p class="text-sm font-semibold text-red-700">${avgGa}</p>
                    </div>
                `;
                playersPanel.innerHTML = renderPlayerHighlights(recent);
                if (state.gameIntelligence) {
                    renderGameIntelligencePanels(state.gameIntelligence, trends);
                    return;
                }
                const derivedSignals = computePatternSignals(recent);
                const playerTrend = extractPlayerTrendSnapshot(recent);
                state.gameIntelligence = await evaluateGameIntelligence(recent, { record, avgGf, avgGa, signals: derivedSignals, playerTrend });
                renderGameIntelligencePanels(state.gameIntelligence, trends);
                await persistGameIntelligenceContext();
            } catch (e) {
                console.warn('Context rail error:', e);
                showToast('Could not load recent game context', 'error');
                const playersPanel = document.getElementById('context-players');
                if (playersPanel) playersPanel.innerHTML = renderPlayerHighlights([]);
                const narrativePanel = document.getElementById('context-ai-narrative');
                const focusPanel = document.getElementById('context-coach-focus');
                if (narrativePanel) narrativePanel.innerHTML = '<p class="text-xs text-gray-400 italic">Narrative analysis unavailable.</p>';
                if (focusPanel) focusPanel.innerHTML = '<p class="text-xs text-gray-400 italic">Focus recommendation unavailable.</p>';
            }
        }

        function renderPlayerHighlights(recentGames) {
            const highlights = [];
            for (const g of (recentGames || [])) {
                if (Array.isArray(g.playerHighlights)) {
                    g.playerHighlights.slice(0, 2).forEach(h => {
                        if (typeof h === 'string') highlights.push(h);
                        else if (h?.name || h?.note) highlights.push(`${h.name || 'Player'}: ${h.note || ''}`.trim());
                    });
                }
                if (Array.isArray(g.highlights)) {
                    g.highlights.slice(0, 2).forEach(h => {
                        if (typeof h === 'string') highlights.push(h);
                    });
                }
                if (g.topPerformer) {
                    if (typeof g.topPerformer === 'string') highlights.push(g.topPerformer);
                    else if (g.topPerformer?.name || g.topPerformer?.statLine) {
                        highlights.push(`${g.topPerformer.name || 'Player'} ${g.topPerformer.statLine || ''}`.trim());
                    }
                }
            }
            const deduped = [...new Set(highlights.map(h => (h || '').trim()).filter(Boolean))].slice(0, 4);
            if (deduped.length > 0) {
                return deduped.map(h => `
                    <div class="bg-gray-50 rounded-lg p-3 border border-gray-100">
                        <p class="text-xs text-gray-700">${escapeHtml(h)}</p>
                    </div>
                `).join('');
            }
            const attendance = getAttendanceSummary();
            const rosterSize = state.playerRoster?.length || 0;
            return `
                <div class="bg-gray-50 rounded-lg p-3 border border-gray-100">
                    <p class="text-[11px] uppercase tracking-wide text-gray-400 mb-1">Roster Snapshot</p>
                    <p class="text-xs text-gray-700">${attendance.checkedIn}/${rosterSize} available today</p>
                </div>
                <div class="bg-gray-50 rounded-lg p-3 border border-gray-100">
                    <p class="text-xs text-gray-700">${escapeHtml(state.playerRoster?.slice(0, 4).map(p => p.name).filter(Boolean).join(', ') || 'No player highlight data from recent games yet.')}</p>
                </div>
            `;
        }

        function computePatternSignals(recentGames) {
            const text = (recentGames || []).map(g => [g.summary, g.notes, Array.isArray(g.highlights) ? g.highlights.join(' ') : ''].filter(Boolean).join(' ')).join(' ').toLowerCase();
            const checks = [
                { key: 'finishing misses', patterns: ['missed chance', 'could not finish', 'finishing', 'shot off target'] },
                { key: 'slow starts', patterns: ['slow start', 'started slow', 'flat opening'] },
                { key: 'late concessions', patterns: ['late goal', 'conceded late', 'final minutes'] },
                { key: 'defensive resilience', patterns: ['clean sheet', 'defensive shape', 'solid defending'] },
                { key: 'transition moments', patterns: ['counter', 'transition', 'turnover'] }
            ];
            return checks
                .map(c => ({ label: c.key, count: c.patterns.reduce((sum, p) => sum + (text.includes(p) ? 1 : 0), 0) }))
                .filter(s => s.count > 0)
                .sort((a, b) => b.count - a.count)
                .slice(0, 4);
        }

        function extractPlayerTrendSnapshot(recentGames) {
            const mentions = {};
            for (const g of (recentGames || [])) {
                const addMention = (name, trend) => {
                    if (!name) return;
                    const key = name.trim();
                    if (!key) return;
                    if (!mentions[key]) mentions[key] = { name: key, up: 0, attention: 0 };
                    if (trend === 'up') mentions[key].up += 1;
                    else mentions[key].attention += 1;
                };

                if (Array.isArray(g.playerHighlights)) {
                    g.playerHighlights.forEach(h => {
                        if (typeof h === 'string') {
                            const matched = (state.playerRoster || []).find(p => h.toLowerCase().includes((p.name || '').toLowerCase()));
                            addMention(matched?.name || null, 'up');
                        } else {
                            addMention(h?.name || null, 'up');
                        }
                    });
                }
                if (g.topPerformer) {
                    if (typeof g.topPerformer === 'string') {
                        const matched = (state.playerRoster || []).find(p => g.topPerformer.toLowerCase().includes((p.name || '').toLowerCase()));
                        addMention(matched?.name || null, 'up');
                    } else {
                        addMention(g.topPerformer?.name || null, 'up');
                    }
                }
            }
            const list = Object.values(mentions);
            return {
                up: list.filter(m => m.up >= m.attention).sort((a, b) => b.up - a.up).slice(0, 3).map(m => m.name),
                attention: list.filter(m => m.attention > m.up).sort((a, b) => b.attention - a.attention).slice(0, 3).map(m => m.name)
            };
        }

        async function evaluateGameIntelligence(recentGames, base) {
            const fallback = {
                improved: `Record trend: ${base.record.w}-${base.record.l}-${base.record.d}. Goals for/game ${base.avgGf}.`,
                breakdown: `Goals against/game ${base.avgGa}. Tighten transitions and compactness when fatigued.`,
                focus: 'Prioritize compact defensive shape and fast finishing reps in the next session.',
                primaryFocus: 'Defensive transitions + finishing execution',
                blockMix: { technical: 40, tactical: 30, game: 30 },
                signals: base.signals || [],
                playerTrend: base.playerTrend || { up: [], attention: [] },
                confidence: 'medium'
            };

            try {
                const app = getApp();
                const ai = getAI(app, { backend: new GoogleAIBackend() });
                const model = getGenerativeModel(ai, { model: 'gemini-2.5-flash' });
                const prompt = `
You are a youth coach analyst. Analyze the last 3 games and return JSON only.
Return shape:
{
  "improved": "string",
  "breakdown": "string",
  "focus": "string",
  "primaryFocus": "string",
  "blockMix": { "technical": 40, "tactical": 30, "game": 30 },
  "signals": ["string", "string"],
  "playerTrend": { "up": ["name"], "attention": ["name"] },
  "confidence": "high|medium|low"
}
Context:
${JSON.stringify({
    recentGames: (recentGames || []).map(g => ({
        opponent: g.opponent || 'Unknown',
        score: `${g.homeScore || 0}-${g.awayScore || 0}`,
        summary: g.summary || '',
        notes: g.notes || '',
        highlights: g.highlights || [],
        playerHighlights: g.playerHighlights || [],
        topPerformer: g.topPerformer || null
    })),
    base
})}
                `.trim();
                const result = await model.generateContent(prompt);
                const parsed = parseLooseJson(result.response.text());
                return {
                    ...fallback,
                    ...parsed,
                    blockMix: { ...fallback.blockMix, ...(parsed?.blockMix || {}) },
                    signals: Array.isArray(parsed?.signals) && parsed.signals.length ? parsed.signals.slice(0, 4) : fallback.signals,
                    playerTrend: parsed?.playerTrend && typeof parsed.playerTrend === 'object'
                        ? {
                            up: Array.isArray(parsed.playerTrend.up) ? parsed.playerTrend.up.slice(0, 3) : fallback.playerTrend.up,
                            attention: Array.isArray(parsed.playerTrend.attention) ? parsed.playerTrend.attention.slice(0, 3) : fallback.playerTrend.attention
                        }
                        : fallback.playerTrend
                };
            } catch (err) {
                console.warn('Game intelligence AI unavailable:', err);
                return fallback;
            }
        }

        async function persistGameIntelligenceContext() {
            if (!state.sessionId || !state.gameIntelligence) return;
            try {
                const existingAiContext = state.gameIntelligence ? { gameIntelligence: state.gameIntelligence } : {};
                await updatePracticeSession(state.teamId, state.sessionId, {
                    aiContext: {
                        ...existingAiContext,
                        presentPlayerIds: (state.attendance?.players || [])
                            .filter(p => p.status === 'present' || p.status === 'late')
                            .map(p => p.playerId),
                        attendanceSummary: getAttendanceSummary()
                    }
                });
            } catch (err) {
                console.warn('Failed to persist game intelligence context:', err);
            }
        }

        function parseLooseJson(raw) {
            if (!raw) return null;
            const cleaned = raw.trim().replace(/^```json\s*/i, '').replace(/^```\s*/i, '').replace(/\s*```$/, '').trim();
            try {
                return JSON.parse(cleaned);
            } catch (_) {
                const match = cleaned.match(/\{[\s\S]*\}/);
                if (!match) return null;
                return JSON.parse(match[0]);
            }
        }

        function renderGameIntelligencePanels(data, trendsPanel) {
            const narrativePanel = document.getElementById('context-ai-narrative');
            const focusPanel = document.getElementById('context-coach-focus');
            if (!narrativePanel || !focusPanel) return;
            if (!data) {
                narrativePanel.innerHTML = '<p class="text-xs text-gray-400 italic">Narrative analysis unavailable.</p>';
                focusPanel.innerHTML = '<p class="text-xs text-gray-400 italic">Focus recommendation unavailable.</p>';
                return;
            }
            const signalChips = (data.signals || []).slice(0, 4).map(s => `<span class="text-[10px] px-2 py-1 rounded-full bg-indigo-50 text-indigo-700 border border-indigo-100">${escapeHtml(typeof s === 'string' ? s : s.label || '')}</span>`).join('');
            narrativePanel.innerHTML = `
                <div class="bg-gray-50 rounded-lg p-3 border border-gray-100">
                    <p class="text-[11px] uppercase tracking-wide text-gray-400 mb-1">What Improved</p>
                    <p class="text-xs text-gray-700">${escapeHtml(data.improved || 'No clear improvement trend extracted.')}</p>
                </div>
                <div class="bg-gray-50 rounded-lg p-3 border border-gray-100">
                    <p class="text-[11px] uppercase tracking-wide text-gray-400 mb-1">What Broke Down</p>
                    <p class="text-xs text-gray-700">${escapeHtml(data.breakdown || 'No breakdown trend extracted.')}</p>
                </div>
                ${signalChips ? `<div class="flex flex-wrap gap-1">${signalChips}</div>` : ''}
            `;

            const upPlayers = (data.playerTrend?.up || []).slice(0, 3).join(', ') || 'No strong up-trend signals yet';
            const attentionPlayers = (data.playerTrend?.attention || []).slice(0, 3).join(', ') || 'No immediate concern flags';
            const bm = data.blockMix || {};
            focusPanel.innerHTML = `
                <div class="bg-indigo-50 rounded-lg p-3 border border-indigo-100">
                    <p class="text-[11px] uppercase tracking-wide text-indigo-500 mb-1">Primary Focus</p>
                    <p class="text-xs font-semibold text-indigo-900">${escapeHtml(data.primaryFocus || data.focus || 'Set next practice priority')}</p>
                    <p class="text-xs text-indigo-700 mt-1">${escapeHtml(data.focus || '')}</p>
                    <p class="text-[10px] text-indigo-500 mt-2">Confidence: ${escapeHtml(data.confidence || 'medium')}</p>
                </div>
                <div class="bg-gray-50 rounded-lg p-3 border border-gray-100">
                    <p class="text-[11px] uppercase tracking-wide text-gray-400 mb-1">Suggested Block Mix</p>
                    <p class="text-xs text-gray-700">Technical ${bm.technical ?? 40}%  Tactical ${bm.tactical ?? 30}%  Game ${bm.game ?? 30}%</p>
                </div>
                <div class="bg-gray-50 rounded-lg p-3 border border-gray-100">
                    <p class="text-[11px] uppercase tracking-wide text-gray-400 mb-1">Player Trend Spotlight</p>
                    <p class="text-xs text-gray-700"><strong>Up:</strong> ${escapeHtml(upPlayers)}</p>
                    <p class="text-xs text-gray-700 mt-1"><strong>Attention:</strong> ${escapeHtml(attentionPlayers)}</p>
                </div>
            `;

            if (trendsPanel && signalChips) {
                trendsPanel.insertAdjacentHTML('beforeend', `<div class="bg-gray-50 rounded-lg p-3 border border-gray-100"><p class="text-[11px] uppercase tracking-wide text-gray-400 mb-2">Pattern Signals</p><div class="flex flex-wrap gap-1">${signalChips}</div></div>`);
            }
        }

        // ==================== DRILL LIBRARY ====================
        let searchTimeout;
        function debounceSearch() {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => loadLibrary(), 300);
        }

        function setLibTab(tab) {
            state.libTab = tab;
            ['community', 'mydrills', 'favorites'].forEach(t => {
                const btn = document.getElementById(`lib-tab-${t}`);
                btn.classList.toggle('text-primary-600', t === tab);
                btn.classList.toggle('border-b-2', t === tab);
                btn.classList.toggle('border-primary-600', t === tab);
                btn.classList.toggle('text-gray-500', t !== tab);
            });
            state.libLastDoc = null;
            loadLibrary();
        }

        function getCommunityLibraryFilters(extra = {}) {
            const sport = state.team?.sport || 'Soccer';
            const opts = { sport, ...extra };
            const type = document.getElementById('filter-type').value;
            const level = document.getElementById('filter-level').value;
            const skill = document.getElementById('filter-skill').value;
            const search = document.getElementById('filter-search').value.trim();
            if (type) opts.type = type;
            if (level) opts.level = level;
            if (skill) opts.skill = skill;
            if (search) opts.searchText = search;
            return opts;
        }

        async function loadLibrary() {
            const container = document.getElementById('lib-cards');
            renderLibrarySkeleton();

            try {
                let drills = [];

                if (state.libTab === 'community') {
                    const opts = getCommunityLibraryFilters();
                    const result = await getDrills(opts);
                    drills = result.drills;
                    state.libLastDoc = result.lastDoc;
                    state.aiDrillContext = {
                        ...(state.aiDrillContext || {}),
                        community: drills.slice(0, 12)
                    };
                } else if (state.libTab === 'mydrills') {
                    drills = await getTeamDrills(state.teamId);
                    state.aiDrillContext = {
                        ...(state.aiDrillContext || {}),
                        myDrills: drills.slice(0, 12)
                    };
                } else if (state.libTab === 'favorites') {
                    if (state.favoriteIds.size === 0) { drills = []; }
                    else {
                        const fetches = [...state.favoriteIds].map(id => getDrill(id));
                        drills = (await Promise.all(fetches)).filter(Boolean);
                    }
                }

                document.getElementById('lib-result-count').textContent = `${drills.length} result${drills.length !== 1 ? 's' : ''}`;
                document.getElementById('lib-load-more').classList.toggle('hidden', !state.libLastDoc || state.libTab !== 'community');

                if (drills.length === 0) {
                    const msgs = {
                        community: 'No drills match your filters.',
                        mydrills: "Your team hasn't created any drills yet.",
                        favorites: 'No favorited drills yet.'
                    };
                    container.innerHTML = `<div class="col-span-full text-center py-12">
                        <svg class="w-12 h-12 text-gray-300 mx-auto mb-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M19.428 15.428a2 2 0 00-1.022-.547l-2.387-.477a6 6 0 00-3.86.517l-.318.158a6 6 0 01-3.86.517L6.05 15.21a2 2 0 00-1.806.547M8 4h8l-1 1v5.172a2 2 0 00.586 1.414l5 5c1.26 1.26.367 3.414-1.415 3.414H4.828c-1.782 0-2.674-2.154-1.414-3.414l5-5A2 2 0 009 10.172V5L8 4z"/></svg>
                        <p class="text-sm text-gray-500">${msgs[state.libTab]}</p>
                    </div>`;
                    return;
                }

                container.innerHTML = drills.map(d => renderDrillCard(d)).join('');
            } catch (err) {
                console.error('Library load error:', err);
                container.innerHTML = `<div class="col-span-full text-center py-12">
                    <p class="text-red-500 text-sm font-medium">Failed to load drills</p>
                    <button onclick="loadLibrary()" class="mt-2 text-sm text-primary-600 hover:underline">Retry</button>
                </div>`;
                showToast('Failed to load drill library', 'error');
            }
        }

        function renderLibrarySkeleton() {
            const container = document.getElementById('lib-cards');
            const skeletonCard = `
                <div class="bg-white rounded-xl border border-gray-200 shadow-sm p-4 animate-pulse">
                    <div class="flex items-start justify-between mb-3">
                        <div class="h-5 w-20 rounded-full bg-gray-200"></div>
                        <div class="h-5 w-5 rounded-full bg-gray-200"></div>
                    </div>
                    <div class="h-4 w-5/6 bg-gray-200 rounded mb-2"></div>
                    <div class="h-3 w-full bg-gray-100 rounded mb-1.5"></div>
                    <div class="h-3 w-4/5 bg-gray-100 rounded mb-3"></div>
                    <div class="flex gap-1 mb-3">
                        <div class="h-4 w-14 rounded-full bg-gray-100"></div>
                        <div class="h-4 w-16 rounded-full bg-gray-100"></div>
                    </div>
                    <div class="h-3 w-24 bg-gray-100 rounded"></div>
                </div>`;
            container.innerHTML = `<div class="col-span-full grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">${new Array(8).fill(skeletonCard).join('')}</div>`;
        }

        async function loadMoreDrills() {
            if (!state.libLastDoc) return;
            try {
                const opts = getCommunityLibraryFilters({ startAfterDoc: state.libLastDoc });
                const result = await getDrills(opts);
                state.libLastDoc = result.lastDoc;
                state.aiDrillContext = {
                    ...(state.aiDrillContext || {}),
                    community: [...(state.aiDrillContext?.community || []), ...result.drills].slice(0, 20)
                };
                const container = document.getElementById('lib-cards');
                result.drills.forEach(d => container.insertAdjacentHTML('beforeend', renderDrillCard(d)));
                document.getElementById('lib-load-more').classList.toggle('hidden', !state.libLastDoc);
            } catch (e) {
                console.error('Load more error:', e);
                showToast('Could not load more drills', 'error');
            }
        }

        function invalidateAiDrillUniverse() {
            state.aiDrillUniverse = null;
            state.aiDrillUniverseLoadedAt = 0;
        }

        async function ensureAiDrillUniverse(force = false) {
            const stale = !state.aiDrillUniverseLoadedAt || (Date.now() - state.aiDrillUniverseLoadedAt > 120000);
            if (!force && !stale && Array.isArray(state.aiDrillUniverse) && state.aiDrillUniverse.length > 0) {
                return state.aiDrillUniverse;
            }
            const sport = state.team?.sport || 'Soccer';
            const community = [];
            let cursor = null;
            let guard = 0;
            do {
                const res = await getDrills({ sport, limitCount: 120, startAfterDoc: cursor });
                community.push(...(res.drills || []));
                cursor = res.lastDoc || null;
                guard += 1;
            } while (cursor && guard < 20);

            let teamDrills = [];
            try {
                teamDrills = await getTeamDrills(state.teamId);
            } catch (err) {
                console.warn('Failed loading team drills for AI index:', err);
            }

            const merged = [...community, ...teamDrills];
            const byId = new Map();
            merged.forEach(d => {
                if (!d?.id) return;
                byId.set(d.id, {
                    id: d.id,
                    title: d.title || '',
                    type: d.type || 'Technical',
                    level: d.level || 'All',
                    skills: Array.isArray(d.skills) ? d.skills : [],
                    duration: d.setup?.duration || null,
                    players: d.setup?.players || null,
                    description: d.description || '',
                    source: d.source || (d.publishedToCommunity ? 'published' : 'custom'),
                    teamId: d.teamId || null,
                    publishedToCommunity: !!d.publishedToCommunity
                });
            });
            state.aiDrillUniverse = [...byId.values()];
            state.aiDrillUniverseLoadedAt = Date.now();
            return state.aiDrillUniverse;
        }

        function scoreDrillRelevance(drill, tokens = [], lowAttendance = false) {
            const title = (drill.title || '').toLowerCase();
            const desc = (drill.description || '').toLowerCase();
            const skills = (drill.skills || []).map(s => (s || '').toLowerCase());
            let score = 0;
            tokens.forEach(t => {
                if (!t) return;
                if (title.includes(t)) score += 5;
                if (desc.includes(t)) score += 2;
                if (skills.some(s => s.includes(t))) score += 4;
            });
            if (lowAttendance && (drill.type || '').toLowerCase() === 'game') score += 2;
            if (drill.source === 'custom' || drill.teamId === state.teamId) score += 1.5;
            if (drill.publishedToCommunity) score += 0.5;
            return score;
        }

        function getRelevantDrillMatches(universe, userPrompt, attendanceSummary, topN = 40) {
            const prompt = (userPrompt || '').toLowerCase();
            const tokens = prompt.split(/[^a-z0-9]+/g).filter(t => t.length >= 3);
            const lowAttendance = (attendanceSummary?.checkedIn || 0) < 10;
            const ranked = (universe || [])
                .map(d => ({ drill: d, score: scoreDrillRelevance(d, tokens, lowAttendance) }))
                .sort((a, b) => b.score - a.score || (a.drill.title || '').localeCompare(b.drill.title || ''));
            const positive = ranked.filter(r => r.score > 0).slice(0, topN).map(r => r.drill);
            if (positive.length >= Math.min(10, topN)) return positive;
            return ranked.slice(0, topN).map(r => r.drill);
        }

        function renderDrillCard(d) {
            const tc = getTypeClass(d.type);
            const isFav = state.favoriteIds.has(d.id);
            const favSvg = isFav
                ? `<svg class="w-5 h-5 text-red-400" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M3.172 5.172a4 4 0 015.656 0L10 6.343l1.172-1.171a4 4 0 115.656 5.656L10 17.657l-6.828-6.829a4 4 0 010-5.656z"/></svg>`
                : `<svg class="w-5 h-5 text-gray-300 hover:text-red-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z"/></svg>`;
            const skills = (d.skills || []).slice(0, 3).map(s => `<span class="bg-gray-100 text-gray-600 text-[10px] px-2 py-0.5 rounded-full">${escapeHtml(s)}</span>`).join('');
            const dur = d.setup?.duration || '?';
            const players = d.setup?.players ? (typeof d.setup.players === 'object' ? `${d.setup.players.min}-${d.setup.players.max}` : d.setup.players) : '?';

            return `<div class="bg-white rounded-xl border border-gray-200 shadow-sm card-hover overflow-hidden cursor-pointer" onclick="window._openDrill('${d.id}')">
                <div class="p-4">
                    <div class="flex items-start justify-between mb-2">
                        <span class="${tc} text-[10px] font-bold px-2 py-0.5 rounded-full uppercase">${escapeHtml(d.type || 'Drill')}</span>
                        <button onclick="event.stopPropagation(); window._toggleFav('${d.id}', this)" class="fav-btn">${favSvg}</button>
                    </div>
                    <h4 class="font-semibold text-gray-800 text-sm mb-1">${escapeHtml(d.title || 'Untitled')}</h4>
                    <p class="text-xs text-gray-500 mb-3 line-clamp-2">${escapeHtml(d.description || '')}</p>
                    <div class="flex flex-wrap gap-1 mb-3">${skills}</div>
                    <div class="flex items-center justify-between text-[10px] text-gray-400 border-t border-gray-100 pt-2">
                        <span>${dur} min &middot; ${players} players</span>
                        <span>${escapeHtml(d.level || 'All')}</span>
                    </div>
                </div>
            </div>`;
        }

        function getTypeClass(type) {
            const map = { 'Warm-up': 'type-warmup', 'Tactical': 'type-tactical', 'Technical': 'type-technical', 'Physical': 'type-physical', 'Game': 'type-game' };
            return map[type] || 'type-technical';
        }
        function getBarClass(type) {
            const map = { 'Warm-up': 'bar-warmup', 'Tactical': 'bar-tactical', 'Technical': 'bar-technical', 'Physical': 'bar-physical', 'Game': 'bar-game' };
            return map[type] || 'bar-technical';
        }

        // ==================== DRILL DETAIL ====================
        window._openDrill = async function(drillId) {
            try {
                const drill = await getDrill(drillId);
                if (!drill) return;
                state.currentDetailDrill = drill;
                const tc = getTypeClass(drill.type);
                document.getElementById('detail-type-badge').className = `${tc} text-xs font-bold px-2.5 py-1 rounded-full uppercase`;
                document.getElementById('detail-type-badge').textContent = drill.type || 'Drill';
                document.getElementById('detail-source-label').textContent = drill.source === 'community'
                    ? 'Community Drill'
                    : (drill.publishedToCommunity ? 'Published Team Drill' : 'Custom Drill');

            // Fav button
            const isFav = state.favoriteIds.has(drill.id);
            const favBtn = document.getElementById('detail-fav-btn');
            favBtn.innerHTML = isFav
                ? `<svg class="w-6 h-6 text-red-400" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M3.172 5.172a4 4 0 015.656 0L10 6.343l1.172-1.171a4 4 0 115.656 5.656L10 17.657l-6.828-6.829a4 4 0 010-5.656z"/></svg>`
                : `<svg class="w-6 h-6 text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z"/></svg>`;

            // Show edit/delete for custom drills owned by this team
            const isOwned = drill.source === 'custom' && drill.teamId === state.teamId && state.accessLevel === 'full';
            document.getElementById('detail-edit-btn').classList.toggle('hidden', !isOwned);
            document.getElementById('detail-delete-btn').classList.toggle('hidden', !isOwned);

            // Content
            const setup = drill.setup || {};
            const skills = (drill.skills || []).map(s => `<span class="bg-purple-50 text-purple-700 text-xs font-medium px-3 py-1 rounded-full">${escapeHtml(s)}</span>`).join('');
            const attribution = drill.attribution ? `<div class="bg-gray-50 rounded-xl p-4 border border-gray-100 mt-6">
                <p class="text-xs text-gray-500">By <strong>${escapeHtml(drill.author || 'Unknown')}</strong> &middot; Licensed under <strong>${escapeHtml(drill.attribution.license || '')}</strong></p>
                <p class="text-xs text-gray-400 mt-0.5">Source: ${escapeHtml(drill.attribution.source || '')}</p>
            </div>` : '';

            document.getElementById('detail-content').innerHTML = `
                <h1 class="text-2xl font-bold text-gray-900 mb-2">${escapeHtml(drill.title)}</h1>
                <p class="text-gray-600 mb-4">${escapeHtml(drill.description || '')}</p>
                <div class="flex flex-wrap gap-2 mb-6">
                    <span class="bg-gray-100 text-gray-700 text-xs font-medium px-3 py-1 rounded-full">${escapeHtml(drill.level || 'All')}</span>
                    ${drill.ageGroup ? `<span class="bg-gray-100 text-gray-700 text-xs font-medium px-3 py-1 rounded-full">${escapeHtml(drill.ageGroup)}</span>` : ''}
                    ${skills}
                </div>
                <div class="bg-gray-50 rounded-xl p-4 mb-6">
                    <h3 class="text-sm font-semibold text-gray-700 mb-3">Setup Requirements</h3>
                    <div class="grid grid-cols-2 sm:grid-cols-3 gap-4">
                        <div><p class="text-[10px] uppercase tracking-wider text-gray-400 mb-0.5">Duration</p><p class="text-sm font-medium text-gray-700">${setup.duration || '?'} min</p></div>
                        <div><p class="text-[10px] uppercase tracking-wider text-gray-400 mb-0.5">Players</p><p class="text-sm font-medium text-gray-700">${typeof setup.players === 'object' ? `${setup.players.min}-${setup.players.max}` : (setup.players || '?')}</p></div>
                        <div><p class="text-[10px] uppercase tracking-wider text-gray-400 mb-0.5">Cones</p><p class="text-sm font-medium text-gray-700">${setup.cones || '0'}</p></div>
                        <div><p class="text-[10px] uppercase tracking-wider text-gray-400 mb-0.5">Balls</p><p class="text-sm font-medium text-gray-700">${typeof setup.balls === 'object' ? `${setup.balls.min}-${setup.balls.max}` : (setup.balls || '?')}</p></div>
                    </div>
                </div>
                <div class="mb-6">
                    <h3 class="text-sm font-semibold text-gray-700 mb-3">Instructions</h3>
                    <div class="prose prose-sm text-gray-600 whitespace-pre-wrap">${escapeHtml(drill.instructions || 'No instructions provided.')}</div>
                </div>
                ${drill.homeVariant ? `<div class="bg-blue-50 rounded-xl p-4 mb-6 border border-blue-100">
                    <div class="flex items-center gap-2 mb-2">
                        <svg class="w-4 h-4 text-blue-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6"/></svg>
                        <h3 class="text-sm font-semibold text-blue-800">At-Home Variant</h3>
                    </div>
                    <p class="text-sm text-blue-700">${escapeHtml(drill.homeVariant)}</p>
                </div>` : ''}
                ${attribution}`;

                document.getElementById('drill-detail-modal').classList.remove('hidden');
            } catch (err) {
                console.error('Open drill error:', err);
                showToast('Failed to open drill details', 'error');
            }
        };

        function closeDrillDetail() {
            document.getElementById('drill-detail-modal').classList.add('hidden');
            state.currentDetailDrill = null;
        }

        // ==================== FAVORITES ====================
        window._toggleFav = async function(drillId, btn) {
            if (state.accessLevel !== 'full') return;
            const wasFav = state.favoriteIds.has(drillId);
            const originalMarkup = btn.innerHTML;
            btn.disabled = true;
            btn.innerHTML = '<svg class="w-5 h-5 text-gray-300 animate-spin" viewBox="0 0 24 24" fill="none"><circle class="opacity-30" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="3"></circle><path class="opacity-90" fill="currentColor" d="M4 12a8 8 0 018-8v3a5 5 0 00-5 5H4z"></path></svg>';
            // Optimistic
            if (wasFav) state.favoriteIds.delete(drillId); else state.favoriteIds.add(drillId);
            updateFavBadge();
            btn.innerHTML = wasFav
                ? `<svg class="w-5 h-5 text-gray-300 hover:text-red-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z"/></svg>`
                : `<svg class="w-5 h-5 text-red-400" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M3.172 5.172a4 4 0 015.656 0L10 6.343l1.172-1.171a4 4 0 115.656 5.656L10 17.657l-6.828-6.829a4 4 0 010-5.656z"/></svg>`;
            try {
                if (wasFav) await removeDrillFavorite(state.teamId, drillId);
                else await addDrillFavorite(state.teamId, drillId);
            } catch (e) {
                // Revert
                if (wasFav) state.favoriteIds.add(drillId); else state.favoriteIds.delete(drillId);
                updateFavBadge();
                btn.innerHTML = originalMarkup;
                showToast('Failed to update favorite', 'error');
            } finally {
                btn.disabled = false;
            }
        };

        async function toggleDetailFav() {
            if (!state.currentDetailDrill) return;
            const btn = document.getElementById('detail-fav-btn');
            await window._toggleFav(state.currentDetailDrill.id, btn);
        }

        function updateFavBadge() {
            const badge = document.getElementById('fav-count-badge');
            badge.textContent = state.favoriteIds.size;
            badge.classList.toggle('hidden', state.favoriteIds.size === 0);
        }

        // ==================== CANVAS ====================
        function addDetailToCanvas() {
            if (!state.currentDetailDrill) return;
            const d = state.currentDetailDrill;
            state.canvasBlocks.push({
                drillId: d.id,
                drillTitle: d.title,
                type: d.type || 'Technical',
                duration: d.setup?.duration || 15,
                notes: '',
                description: d.description || ''
            });
            renderCanvas();
            closeDrillDetail();
            setMode('planning');
            showToast(`Added "${d.title}" to canvas`);
        }

        function removeCanvasBlock(index) {
            state.canvasBlocks.splice(index, 1);
            renderCanvas();
        }

        function renderCanvas() {
            const container = document.getElementById('canvas-blocks');
            const empty = document.getElementById('canvas-empty');
            if (state.canvasBlocks.length === 0) {
                container.innerHTML = '';
                if (empty) container.appendChild(empty);
                document.getElementById('canvas-total').textContent = 'Total: 0 min';
                updateTimelineAllocation(0);
                return;
            }
            if (empty) empty.remove();
            const total = state.canvasBlocks.reduce((s, b) => s + (b.duration || 0), 0);
            document.getElementById('canvas-total').textContent = `Total: ${total} min`;
            updateTimelineAllocation(total);

            container.innerHTML = state.canvasBlocks.map((b, i) => {
                const barClass = getBarClass(b.type);
                const tc = getTypeClass(b.type);
                return `<div class="bg-white rounded-xl border border-gray-200 shadow-sm overflow-hidden"
                        draggable="true"
                        data-block-index="${i}"
                        ondragstart="startDragBlock(event, ${i})"
                        ondragover="allowDropBlock(event)"
                        ondrop="dropBlock(event, ${i})">
                    <div class="flex items-stretch">
                        <div class="w-1.5 ${barClass} flex-shrink-0"></div>
                        <div class="flex-1 p-3">
                            <div class="flex items-center justify-between mb-1">
                                <div class="flex items-center gap-2">
                                    <span class="drag-handle text-gray-300">
                                        <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path d="M7 2a2 2 0 1 0 0 4 2 2 0 0 0 0-4zM7 8a2 2 0 1 0 0 4 2 2 0 0 0 0-4zM7 14a2 2 0 1 0 0 4 2 2 0 0 0 0-4zM13 2a2 2 0 1 0 0 4 2 2 0 0 0 0-4zM13 8a2 2 0 1 0 0 4 2 2 0 0 0 0-4zM13 14a2 2 0 1 0 0 4 2 2 0 0 0 0-4z"/></svg>
                                    </span>
                                    <span class="text-sm font-semibold text-gray-800">${escapeHtml(b.drillTitle)}</span>
                                    <span class="${tc} text-[10px] font-bold px-2 py-0.5 rounded-full uppercase">${escapeHtml(b.type)}</span>
                                </div>
                                <div class="flex items-center gap-2">
                                    <input type="number" value="${b.duration}" min="1" max="60" class="w-10 text-center text-sm font-bold text-gray-500 border-none bg-transparent focus:bg-primary-50 focus:outline-none rounded" onchange="window._updateBlockDur(${i}, this.value)">
                                    <span class="text-xs text-gray-400">min</span>
                                    <button onclick="removeCanvasBlock(${i})" class="text-gray-300 hover:text-red-400 ml-1">
                                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>
                                    </button>
                                </div>
                            </div>
                            <p class="text-xs text-gray-500 ml-6">${escapeHtml(b.description)}</p>
                        </div>
                    </div>
                </div>`;
            }).join('');
        }

        window._updateBlockDur = function(index, val) {
            state.canvasBlocks[index].duration = parseInt(val) || 1;
            const total = state.canvasBlocks.reduce((s, b) => s + (b.duration || 0), 0);
            document.getElementById('canvas-total').textContent = `Total: ${total} min`;
            updateTimelineAllocation(total);
        };

        function updateTimelineAllocation(explicitTotal = null) {
            const total = explicitTotal !== null
                ? explicitTotal
                : state.canvasBlocks.reduce((s, b) => s + (b.duration || 0), 0);
            const durationInput = document.getElementById('session-duration');
            const sessionDuration = parseInt(durationInput?.value, 10) || 60;
            const gapEl = document.getElementById('canvas-gap');
            const bannerEl = document.getElementById('timeline-gap-banner');
            if (!gapEl) return;
            const delta = sessionDuration - total;
            if (durationInput) durationInput.classList.remove('border-green-400', 'border-amber-400', 'border-red-400');
            if (delta > 0) {
                gapEl.textContent = `Unallocated: ${delta} min`;
                gapEl.className = 'text-xs font-medium px-2 py-1 rounded-full bg-amber-100 text-amber-700';
                if (bannerEl) {
                    bannerEl.textContent = `Gap: ${delta} min`;
                    bannerEl.className = 'text-[10px] font-medium px-2 py-1 rounded-full bg-amber-100 text-amber-700';
                }
                if (durationInput) durationInput.classList.add('border-amber-400');
            } else if (delta < 0) {
                gapEl.textContent = `Over by: ${Math.abs(delta)} min`;
                gapEl.className = 'text-xs font-medium px-2 py-1 rounded-full bg-red-100 text-red-700';
                if (bannerEl) {
                    bannerEl.textContent = `Over: ${Math.abs(delta)} min`;
                    bannerEl.className = 'text-[10px] font-medium px-2 py-1 rounded-full bg-red-100 text-red-700';
                }
                if (durationInput) durationInput.classList.add('border-red-400');
            } else {
                gapEl.textContent = 'Fully allocated';
                gapEl.className = 'text-xs font-medium px-2 py-1 rounded-full bg-green-100 text-green-700';
                if (bannerEl) {
                    bannerEl.textContent = 'Matched';
                    bannerEl.className = 'text-[10px] font-medium px-2 py-1 rounded-full bg-green-100 text-green-700';
                }
                if (durationInput) durationInput.classList.add('border-green-400');
            }
        }

        let draggedBlockIndex = null;
        function startDragBlock(event, index) {
            draggedBlockIndex = index;
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', String(index));
        }

        function allowDropBlock(event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';
        }

        async function dropBlock(event, targetIndex) {
            event.preventDefault();
            const sourceIndexRaw = event.dataTransfer.getData('text/plain');
            const sourceIndex = sourceIndexRaw ? parseInt(sourceIndexRaw, 10) : draggedBlockIndex;
            if (Number.isNaN(sourceIndex) || sourceIndex === null || sourceIndex === targetIndex) return;
            if (sourceIndex < 0 || sourceIndex >= state.canvasBlocks.length) return;
            if (targetIndex < 0 || targetIndex >= state.canvasBlocks.length) return;

            const [moved] = state.canvasBlocks.splice(sourceIndex, 1);
            state.canvasBlocks.splice(targetIndex, 0, moved);
            renderCanvas();

            if (state.sessionId) {
                try {
                    await updatePracticeSession(state.teamId, state.sessionId, {
                        blocks: state.canvasBlocks.map((b, i) => ({ ...b, order: i }))
                    });
                } catch (err) {
                    console.warn('Failed to persist reordered blocks:', err);
                    showToast('Failed to save order', 'error');
                }
            }
        }

        // ==================== CREATE/EDIT DRILL ====================
        function showDrillForm(drill) {
            document.getElementById('form-title').textContent = drill ? 'Edit Drill' : 'New Drill';
            document.getElementById('form-drill-id').value = drill?.id || '';
            document.getElementById('form-drill-title').value = drill?.title || '';
            document.getElementById('form-drill-type').value = drill?.type || 'Technical';
            document.getElementById('form-drill-level').value = drill?.level || 'All';
            document.getElementById('form-drill-skills').value = (drill?.skills || []).join(', ');
            document.getElementById('form-drill-duration').value = drill?.setup?.duration || 15;
            document.getElementById('form-drill-players').value = drill?.setup?.players || '';
            document.getElementById('form-drill-cones').value = drill?.setup?.cones || 0;
            document.getElementById('form-drill-desc').value = drill?.description || '';
            document.getElementById('form-drill-instructions').value = drill?.instructions || '';
            document.getElementById('form-publish-community').checked = !!drill?.publishedToCommunity;
            state.formAiHistory = [{
                role: 'assistant',
                content: 'Tell me the drill concept and I will fill the card fields for you.'
            }];
            renderFormAiMessages();
            document.getElementById('drill-form-modal').classList.remove('hidden');
        }

        function closeDrillForm() {
            document.getElementById('drill-form-modal').classList.add('hidden');
            state.formAiHistory = [];
        }

        function renderFormAiMessages() {
            const box = document.getElementById('form-ai-messages');
            if (!box) return;
            if (!state.formAiHistory.length) {
                box.innerHTML = '<p class="text-gray-500">Ask ALL PLAYS to generate drill fields.</p>';
                return;
            }
            box.innerHTML = state.formAiHistory.map(msg => {
                const isUser = msg.role === 'user';
                return `
                    <div class="${isUser ? 'text-right' : 'text-left'}">
                        <p class="text-[10px] ${isUser ? 'text-gray-500' : 'text-indigo-600'} font-semibold mb-0.5">${isUser ? (state.user?.displayName || 'Coach') : 'ALL PLAYS COACH'}</p>
                        <div class="inline-block max-w-[95%] ${isUser ? 'bg-indigo-100 text-gray-800' : 'bg-gray-100 text-gray-700'} rounded-md px-2 py-1">
                            ${escapeHtml(msg.content || '')}
                        </div>
                    </div>
                `;
            }).join('');
            box.scrollTop = box.scrollHeight;
        }

        function collectDrillFormSnapshot() {
            return {
                title: document.getElementById('form-drill-title').value.trim(),
                type: document.getElementById('form-drill-type').value,
                level: document.getElementById('form-drill-level').value,
                skills: document.getElementById('form-drill-skills').value.split(',').map(s => s.trim()).filter(Boolean),
                duration: parseInt(document.getElementById('form-drill-duration').value, 10) || 15,
                players: document.getElementById('form-drill-players').value.trim(),
                cones: parseInt(document.getElementById('form-drill-cones').value, 10) || 0,
                description: document.getElementById('form-drill-desc').value.trim(),
                instructions: document.getElementById('form-drill-instructions').value.trim(),
                publishedToCommunity: !!document.getElementById('form-publish-community').checked
            };
        }

        function applyAiDrillFields(fields = {}) {
            if (fields.title) document.getElementById('form-drill-title').value = fields.title;
            if (fields.type && DRILL_TYPES.includes(fields.type)) document.getElementById('form-drill-type').value = fields.type;
            if (fields.level && DRILL_LEVELS.includes(fields.level)) document.getElementById('form-drill-level').value = fields.level;
            if (Array.isArray(fields.skills)) document.getElementById('form-drill-skills').value = fields.skills.join(', ');
            if (fields.duration) document.getElementById('form-drill-duration').value = Math.max(1, parseInt(fields.duration, 10) || 15);
            if (fields.players !== undefined) document.getElementById('form-drill-players').value = fields.players || '';
            if (fields.cones !== undefined) document.getElementById('form-drill-cones').value = Math.max(0, parseInt(fields.cones, 10) || 0);
            if (fields.description !== undefined) document.getElementById('form-drill-desc').value = fields.description || '';
            if (fields.instructions !== undefined) document.getElementById('form-drill-instructions').value = fields.instructions || '';
            if (typeof fields.publishedToCommunity === 'boolean') document.getElementById('form-publish-community').checked = fields.publishedToCommunity;
        }

        async function askFormAi() {
            const input = document.getElementById('form-ai-input');
            const sendBtn = document.getElementById('form-ai-send-btn');
            const text = input.value.trim();
            if (!text) return;
            input.value = '';
            input.disabled = true;
            sendBtn.disabled = true;
            state.formAiHistory.push({ role: 'user', content: text });
            renderFormAiMessages();
            try {
                const app = getApp();
                const ai = getAI(app, { backend: new GoogleAIBackend() });
                const model = getGenerativeModel(ai, { model: 'gemini-2.5-flash' });
                const prompt = `
You are ALL PLAYS COACH helping fill a drill form.
Return JSON only:
{
 "assistantMessage":"short response",
 "fields":{
   "title":"string",
   "type":"Warm-up|Tactical|Technical|Physical|Game",
   "level":"All|Initial|Basic|Intermediate|Advanced|Professional",
   "skills":["skill"],
   "duration":15,
   "players":"8-12",
   "cones":6,
   "description":"string",
   "instructions":"string",
   "publishedToCommunity":false
 }
}
Current form snapshot:
${JSON.stringify(collectDrillFormSnapshot())}
Coach request:
${text}
                `.trim();
                const result = await model.generateContent(prompt);
                const parsed = parseLooseJson(result.response.text()) || {};
                const fields = parsed.fields || {};
                applyAiDrillFields(fields);
                state.formAiHistory.push({
                    role: 'assistant',
                    content: parsed.assistantMessage || 'I updated the drill fields based on your request.'
                });
            } catch (err) {
                console.warn('Form AI failed:', err);
                state.formAiHistory.push({
                    role: 'assistant',
                    content: `I could not update fields automatically (${err?.message || 'unknown error'}).`
                });
            } finally {
                input.disabled = false;
                sendBtn.disabled = false;
                input.focus();
                renderFormAiMessages();
            }
        }

        async function submitDrillForm(e) {
            e.preventDefault();
            const id = document.getElementById('form-drill-id').value;
            const data = {
                title: document.getElementById('form-drill-title').value.trim(),
                sport: state.team?.sport || 'Soccer',
                type: document.getElementById('form-drill-type').value,
                level: document.getElementById('form-drill-level').value,
                skills: document.getElementById('form-drill-skills').value.split(',').map(s => s.trim()).filter(Boolean),
                description: document.getElementById('form-drill-desc').value.trim(),
                instructions: document.getElementById('form-drill-instructions').value.trim(),
                publishedToCommunity: !!document.getElementById('form-publish-community').checked,
                setup: {
                    duration: parseInt(document.getElementById('form-drill-duration').value) || 15,
                    players: document.getElementById('form-drill-players').value.trim(),
                    cones: parseInt(document.getElementById('form-drill-cones').value) || 0
                }
            };
            try {
                if (data.publishedToCommunity && !state.user?.isAdmin) {
                    showToast('Published drills are shared from your team. Save to publish.', 'success');
                }
                if (id) { await updateDrill(id, data); showToast('Drill updated'); }
                else { await createDrill(state.teamId, data); showToast('Drill created'); }
                invalidateAiDrillUniverse();
                closeDrillForm();
                closeDrillDetail();
                setLibTab('mydrills');
            } catch (err) {
                showToast('Failed to save drill: ' + err.message, 'error');
            }
        }

        function editDrillFromDetail() {
            if (state.currentDetailDrill) showDrillForm(state.currentDetailDrill);
        }

        async function deleteDrillConfirm() {
            if (!state.currentDetailDrill) return;
            if (!confirm(`Delete "${state.currentDetailDrill.title}"? This cannot be undone.`)) return;
            try {
                await deleteDrill(state.currentDetailDrill.id);
                invalidateAiDrillUniverse();
                showToast('Drill deleted');
                closeDrillDetail();
                loadLibrary();
            } catch (err) {
                showToast('Failed to delete: ' + err.message, 'error');
            }
        }

        // ==================== SESSION SAVE ====================
        async function saveSession() {
            if (state.canvasBlocks.length === 0) { showToast('Add drills to canvas first', 'error'); return; }
            const saveBtn = document.getElementById('btn-save-session');
            if (saveBtn) {
                saveBtn.disabled = true;
                saveBtn.textContent = 'Saving...';
            }
            const data = {
                date: new Date(document.getElementById('session-date').value),
                duration: parseInt(document.getElementById('session-duration').value) || 60,
                blocks: state.canvasBlocks.map((b, i) => ({ ...b, order: i })),
                attendance: state.attendance,
                attendancePlayers: getCheckedInCount(),
                eventId: state.eventId || null,
                eventType: state.eventId ? 'practice' : null,
                sourcePage: state.sourcePage || 'drills',
                status: 'draft'
            };
            if (state.homePacketBlocks.length > 0) {
                data.homePacketGenerated = true;
                data.homePacketContent = {
                    blocks: normalizeHomePacketBlocks(state.homePacketBlocks),
                    totalMinutes: state.homePacketBlocks.reduce((sum, b) => sum + (parseInt(b.duration, 10) || 0), 0),
                    updatedAt: new Date()
                };
            }
            try {
                if (state.sessionId) {
                    await updatePracticeSession(state.teamId, state.sessionId, data);
                } else if (state.eventId) {
                    state.sessionId = await upsertPracticeSessionForEvent(state.teamId, state.eventId, data);
                } else {
                    state.sessionId = await createPracticeSession(state.teamId, data);
                }
                showToast('Session saved');
            } catch (err) {
                showToast('Failed to save: ' + err.message, 'error');
            } finally {
                if (saveBtn) {
                    saveBtn.disabled = false;
                    saveBtn.textContent = 'Save Draft';
                }
            }
        }

        async function sharePracticePlan() {
            const params = new URLSearchParams();
            params.set('teamId', state.teamId || '');
            if (state.eventId) params.set('eventId', state.eventId);
            if (state.sourcePage) params.set('source', state.sourcePage);
            if (state.eventMeta?.date) params.set('eventDate', state.eventMeta.date);
            if (state.eventMeta?.duration) params.set('eventDuration', String(state.eventMeta.duration));
            if (state.eventMeta?.location) params.set('eventLocation', state.eventMeta.location);
            if (state.eventMeta?.title) params.set('eventTitle', state.eventMeta.title);
            const url = `${window.location.origin}/drills.html#${params.toString()}`;
            const dateLabel = document.getElementById('session-date')?.value || 'scheduled date';
            const shareText = `ALL PLAYS practice plan for ${(state.team?.name || 'team')} on ${dateLabel}`;
            const result = await shareOrCopy({
                title: 'ALL PLAYS Practice Plan',
                text: shareText,
                url,
                clipboardText: `${shareText}\n${url}`
            });
            if (result.status === 'shared') showToast('Share sheet opened!');
            else if (result.status === 'copied') showToast('Share text copied!');
            else if (result.status === 'aborted') return;
            else showToast('Could not share link', 'error');
        }

        // ==================== AI CHAT ====================
        async function ensurePracticeSessionExists(status = 'draft') {
            if (state.sessionId) return state.sessionId;
            const seed = {
                date: new Date(document.getElementById('session-date').value),
                duration: parseInt(document.getElementById('session-duration').value, 10) || 60,
                blocks: state.canvasBlocks.map((b, i) => ({ ...b, order: i })),
                attendance: state.attendance,
                eventId: state.eventId || null,
                eventType: state.eventId ? 'practice' : null,
                sourcePage: state.sourcePage || 'drills',
                status
            };
            state.sessionId = state.eventId
                ? await upsertPracticeSessionForEvent(state.teamId, state.eventId, seed)
                : await createPracticeSession(state.teamId, seed);
            return state.sessionId;
        }

        async function markPracticeStatus(status) {
            if (state.accessLevel !== 'full') return;
            const sessionId = await ensurePracticeSessionExists(status);
            if (!sessionId) return;
            await updatePracticeSession(state.teamId, sessionId, {
                status,
                blocks: state.canvasBlocks.map((b, i) => ({ ...b, order: i })),
                attendance: state.attendance
            });
        }

        async function completePractice() {
            try {
                await markPracticeStatus('completed');
                state.practiceRunning = false;
                if (state.practiceTimer) clearInterval(state.practiceTimer);
                stopActiveVoiceRecognition();
                document.getElementById('practice-play-icon').innerHTML = '<path d="M8 5v14l11-7z"/>';
                setMode('planning');
                showToast('Practice marked completed');
            } catch (err) {
                console.warn('Failed to complete practice:', err);
                showToast('Failed to mark completed', 'error');
            }
        }

        function toMillis(ts) {
            if (!ts) return 0;
            if (typeof ts === 'number') return ts;
            if (ts instanceof Date) return ts.getTime();
            if (typeof ts?.toMillis === 'function') return ts.toMillis();
            const parsed = new Date(ts);
            return Number.isNaN(parsed.getTime()) ? 0 : parsed.getTime();
        }

        function scrollChatToBottom() {
            const container = document.getElementById('chat-messages');
            if (!container) return;
            const pin = () => { container.scrollTop = container.scrollHeight; };
            pin();
            requestAnimationFrame(pin);
            setTimeout(pin, 0);
        }

        function renderChatHistory() {
            const container = document.getElementById('chat-messages');
            if (!container) return;
            const history = Array.isArray(state.aiChatHistory) ? state.aiChatHistory.slice() : [];
            const currentPhoto = state.user?.photoURL || state.user?.photoUrl || null;
            const currentName = state.user?.displayName || state.user?.email || 'Coach';
            history.forEach(turn => {
                if (turn?.role !== 'user') return;
                // Backfill older chat turns created before sender metadata existed.
                if (!turn.senderId && !turn.senderName) {
                    turn.senderId = state.user?.uid || null;
                    turn.senderName = currentName;
                }
                if (!turn.senderPhotoUrl && turn.senderId === state.user?.uid && currentPhoto) {
                    turn.senderPhotoUrl = currentPhoto;
                }
            });
            if (history.length === 0) {
                container.innerHTML = `
                    <div class="chat-bubble-ai px-4 py-3 max-w-[90%]">
                        <p class="text-sm text-gray-700">Welcome! I can help plan your practice session. Try:</p>
                        <ul class="text-sm text-gray-500 mt-2 space-y-1 list-disc pl-4">
                            <li>"Plan for 8 kids, focus on finishing"</li>
                            <li>"Add a rondo drill after warm-up"</li>
                            <li>"Shorten the session to 45 minutes"</li>
                        </ul>
                    </div>
                `;
                scrollChatToBottom();
                return;
            }

            history.sort((a, b) => toMillis(a.timestamp) - toMillis(b.timestamp));
            container.innerHTML = history.map(turn => renderChatTurn(turn)).join('');
            scrollChatToBottom();
            hydrateChatAvatars().catch(err => console.warn('Chat avatar hydrate failed:', err));
        }

        async function hydrateChatAvatars() {
            if (state.chatAvatarHydrating) return;
            const history = Array.isArray(state.aiChatHistory) ? state.aiChatHistory : [];
            const idsToLoad = [...new Set(
                history
                    .filter(t => t?.role === 'user' && t?.senderId && !t?.senderPhotoUrl && !state.chatAvatarCache.has(t.senderId))
                    .map(t => t.senderId)
            )];
            if (idsToLoad.length === 0) return;
            state.chatAvatarHydrating = true;
            try {
                await Promise.all(idsToLoad.map(async (uid) => {
                    try {
                        const profile = await getUserProfile(uid);
                        const photo = profile?.photoUrl || profile?.photoURL || null;
                        state.chatAvatarCache.set(uid, photo);
                    } catch (err) {
                        state.chatAvatarCache.set(uid, null);
                    }
                }));
                let changed = false;
                history.forEach(turn => {
                    if (turn?.role !== 'user' || !turn?.senderId || turn?.senderPhotoUrl) return;
                    if (state.chatAvatarCache.has(turn.senderId)) {
                        const photo = state.chatAvatarCache.get(turn.senderId);
                        if (photo) {
                            turn.senderPhotoUrl = photo;
                            changed = true;
                        }
                    }
                });
                if (changed) renderChatHistory();
            } finally {
                state.chatAvatarHydrating = false;
            }
        }

        function renderChatTurn(turn, opts = {}) {
            const role = turn?.role === 'assistant' ? 'assistant' : 'user';
            const isAssistant = role === 'assistant';
            const senderName = turn?.senderName
                || (isAssistant ? 'ALL PLAYS COACH' : (state.user?.displayName || state.user?.email || 'Coach'));
            const senderPhoto = isAssistant
                ? null
                : (turn?.senderPhotoUrl || state.user?.photoURL || state.user?.photoUrl || null);
            const content = opts.thinking
                ? '<p class="text-sm text-gray-500 italic">ALL PLAYS COACH is thinking...</p>'
                : `<p class="text-sm text-gray-700">${escapeHtml(turn?.content || '')}</p>`;
            const avatar = isAssistant
                ? `<img src="img/logo_small.png" alt="ALL PLAYS COACH" class="w-5 h-5 rounded-full object-cover border border-indigo-200">`
                : senderPhoto
                    ? `<img src="${escapeHtml(senderPhoto)}" alt="${escapeHtml(senderName)}" referrerpolicy="no-referrer" crossorigin="anonymous" onerror="this.style.display='none'; this.nextElementSibling && (this.nextElementSibling.style.display='flex')" class="w-5 h-5 rounded-full object-cover">`
                    : '';
            const fallbackInitial = !isAssistant
                ? `<div style="${senderPhoto ? 'display:none;' : ''}" class="w-5 h-5 rounded-full bg-gray-200 text-gray-700 text-[10px] font-bold flex items-center justify-center">${escapeHtml((senderName || '?').slice(0, 1).toUpperCase())}</div>`
                : '';
            const shellClass = isAssistant ? 'chat-bubble-ai' : 'chat-bubble-user ml-auto';
            const nameClass = isAssistant ? 'text-indigo-600' : 'text-gray-600';
            let proposalActions = '';
            if (isAssistant && turn?.aiProposal?.status === 'pending') {
                const blocks = Array.isArray(turn.aiProposal.blocks) ? turn.aiProposal.blocks : [];
                const count = blocks.length;
                const selected = getProposalSelectedIndices(turn.aiProposal);
                const selectedSet = new Set(selected);
                const selectedMinutes = selected.reduce((sum, i) => sum + (parseInt(blocks[i]?.duration, 10) || 0), 0);
                const totalMinutes = blocks.reduce((sum, b) => sum + (parseInt(b?.duration, 10) || 0), 0);
                const targetMinutes = parseInt(turn.aiProposal?.targetMinutes, 10) || null;
                const targetLine = targetMinutes
                    ? `<p class="text-[11px] text-gray-500 mb-2">Selected ${selected.length}/${count} blocks (${selectedMinutes} min). Target: ${targetMinutes} min. Proposed total: ${totalMinutes} min.</p>`
                    : `<p class="text-[11px] text-gray-500 mb-2">Selected ${selected.length}/${count} blocks (${selectedMinutes} min). Proposed total: ${totalMinutes} min.</p>`;
                const listHtml = blocks.map((b, i) => `
                    <label class="flex items-start gap-2 text-[11px] text-gray-700">
                        <input type="checkbox" ${selectedSet.has(i) ? 'checked' : ''} onchange="toggleProposalBlock('${escapeHtml(turn.turnId || '')}', ${i})" class="mt-0.5 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500">
                        <span>${escapeHtml(b.drillTitle || b.title || `Block ${i + 1}`)}  ${escapeHtml(b.type || 'Technical')}  ${parseInt(b.duration, 10) || 0} min</span>
                    </label>
                `).join('');
                proposalActions = `
                    <div class="mt-2 pt-2 border-t border-indigo-100">
                        <p class="text-[11px] text-gray-500 mb-2">Proposed ${count} block${count === 1 ? '' : 's'}.</p>
                        ${targetLine}
                        <div class="space-y-1.5 mb-2">${listHtml}</div>
                        <div class="flex flex-wrap items-center gap-2">
                            <button onclick="selectAllProposalBlocks('${escapeHtml(turn.turnId || '')}', 'all')" class="px-2.5 py-1 text-[11px] font-semibold rounded-md bg-gray-100 text-gray-700 hover:bg-gray-200">Select all</button>
                            <button onclick="selectAllProposalBlocks('${escapeHtml(turn.turnId || '')}', 'none')" class="px-2.5 py-1 text-[11px] font-semibold rounded-md bg-gray-100 text-gray-700 hover:bg-gray-200">Clear</button>
                            <button onclick="acceptAiProposal('${escapeHtml(turn.turnId || '')}', 'replace', 'selected')" class="px-2.5 py-1 text-[11px] font-semibold rounded-md bg-indigo-600 text-white hover:bg-indigo-700">Move Selected</button>
                            <button onclick="acceptAiProposal('${escapeHtml(turn.turnId || '')}', 'append', 'selected')" class="px-2.5 py-1 text-[11px] font-semibold rounded-md bg-indigo-50 text-indigo-700 border border-indigo-200 hover:bg-indigo-100">Append Selected</button>
                            <button onclick="acceptAiProposal('${escapeHtml(turn.turnId || '')}', 'replace', 'all')" class="px-2.5 py-1 text-[11px] font-semibold rounded-md bg-indigo-50 text-indigo-700 border border-indigo-200 hover:bg-indigo-100">Use All</button>
                            <button onclick="dismissAiProposal('${escapeHtml(turn.turnId || '')}')" class="px-2.5 py-1 text-[11px] font-semibold rounded-md bg-gray-100 text-gray-600 hover:bg-gray-200">Dismiss</button>
                        </div>
                    </div>
                `;
            } else if (isAssistant && turn?.aiProposal?.status === 'accepted') {
                proposalActions = `<p class="mt-2 text-[11px] text-green-700 font-medium">Added to timeline</p>`;
            } else if (isAssistant && turn?.aiProposal?.status === 'dismissed') {
                proposalActions = `<p class="mt-2 text-[11px] text-gray-500 font-medium">Suggestion dismissed</p>`;
            }
            return `
                <div class="${shellClass} px-4 py-3 max-w-[90%]">
                    <div class="flex items-center gap-2 mb-1">
                        ${avatar}
                        ${fallbackInitial}
                        <p class="text-[11px] font-semibold ${nameClass}">${escapeHtml(senderName)}</p>
                    </div>
                    ${content}
                    ${proposalActions}
                </div>
            `;
        }

        function normalizeProposalBlocks(blocks) {
            return (Array.isArray(blocks) ? blocks : []).map((b, i) => ({
                drillId: b.drillId || null,
                drillTitle: b.drillTitle || b.title || `Block ${i + 1}`,
                type: normalizeDrillType(b.type || 'Technical'),
                duration: parseInt(b.duration, 10) || 10,
                notes: b.notes || '',
                description: b.description || ''
            }));
        }

        function getProposalSelectedIndices(proposal) {
            const total = Array.isArray(proposal?.blocks) ? proposal.blocks.length : 0;
            if (total === 0) return [];
            const valid = Array.isArray(proposal?.selectedIndices)
                ? proposal.selectedIndices.filter(i => Number.isInteger(i) && i >= 0 && i < total)
                : [];
            return valid.length ? [...new Set(valid)] : Array.from({ length: total }, (_, i) => i);
        }

        async function toggleProposalBlock(turnId, blockIndex) {
            const idx = state.aiChatHistory.findIndex(t => t.turnId === turnId && t.role === 'assistant');
            if (idx < 0) return;
            const turn = state.aiChatHistory[idx];
            const proposal = turn.aiProposal;
            if (!proposal || proposal.status !== 'pending') return;
            const total = Array.isArray(proposal.blocks) ? proposal.blocks.length : 0;
            if (!Number.isInteger(blockIndex) || blockIndex < 0 || blockIndex >= total) return;
            const selected = new Set(getProposalSelectedIndices(proposal));
            if (selected.has(blockIndex)) selected.delete(blockIndex);
            else selected.add(blockIndex);
            proposal.selectedIndices = [...selected].sort((a, b) => a - b);
            renderChatHistory();
            await persistProposalState();
        }

        async function selectAllProposalBlocks(turnId, mode = 'all') {
            const idx = state.aiChatHistory.findIndex(t => t.turnId === turnId && t.role === 'assistant');
            if (idx < 0) return;
            const turn = state.aiChatHistory[idx];
            const proposal = turn.aiProposal;
            if (!proposal || proposal.status !== 'pending') return;
            const total = Array.isArray(proposal.blocks) ? proposal.blocks.length : 0;
            proposal.selectedIndices = mode === 'none' ? [] : Array.from({ length: total }, (_, i) => i);
            renderChatHistory();
            await persistProposalState();
        }

        async function acceptAiProposal(turnId, mode = 'replace', selectionMode = 'selected') {
            const idx = state.aiChatHistory.findIndex(t => t.turnId === turnId && t.role === 'assistant');
            if (idx < 0) return;
            const turn = state.aiChatHistory[idx];
            const proposal = turn.aiProposal;
            if (!proposal || proposal.status !== 'pending') return;
            const allBlocks = normalizeProposalBlocks(proposal.blocks);
            const selectedIndices = getProposalSelectedIndices(proposal);
            const proposedBlocks = selectionMode === 'all'
                ? allBlocks
                : selectedIndices.map(i => allBlocks[i]).filter(Boolean);
            if (proposedBlocks.length === 0) {
                showToast('Select at least one drill to move', 'error');
                return;
            }

            let nextBlocks;
            if (mode === 'append' && state.canvasBlocks.length > 0) {
                nextBlocks = [...state.canvasBlocks, ...proposedBlocks];
            } else {
                if (state.canvasBlocks.length > 0 && mode !== 'append') {
                    const ok = confirm('Replace the current timeline with the suggested drills?');
                    if (!ok) return;
                }
                nextBlocks = [...proposedBlocks];
            }

            state.canvasBlocks = nextBlocks;
            turn.aiProposal.status = 'accepted';
            turn.aiProposal.acceptedAt = new Date();
            turn.aiProposal.acceptedIndices = selectionMode === 'all' ? Array.from({ length: allBlocks.length }, (_, i) => i) : selectedIndices;
            renderCanvas();
            renderChatHistory();
            showToast('AI drills moved to timeline');
            await persistProposalState();
        }

        async function dismissAiProposal(turnId) {
            const idx = state.aiChatHistory.findIndex(t => t.turnId === turnId && t.role === 'assistant');
            if (idx < 0) return;
            const turn = state.aiChatHistory[idx];
            if (!turn.aiProposal || turn.aiProposal.status !== 'pending') return;
            turn.aiProposal.status = 'dismissed';
            turn.aiProposal.dismissedAt = new Date();
            renderChatHistory();
            await persistProposalState();
        }

        async function persistProposalState() {
            if (!state.sessionId) return;
            try {
                await updatePracticeSession(state.teamId, state.sessionId, {
                    aiChatHistory: state.aiChatHistory,
                    blocks: state.canvasBlocks.map((b, i) => ({ ...b, order: i }))
                });
            } catch (err) {
                console.warn('Failed to persist proposal state:', err);
                showToast('Could not save proposal state', 'error');
            }
        }

        async function sendChat() {
            const input = document.getElementById('chat-input');
            const text = input.value.trim();
            if (!text) return;
            const sendBtn = document.getElementById('chat-send-btn');
            input.value = '';
            input.disabled = true;
            sendBtn.disabled = true;
            const container = document.getElementById('chat-messages');
            container.innerHTML += renderChatTurn({
                role: 'user',
                content: text,
                senderName: state.user?.displayName || state.user?.email || 'Coach',
                senderPhotoUrl: state.user?.photoURL || state.user?.photoUrl || null
            });
            container.innerHTML += renderChatTurn({
                role: 'assistant',
                content: ''
            }, { thinking: true });
            scrollChatToBottom();

            let aiText = '';
            const attendanceSummary = getAttendanceSummary();
            const timelineSummary = getTimelineDurationSummary();
            const hasExistingTimeline = state.canvasBlocks.length > 0;
            const planScope = hasExistingTimeline && timelineSummary.gap > 0 ? 'gap-fill' : 'full-session';
            const targetMinutes = planScope === 'gap-fill' ? timelineSummary.remaining : timelineSummary.sessionDuration;
            let suggestedBlocks = [];
            let proposalStatus = 'pending';

            try {
                const aiResult = await generateAiPlan(text, attendanceSummary, targetMinutes, planScope);
                suggestedBlocks = normalizeProposalBlocks(aiResult.blocks);
                aiText = aiResult.assistantText;
            } catch (err) {
                console.warn('Gemini planning failed, using fallback:', err);
                suggestedBlocks = normalizeProposalBlocks(buildAttendanceAwarePlan(attendanceSummary, text, targetMinutes, planScope));
                aiText = `ALL PLAYS AI is temporarily unavailable (${err?.message || 'unknown error'}). I prepared an attendance-aware fallback suggestion for ${attendanceSummary.checkedIn} checked-in players (${attendanceSummary.late} late, ${attendanceSummary.absent} absent).`;
                showToast(`AI unavailable (${err?.message || 'unknown error'}). Used fallback plan.`, 'error');
            } finally {
                input.disabled = false;
                sendBtn.disabled = false;
                input.focus();
            }
            aiText = `${aiText} Target planning time: ${targetMinutes} min (${planScope === 'gap-fill' ? 'fill timeline gap' : 'full session'}). Review the suggested drills below, choose drills or use all, then move them to the timeline.`;

            const lastBubble = container.querySelector('.chat-bubble-ai:last-child');
            if (lastBubble) {
                lastBubble.innerHTML = `
                    <div class="flex items-center gap-2 mb-1">
                        <img src="img/logo_small.png" alt="ALL PLAYS COACH" class="w-5 h-5 rounded-full object-cover border border-indigo-200">
                        <p class="text-[11px] font-semibold text-indigo-600">ALL PLAYS COACH</p>
                    </div>
                    <p class="text-sm text-gray-700">${escapeHtml(aiText)}</p>
                    <p class="text-xs text-gray-400 mt-2">Context: ${escapeHtml(buildAiContextLabel())}</p>
                `;
            }
            scrollChatToBottom();

            try {
                await persistAiTurn(text, aiText, attendanceSummary, {
                    status: proposalStatus,
                    blocks: suggestedBlocks,
                    targetMinutes,
                    planScope
                });
                renderChatHistory();
            } catch (err) {
                console.warn('Failed to persist AI turn:', err);
                showToast('Plan updated but chat history did not save', 'error');
            }
        }

        function getAttendanceSummary() {
            const players = state.attendance?.players || [];
            const present = players.filter(p => p.status === 'present').length;
            const late = players.filter(p => p.status === 'late').length;
            const absent = players.filter(p => p.status === 'absent').length;
            return {
                present,
                late,
                absent,
                checkedIn: present + late,
                total: players.length
            };
        }

        function buildAiContextLabel() {
            const a = getAttendanceSummary();
            const eventCtx = state.eventId ? `eventId=${state.eventId}` : 'ad-hoc-session';
            const meta = `attendance=${a.checkedIn}/${a.total}`;
            return `${eventCtx}, ${meta}`;
        }

        function getTimelineDurationSummary() {
            const sessionDuration = parseInt(document.getElementById('session-duration').value, 10) || 60;
            const allocated = state.canvasBlocks.reduce((sum, b) => sum + (parseInt(b.duration, 10) || 0), 0);
            const gap = sessionDuration - allocated;
            return {
                sessionDuration,
                allocated,
                gap,
                remaining: Math.max(0, gap)
            };
        }

        async function generateAiPlan(userPrompt, attendanceSummary, targetMinutes, planScope = 'full-session') {
            const context = await buildAiPromptContext(attendanceSummary, userPrompt, targetMinutes, planScope);
            const app = getApp();
            const ai = getAI(app, { backend: new GoogleAIBackend() });
            const model = getGenerativeModel(ai, { model: 'gemini-2.5-flash' });
            const prompt = `
You are ALL PLAYS AI coach. Build a soccer practice plan from the provided context.

Hard constraints:
- Use attendance-aware scaling. Checked-in players: ${attendanceSummary.checkedIn} of ${attendanceSummary.total}.
- If checked-in players are below 10, include small-sided game formats.
- Return at most 3 core drill blocks in "coreBlocks".
- The total planned drill durations must equal exactly ${targetMinutes} minutes.
- Keep durations practical for the configured target duration.
- Plan scope is "${planScope}".
- If plan scope is "full-session", include warm-up and cool-down considerations.
- Prefer drills that match recent negative trends from recent games.

Return ONLY valid JSON in this shape:
{
  "assistantMessage": "short coaching rationale",
  "coreBlocks": [
    { "title": "string", "type": "Technical|Tactical|Physical|Game|Warm-up", "duration": 12, "description": "string", "notes": "string" }
  ]
}

Context JSON:
${JSON.stringify(context)}

Coach request:
${userPrompt}
            `.trim();

            const result = await model.generateContent(prompt);
            const raw = result.response.text();
            const parsed = parseAiJson(raw);
            const blocks = buildPlanFromCoreBlocks(parsed.coreBlocks || [], attendanceSummary, targetMinutes, { includeBuffers: planScope === 'full-session' });
            const assistantText = parsed.assistantMessage || `Plan updated for ${attendanceSummary.checkedIn} checked-in players and ${targetMinutes} minutes.`;
            return { blocks, assistantText };
        }

        async function buildAiPromptContext(attendanceSummary, userPrompt = '', targetMinutes = null, planScope = 'full-session') {
            const sport = state.team?.sport || 'Soccer';
            const sessionDuration = parseInt(document.getElementById('session-duration').value, 10) || 60;
            const sessionDate = document.getElementById('session-date').value || new Date().toISOString().split('T')[0];

            if (!state.aiDrillContext?.community || state.aiDrillContext.community.length === 0) {
                const communityResult = await getDrills({ sport, limitCount: 12 });
                state.aiDrillContext = {
                    ...(state.aiDrillContext || {}),
                    community: communityResult.drills || []
                };
            }
            if (!state.aiDrillContext?.myDrills && state.accessLevel === 'full') {
                const myDrills = await getTeamDrills(state.teamId);
                state.aiDrillContext = {
                    ...(state.aiDrillContext || {}),
                    myDrills: myDrills.slice(0, 12)
                };
            }

            const libraryShortlist = [...(state.aiDrillContext?.myDrills || []), ...(state.aiDrillContext?.community || [])]
                .slice(0, 18)
                .map(d => ({
                    id: d.id || null,
                    title: d.title || '',
                    type: d.type || 'Technical',
                    level: d.level || 'All',
                    skills: Array.isArray(d.skills) ? d.skills.slice(0, 4) : [],
                    duration: d.setup?.duration || null
                }));

            const recentGameContext = (state.recentGames || []).map(g => ({
                opponent: g.opponent || 'Unknown',
                score: `${g.homeScore || 0}-${g.awayScore || 0}`,
                summary: g.summary || '',
                date: (g.date?.toDate ? g.date.toDate() : new Date(g.date)).toISOString().split('T')[0]
            }));
            const recentGamesRaw = (state.recentGames || []).map(g => normalizeForAiPayload(g, 0));
            const recentWindowRaw = (state.allGames || []).slice(-10).reverse().map(g => normalizeForAiPayload(g, 0));
            const scoringLeaders = deriveScoringLeaders(recentWindowRaw);
            const rawGameContext = await ensureRawGameContext();
            const drillUniverse = await ensureAiDrillUniverse();
            const drillTopMatches = getRelevantDrillMatches(drillUniverse, userPrompt, attendanceSummary, 40);
            const drillCatalog = drillUniverse.slice(0, 500).map(d => ({
                id: d.id,
                title: d.title,
                type: d.type,
                skills: (d.skills || []).slice(0, 6),
                duration: d.duration,
                source: d.source
            }));

            return {
                team: {
                    id: state.teamId,
                    name: state.team?.name || '',
                    sport
                },
                roster: (state.playerRoster || []).map(p => ({
                    playerId: p.id,
                    name: p.name || '',
                    jerseyNumber: p.number || null
                })).slice(0, 30),
                eventContext: {
                    eventId: state.eventId || null,
                    sourcePage: state.sourcePage || 'drills',
                    eventDate: state.eventMeta?.date || null,
                    eventDuration: state.eventMeta?.duration || null,
                    eventLocation: state.eventMeta?.location || null
                },
                lastPractice: state.lastPracticeSeed ? {
                    sessionId: state.lastPracticeSeed.sessionId || null,
                    date: state.lastPracticeSeed.date || null,
                    duration: state.lastPracticeSeed.duration || null,
                    notes: state.lastPracticeSeed.notes || []
                } : null,
                sessionDuration,
                targetPlanMinutes: targetMinutes || sessionDuration,
                planScope,
                sessionDate,
                attendance: attendanceSummary,
                currentCanvas: state.canvasBlocks.map((b, idx) => ({
                    order: idx,
                    title: b.drillTitle,
                    type: b.type,
                    duration: b.duration
                })),
                recentGames: recentGameContext,
                recentGamesRaw,
                recentWindowRaw,
                scoringLeaders,
                rawGameContext,
                gameIntelligence: state.gameIntelligence || null,
                drillLibraryShortlist: libraryShortlist,
                drillLibraryTotalCount: drillUniverse.length,
                drillLibraryCatalog: drillCatalog,
                drillLibraryTopMatches: drillTopMatches
            };
        }

        async function ensureRawGameContext() {
            if (state.aiRawGameContext) return state.aiRawGameContext;
            const recentWindow = (state.allGames || []).slice(-10);
            const recentIds = recentWindow.map(g => g.id).filter(Boolean);
            let aggregatedStats = {};
            try {
                aggregatedStats = recentIds.length > 0
                    ? await getAggregatedStatsForGames(state.teamId, recentIds)
                    : {};
            } catch (err) {
                console.warn('Failed to load aggregated stats for AI context:', err);
            }

            const eventGames = (state.recentGames || []).slice(0, 3);
            const eventsByGame = {};
            await Promise.all(eventGames.map(async (g) => {
                if (!g?.id) return;
                try {
                    const events = await getGameEvents(state.teamId, g.id, { limit: 40 });
                    eventsByGame[g.id] = normalizeForAiPayload(events, 0);
                } catch (err) {
                    console.warn('Failed to load game events for AI context:', g.id, err);
                    eventsByGame[g.id] = [];
                }
            }));

            state.aiRawGameContext = {
                recentGameIds: recentIds,
                aggregatedStatsByPlayer: normalizeForAiPayload(aggregatedStats, 0),
                recentEventsByGame: eventsByGame
            };
            return state.aiRawGameContext;
        }

        function normalizeForAiPayload(value, depth = 0) {
            if (value === null || value === undefined) return null;
            if (depth > 4) return '[max-depth]';
            if (value instanceof Date) return value.toISOString();
            if (typeof value?.toDate === 'function') {
                const d = value.toDate();
                return Number.isNaN(d?.getTime?.()) ? null : d.toISOString();
            }
            if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') return value;
            if (Array.isArray(value)) return value.slice(0, 80).map(v => normalizeForAiPayload(v, depth + 1));
            if (typeof value === 'object') {
                const out = {};
                Object.keys(value).slice(0, 80).forEach(k => {
                    if (k.startsWith('_')) return;
                    const v = value[k];
                    if (typeof v === 'function') return;
                    out[k] = normalizeForAiPayload(v, depth + 1);
                });
                return out;
            }
            return String(value);
        }

        function deriveScoringLeaders(rawGames) {
            const totals = {};
            const candidateScoreKeys = ['goals', 'goal', 'pts', 'points', 'score'];
            const addScore = (name, value) => {
                const num = Number(value);
                if (!name || !Number.isFinite(num) || num <= 0) return;
                totals[name] = (totals[name] || 0) + num;
            };
            const walk = (node) => {
                if (!node || typeof node !== 'object') return;
                if (Array.isArray(node)) {
                    node.forEach(walk);
                    return;
                }
                const hasName = typeof node.name === 'string' && node.name.trim().length > 0;
                if (hasName) {
                    candidateScoreKeys.forEach(k => {
                        if (node[k] !== undefined) addScore(node.name.trim(), node[k]);
                    });
                }
                Object.values(node).forEach(walk);
            };
            (rawGames || []).forEach(walk);
            return Object.entries(totals)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 8)
                .map(([name, total]) => ({ name, total }));
        }

        function parseAiJson(raw) {
            if (!raw) throw new Error('Empty AI response');
            const cleaned = raw.trim().replace(/^```json\s*/i, '').replace(/^```\s*/i, '').replace(/\s*```$/, '').trim();
            let parsed;
            try {
                parsed = JSON.parse(cleaned);
            } catch (jsonErr) {
                const match = cleaned.match(/\{[\s\S]*\}/);
                if (!match) throw jsonErr;
                parsed = JSON.parse(match[0]);
            }
            if (!parsed || !Array.isArray(parsed.coreBlocks)) {
                throw new Error('AI response missing coreBlocks');
            }
            return parsed;
        }

        function buildPlanFromCoreBlocks(coreBlocks, attendanceSummary, sessionDuration, options = {}) {
            const totalDuration = parseInt(sessionDuration, 10) || 60;
            const includeBuffers = options.includeBuffers !== false;
            const warmupDuration = includeBuffers ? (totalDuration === 60 ? 10 : Math.max(8, Math.round(totalDuration * 0.15))) : 0;
            const cooldownDuration = includeBuffers ? (totalDuration === 60 ? 5 : Math.max(5, Math.round(totalDuration * 0.1))) : 0;
            const usableCore = Array.isArray(coreBlocks) ? coreBlocks.slice(0, 3) : [];
            const rawCoreTotal = usableCore.reduce((sum, b) => sum + (parseInt(b.duration, 10) || 0), 0);
            const remainingCoreTarget = Math.max(10, totalDuration - warmupDuration - cooldownDuration);
            const fallbackCore = [
                {
                    title: attendanceSummary.checkedIn < 10 ? 'Rondo Decision Circuit' : 'Passing + Movement Circuit',
                    type: 'Technical',
                    duration: Math.max(8, Math.round(remainingCoreTarget * 0.45)),
                    description: 'Attendance-scaled technical block',
                    notes: `${attendanceSummary.checkedIn} active players`
                },
                {
                    title: attendanceSummary.checkedIn < 10 ? '3v3/4v4 Small-Sided Game' : '5v5/6v6 Directional Game',
                    type: 'Game',
                    duration: Math.max(8, Math.round(remainingCoreTarget * 0.55)),
                    description: 'Game-context application block',
                    notes: attendanceSummary.checkedIn < 10 ? 'SSG emphasis per attendance constraint' : 'Full-group game principles'
                }
            ];
            const sourceCore = rawCoreTotal > 0 ? usableCore : fallbackCore;
            const sourceTotal = sourceCore.reduce((sum, b) => sum + (parseInt(b.duration, 10) || 0), 0);
            const scaledCore = sourceCore.map((b, idx) => {
                const sourceDuration = parseInt(b.duration, 10) || Math.round(remainingCoreTarget / Math.max(sourceCore.length, 1));
                const duration = sourceTotal > 0
                    ? Math.max(6, Math.round((sourceDuration / sourceTotal) * remainingCoreTarget))
                    : Math.max(6, sourceDuration);
                return {
                    drillId: b.drillId || null,
                    drillTitle: b.title || b.drillTitle || `Core Block ${idx + 1}`,
                    type: normalizeDrillType(b.type || 'Technical'),
                    duration,
                    notes: b.notes || `${attendanceSummary.checkedIn} active players`,
                    description: b.description || 'Targeted development block'
                };
            }).slice(0, 3);

            const normalizedCoreTotal = scaledCore.reduce((sum, b) => sum + b.duration, 0);
            const durationDelta = remainingCoreTarget - normalizedCoreTotal;
            if (scaledCore.length > 0 && durationDelta !== 0) {
                scaledCore[scaledCore.length - 1].duration = Math.max(6, scaledCore[scaledCore.length - 1].duration + durationDelta);
            }

            const blocks = [...scaledCore];
            if (includeBuffers) {
                blocks.unshift({
                    drillId: null,
                    drillTitle: 'Dynamic Ball Warm-up',
                    type: 'Warm-up',
                    duration: warmupDuration,
                    notes: attendanceSummary.checkedIn < 10 ? 'Smaller grid, higher touch count' : 'Progressive technical activation',
                    description: 'Mobility, first touch, and passing activation'
                });
                blocks.push({
                    drillId: null,
                    drillTitle: 'Cool-down + Debrief',
                    type: 'Warm-up',
                    duration: cooldownDuration,
                    notes: 'Recovery and reflection',
                    description: 'Stretching, breathing reset, and recap'
                });
            }
            return blocks;
        }

        function normalizeDrillType(type) {
            const allowed = new Set(['Warm-up', 'Tactical', 'Technical', 'Physical', 'Game']);
            return allowed.has(type) ? type : 'Technical';
        }

        function buildAttendanceAwarePlan(attendanceSummary, userPrompt, targetMinutes = null, planScope = 'full-session') {
            const sessionDuration = parseInt(document.getElementById('session-duration').value, 10) || 60;
            const baseDuration = Math.max(10, parseInt(targetMinutes, 10) || sessionDuration);
            const includeBuffers = planScope === 'full-session';
            const warmup = includeBuffers ? (baseDuration === 60 ? 10 : Math.max(8, Math.round(baseDuration * 0.15))) : 0;
            const cooldown = includeBuffers ? (baseDuration === 60 ? 5 : Math.max(5, Math.round(baseDuration * 0.1))) : 0;
            const core = Math.max(10, baseDuration - warmup - cooldown);
            const coreA = Math.max(6, Math.round(core * 0.45));
            const coreB = Math.max(6, core - coreA);
            const lowAttendance = attendanceSummary.checkedIn < 10;
            const prompt = (userPrompt || '').toLowerCase();
            const focusFinishing = prompt.includes('finish') || prompt.includes('shoot');

            const blocks = [
                {
                    drillId: null,
                    drillTitle: focusFinishing ? 'Finishing Pattern Circuit' : (lowAttendance ? 'Rondo Decision Circuit' : 'Passing + Movement Circuit'),
                    type: 'Technical',
                    duration: coreA,
                    notes: `${attendanceSummary.checkedIn} active players`,
                    description: 'Attendance-scaled technical block'
                },
                {
                    drillId: null,
                    drillTitle: lowAttendance ? '3v3/4v4 Small-Sided Game' : '5v5/6v6 Directional Game',
                    type: 'Game',
                    duration: coreB,
                    notes: lowAttendance ? 'SSG emphasis per attendance constraint' : 'Full-group game principles',
                    description: 'Game-context application block'
                }
            ];

            if (includeBuffers) {
                blocks.unshift({
                    drillId: null,
                    drillTitle: 'Dynamic Ball Warm-up',
                    type: 'Warm-up',
                    duration: warmup,
                    notes: lowAttendance ? 'Smaller grid, continuous touches' : 'Two-lane warm-up with rotations',
                    description: 'Mobility and first-touch preparation'
                });
                blocks.push({
                    drillId: null,
                    drillTitle: 'Cool-down + Debrief',
                    type: 'Warm-up',
                    duration: cooldown,
                    notes: 'Recovery and key takeaways',
                    description: 'Stretch and team recap'
                });
            }
            return blocks;
        }

        async function persistAiTurn(userText, assistantText, attendanceSummary, aiProposal = null) {
            const turnIdBase = `${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
            const userTurn = {
                turnId: `${turnIdBase}_u`,
                role: 'user',
                content: userText,
                timestamp: new Date(),
                senderId: state.user?.uid || null,
                senderName: state.user?.displayName || state.user?.email || 'Coach',
                senderPhotoUrl: state.user?.photoURL || state.user?.photoUrl || null
            };
            const normalizedProposalBlocks = normalizeProposalBlocks(aiProposal?.blocks || []);
            const assistantTurn = {
                turnId: `${turnIdBase}_a`,
                role: 'assistant',
                content: assistantText,
                timestamp: new Date(),
                senderId: null,
                senderName: 'ALL PLAYS COACH',
                senderPhotoUrl: null,
                aiProposal: aiProposal ? {
                    status: aiProposal.status || 'pending',
                    blocks: normalizedProposalBlocks,
                    selectedIndices: Array.from({ length: normalizedProposalBlocks.length }, (_, i) => i),
                    targetMinutes: aiProposal.targetMinutes || null,
                    planScope: aiProposal.planScope || 'full-session',
                    createdAt: new Date()
                } : null
            };
            state.aiChatHistory = [...(state.aiChatHistory || []), userTurn, assistantTurn];
            if (!state.sessionId) {
                const seed = {
                    date: new Date(document.getElementById('session-date').value),
                    duration: parseInt(document.getElementById('session-duration').value, 10) || 60,
                    blocks: state.canvasBlocks.map((b, i) => ({ ...b, order: i })),
                    attendance: state.attendance,
                    eventId: state.eventId || null,
                    eventType: state.eventId ? 'practice' : null,
                    sourcePage: state.sourcePage || 'drills',
                    status: 'draft'
                };
                state.sessionId = state.eventId
                    ? await upsertPracticeSessionForEvent(state.teamId, state.eventId, seed)
                    : await createPracticeSession(state.teamId, seed);
            }
            await updatePracticeSession(state.teamId, state.sessionId, {
                aiChatHistory: state.aiChatHistory,
                aiContext: {
                    gameIntelligence: state.gameIntelligence || null,
                    lastPractice: state.lastPracticeSeed ? {
                        sessionId: state.lastPracticeSeed.sessionId || null,
                        date: state.lastPracticeSeed.date || null,
                        duration: state.lastPracticeSeed.duration || null,
                        notes: state.lastPracticeSeed.notes || []
                    } : null,
                    presentPlayerIds: (state.attendance?.players || []).filter(p => p.status === 'present' || p.status === 'late').map(p => p.playerId),
                    attendanceSummary: {
                        present: attendanceSummary.present,
                        late: attendanceSummary.late,
                        absent: attendanceSummary.absent
                    }
                },
                blocks: state.canvasBlocks.map((b, i) => ({ ...b, order: i }))
            });
        }

        // ==================== HOME PACKET ====================
        function normalizeHomePacketBlocks(blocks) {
            return (Array.isArray(blocks) ? blocks : []).map((b, i) => ({
                drillId: b.drillId || null,
                drillTitle: b.drillTitle || b.title || `Home Drill ${i + 1}`,
                type: normalizeDrillType(b.type || 'Technical'),
                duration: Math.max(1, parseInt(b.duration, 10) || 10),
                description: b.description || '',
                notes: b.notes || ''
            }));
        }

        function seedHomePacketFromTimeline() {
            return state.canvasBlocks.map((b, i) => ({
                drillId: b.drillId || null,
                drillTitle: b.drillTitle || `Home Drill ${i + 1}`,
                type: normalizeDrillType(b.type || 'Technical'),
                duration: Math.max(1, parseInt(b.duration, 10) || 10),
                description: b.description || 'Practice this drill at home with minimal equipment.',
                notes: b.notes || ''
            }));
        }

        function renderHomePacketEditor() {
            const content = document.getElementById('home-packet-content');
            const totalEl = document.getElementById('home-packet-total');
            const completionEl = document.getElementById('home-packet-completion-summary');
            if (!content || !totalEl) return;
            const total = state.homePacketBlocks.reduce((sum, b) => sum + (parseInt(b.duration, 10) || 0), 0);
            totalEl.textContent = `${total} min`;
            if (completionEl) {
                const completed = (state.homePacketCompletions || []).filter(c => c.status === 'completed');
                if (completed.length > 0) {
                    const names = [...new Set(completed.map(c => c.childName).filter(Boolean))];
                    completionEl.textContent = `Parent completions: ${completed.length}${names.length ? ` (${names.join(', ')})` : ''}`;
                    completionEl.classList.remove('hidden');
                } else {
                    completionEl.classList.add('hidden');
                    completionEl.textContent = '';
                }
            }
            if (!state.homePacketBlocks.length) {
                content.innerHTML = '<div class="text-sm text-gray-500 text-center py-8">No home drills yet. Add drills to timeline first.</div>';
                return;
            }

            content.innerHTML = state.homePacketBlocks.map((b, i) => `
                <div draggable="true"
                    ondragstart="startDragHomePacket(event, ${i})"
                    ondragover="allowDropHomePacket(event)"
                    ondrop="dropHomePacket(event, ${i})"
                    class="rounded-xl border border-blue-100 bg-blue-50 p-3">
                    <div class="flex items-start justify-between gap-2">
                        <div class="min-w-0">
                            <p class="text-xs font-semibold text-blue-700 uppercase tracking-wide mb-1">${escapeHtml(b.type || 'Technical')}</p>
                            <h4 class="text-sm font-semibold text-blue-900">${escapeHtml(b.drillTitle)}</h4>
                            <p class="text-xs text-blue-700 mt-1">${escapeHtml(b.description || '')}</p>
                        </div>
                        <button onclick="removeHomePacketBlock(${i})" class="text-xs px-2 py-1 rounded bg-white border border-blue-100 text-blue-700 hover:bg-blue-100">Remove</button>
                    </div>
                    <div class="mt-3 flex items-center justify-between gap-2">
                        <span class="text-[11px] text-blue-700">Duration</span>
                        <div class="flex items-center gap-1">
                            <input type="number" min="1" max="120" value="${parseInt(b.duration, 10) || 1}" data-home-dur="${i}" class="w-14 px-2 py-1 border border-blue-200 rounded text-xs text-center bg-white">
                            <span class="text-[11px] text-blue-700">min</span>
                        </div>
                    </div>
                </div>
            `).join('');

            content.querySelectorAll('[data-home-dur]').forEach((input) => {
                input.addEventListener('change', (e) => {
                    const idx = parseInt(e.target.dataset.homeDur, 10);
                    if (!Number.isInteger(idx) || !state.homePacketBlocks[idx]) return;
                    state.homePacketBlocks[idx].duration = Math.max(1, parseInt(e.target.value, 10) || 1);
                    renderHomePacketEditor();
                });
            });
        }

        async function loadHomePacketCompletions() {
            if (!state.sessionId) {
                state.homePacketCompletions = [];
                return;
            }
            try {
                state.homePacketCompletions = await getPracticePacketCompletions(state.teamId, state.sessionId);
            } catch (err) {
                console.warn('Failed loading packet completions:', err);
                state.homePacketCompletions = [];
            }
        }

        function generateHomePacket() {
            if (state.canvasBlocks.length === 0 && state.homePacketBlocks.length === 0) {
                showToast('Add drills first', 'error');
                return;
            }
            if (!state.homePacketBlocks.length) {
                state.homePacketBlocks = seedHomePacketFromTimeline();
            }
            loadHomePacketCompletions().then(() => {
                renderHomePacketEditor();
            }).catch(() => {
                renderHomePacketEditor();
            });
            state.homePacketLibraryOpen = false;
            renderHomePacketLibraryPicker([]);
            document.getElementById('home-packet-modal').classList.remove('hidden');
        }
        function closeHomePacket() {
            document.getElementById('home-packet-modal').classList.add('hidden');
            state.homePacketLibraryOpen = false;
            renderHomePacketLibraryPicker([]);
        }

        function resetHomePacketFromTimeline() {
            state.homePacketBlocks = seedHomePacketFromTimeline();
            renderHomePacketEditor();
            showToast('Home packet reset from timeline');
        }

        function renderHomePacketLibraryPicker(results = []) {
            const resultsEl = document.getElementById('home-packet-library-results');
            const openBtn = document.getElementById('home-packet-open-library-btn');
            if (!resultsEl || !openBtn) return;
            openBtn.textContent = state.homePacketLibraryOpen ? 'Hide Library' : 'Add From Library';
            resultsEl.classList.toggle('hidden', !state.homePacketLibraryOpen);
            if (!state.homePacketLibraryOpen) {
                resultsEl.innerHTML = '';
                return;
            }
            if (!results.length) {
                resultsEl.innerHTML = '<div class="px-3 py-2 text-xs text-gray-500">No drills found.</div>';
                return;
            }
            resultsEl.innerHTML = results.map(d => `
                <div class="px-3 py-2 flex items-center justify-between gap-2">
                    <div class="min-w-0">
                        <p class="text-xs font-semibold text-gray-800 truncate">${escapeHtml(d.title || 'Untitled')}</p>
                        <p class="text-[11px] text-gray-500 truncate">${escapeHtml(d.type || 'Technical')}  ${parseInt(d.duration, 10) || 10} min</p>
                    </div>
                    <button onclick="addHomePacketFromLibrary('${escapeHtml(d.id)}')" class="px-2 py-1 text-[11px] font-semibold rounded bg-blue-100 text-blue-700 hover:bg-blue-200">Add</button>
                </div>
            `).join('');
        }

        async function openHomePacketLibrary() {
            state.homePacketLibraryOpen = !state.homePacketLibraryOpen;
            if (!state.homePacketLibraryOpen) {
                renderHomePacketLibraryPicker([]);
                return;
            }
            await refreshHomePacketLibrary();
        }

        async function refreshHomePacketLibrary() {
            if (!state.homePacketLibraryOpen) return;
            const queryInput = document.getElementById('home-packet-library-search');
            const query = (queryInput?.value || '').trim().toLowerCase();
            let universe = [];
            try {
                universe = await ensureAiDrillUniverse();
            } catch (err) {
                console.warn('Home packet library load failed:', err);
            }
            const list = (Array.isArray(universe) ? universe : [])
                .filter(d => !query || (d.title || '').toLowerCase().includes(query) || (d.type || '').toLowerCase().includes(query) || (d.skills || []).some(s => (s || '').toLowerCase().includes(query)))
                .slice(0, 40)
                .map(d => ({
                    id: d.id,
                    title: d.title,
                    type: d.type || 'Technical',
                    duration: d.duration || 10,
                    description: d.description || ''
                }));
            renderHomePacketLibraryPicker(list);
        }

        function addHomePacketFromLibrary(drillId) {
            const universe = Array.isArray(state.aiDrillUniverse) ? state.aiDrillUniverse : [];
            const drill = universe.find(d => d.id === drillId);
            if (!drill) {
                showToast('Drill not available yet', 'error');
                return;
            }
            state.homePacketBlocks.push({
                drillId: drill.id,
                drillTitle: drill.title || 'Home Drill',
                type: normalizeDrillType(drill.type || 'Technical'),
                duration: Math.max(1, parseInt(drill.duration, 10) || 10),
                description: drill.description || 'At-home focus drill',
                notes: ''
            });
            renderHomePacketEditor();
            showToast('Drill added from library');
        }

        function startDragHomePacket(event, index) {
            state.homePacketDragIndex = index;
            event.dataTransfer.effectAllowed = 'move';
        }
        function allowDropHomePacket(event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';
        }
        function dropHomePacket(event, targetIndex) {
            event.preventDefault();
            const sourceIndex = state.homePacketDragIndex;
            if (sourceIndex === null || sourceIndex === targetIndex) return;
            const moved = state.homePacketBlocks.splice(sourceIndex, 1)[0];
            state.homePacketBlocks.splice(targetIndex, 0, moved);
            state.homePacketDragIndex = null;
            renderHomePacketEditor();
        }

        function removeHomePacketBlock(index) {
            state.homePacketBlocks.splice(index, 1);
            renderHomePacketEditor();
        }

        async function saveHomePacket() {
            if (!state.homePacketBlocks.length) {
                showToast('Add at least one home drill', 'error');
                return;
            }
            const normalizedBlocks = normalizeHomePacketBlocks(state.homePacketBlocks);
            const payload = {
                homePacketGenerated: true,
                homePacketContent: {
                    blocks: normalizedBlocks,
                    totalMinutes: normalizedBlocks.reduce((sum, b) => sum + (parseInt(b.duration, 10) || 0), 0),
                    updatedAt: new Date()
                }
            };
            try {
                if (!state.sessionId) {
                    const seed = {
                        date: new Date(document.getElementById('session-date').value),
                        duration: parseInt(document.getElementById('session-duration').value, 10) || 60,
                        blocks: state.canvasBlocks.map((b, i) => ({ ...b, order: i })),
                        attendance: state.attendance,
                        eventId: state.eventId || null,
                        eventType: state.eventId ? 'practice' : null,
                        sourcePage: state.sourcePage || 'drills',
                        status: 'draft',
                        ...payload
                    };
                    state.sessionId = state.eventId
                        ? await upsertPracticeSessionForEvent(state.teamId, state.eventId, seed)
                        : await createPracticeSession(state.teamId, seed);
                } else {
                    await updatePracticeSession(state.teamId, state.sessionId, payload);
                }
                state.homePacketBlocks = normalizedBlocks;
                await loadHomePacketCompletions();
                showToast('Home packet saved');
                closeHomePacket();
            } catch (err) {
                console.warn('Failed to save home packet:', err);
                showToast('Failed to save home packet', 'error');
            }
        }

        // ==================== ATTENDANCE ====================
        function getCheckedInCount() {
            if (!state.attendance?.players) return 0;
            return state.attendance.players.filter(p => p.status === 'present' || p.status === 'late').length;
        }

        function renderAttendancePanel() {
            const list = document.getElementById('attendance-list');
            const summary = document.getElementById('attendance-count');
            const headerSummary = document.getElementById('practice-attendance-summary');
            const toggleBtn = document.getElementById('attendance-toggle-btn');
            if (!list || !state.attendance) return;

            const checkedIn = getCheckedInCount();
            const total = state.attendance.players.length;
            summary.textContent = `${checkedIn} / ${total} checked in`;
            headerSummary.textContent = `Checked in: ${checkedIn}/${total}`;
            if (toggleBtn) toggleBtn.textContent = state.practiceAttendanceCollapsed ? 'Expand' : 'Collapse';

            list.innerHTML = state.attendance.players.map(p => `
                <div class="flex items-center justify-between" data-player-id="${escapeHtml(p.playerId)}">
                    <span class="text-gray-200">${escapeHtml(p.displayName)}</span>
                    <div class="flex gap-1">
                        <button ${state.accessLevel !== 'full' ? 'disabled' : ''} onclick="setAttendanceStatus('${escapeHtml(p.playerId)}','present', this)" class="attendance-btn ${p.status === 'present' ? 'active-present' : ''} text-[10px] px-2 py-1 rounded-md ${state.accessLevel !== 'full' ? 'opacity-50 cursor-not-allowed' : ''}">Present</button>
                        <button ${state.accessLevel !== 'full' ? 'disabled' : ''} onclick="setAttendanceStatus('${escapeHtml(p.playerId)}','late', this)" class="attendance-btn ${p.status === 'late' ? 'active-late' : ''} text-[10px] px-2 py-1 rounded-md ${state.accessLevel !== 'full' ? 'opacity-50 cursor-not-allowed' : ''}">Late</button>
                        <button ${state.accessLevel !== 'full' ? 'disabled' : ''} onclick="setAttendanceStatus('${escapeHtml(p.playerId)}','absent', this)" class="attendance-btn ${p.status === 'absent' ? 'active-absent' : ''} text-[10px] px-2 py-1 rounded-md ${state.accessLevel !== 'full' ? 'opacity-50 cursor-not-allowed' : ''}">Absent</button>
                    </div>
                </div>
            `).join('');
            list.classList.toggle('hidden', !!state.practiceAttendanceCollapsed);
        }

        function toggleAttendancePanel() {
            state.practiceAttendanceCollapsed = !state.practiceAttendanceCollapsed;
            renderAttendancePanel();
        }

        function renderNotesPanel() {
            const panel = document.getElementById('notes-panel-content');
            const toggleBtn = document.getElementById('notes-toggle-btn');
            if (!panel || !toggleBtn) return;
            panel.classList.toggle('hidden', !!state.practiceNotesCollapsed);
            toggleBtn.textContent = state.practiceNotesCollapsed ? 'Expand' : 'Collapse';
        }

        function toggleNotesPanel() {
            state.practiceNotesCollapsed = !state.practiceNotesCollapsed;
            renderNotesPanel();
        }

        async function setAttendanceStatus(playerId, status, buttonEl) {
            if (state.accessLevel !== 'full') return;
            const p = state.attendance?.players?.find(x => x.playerId === playerId);
            if (!p) return;
            p.status = status;
            p.checkedInAt = status === 'present' || status === 'late' ? new Date() : null;
            state.attendance.checkedInCount = getCheckedInCount();
            state.attendance.updatedAt = new Date();
            state.attendance.editedAt = new Date();

            const row = buttonEl.closest('[data-player-id]');
            if (row) {
                row.querySelectorAll('.attendance-btn').forEach(btn => btn.classList.remove('active-present', 'active-late', 'active-absent'));
                buttonEl.classList.add(status === 'present' ? 'active-present' : status === 'late' ? 'active-late' : 'active-absent');
            }
            renderAttendancePanel();

            if (state.sessionId) {
                try {
                    await updatePracticeAttendance(state.teamId, state.sessionId, state.attendance);
                } catch (err) {
                    console.warn('Attendance update failed:', err);
                    showToast('Failed to save attendance', 'error');
                }
            }
        }

        // ==================== PRACTICE MODE ====================
        function initPracticeMode() {
            state.practiceIndex = 0;
            state.practiceRunning = false;
            if (state.practiceTimer) clearInterval(state.practiceTimer);
            stopActiveVoiceRecognition();
            renderAttendancePanel();
            renderNotesPanel();
            renderPracticeDrill();
        }

        function stopActiveVoiceRecognition() {
            if (state.activeVoiceRecognition && state.voiceListening) {
                try { state.activeVoiceRecognition.stop(); } catch (_) {}
            }
            state.voiceListening = false;
            state.activeVoiceRecognition = null;
            const hint = document.getElementById('voice-note-hint');
            setVoiceNoteButtonLabel(false);
            if (hint) hint.textContent = 'Tap Start voice note, speak, then tap Stop voice note.';
        }

        function setVoiceNoteButtonLabel(isListening) {
            const btn = document.getElementById('voice-note-btn');
            if (!btn) return;
            const label = isListening ? 'Stop voice note' : 'Start voice note';
            btn.innerHTML = `
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z"/></svg>
                <span>${label}</span>
            `;
        }

        function renderPracticeDrill() {
            const blocks = state.canvasBlocks;
            const idx = state.practiceIndex;
            const counter = document.getElementById('practice-drill-counter');
            counter.textContent = blocks.length ? `Drill ${idx + 1} of ${blocks.length}` : 'No drills';

            if (blocks.length === 0) {
                document.getElementById('practice-drill-title').textContent = 'No Drills';
                document.getElementById('practice-drill-desc').textContent = 'Add drills in Planning mode first';
                document.getElementById('practice-timer').textContent = '0:00';
                document.getElementById('practice-next-btn').classList.add('hidden');
                document.getElementById('practice-note').classList.add('hidden');
                return;
            }

            const b = blocks[idx];
            document.getElementById('practice-type-badge').className = `${getTypeClass(b.type)} text-xs font-bold px-3 py-1 rounded-full uppercase`;
            document.getElementById('practice-type-badge').textContent = b.type;
            document.getElementById('practice-drill-title').textContent = b.drillTitle;
            document.getElementById('practice-drill-desc').textContent = b.description || '';

            state.practiceSecondsLeft = (b.duration || 1) * 60;
            updateTimerDisplay();

            // Note
            const notesList = Array.isArray(b.notesLog) ? b.notesLog : [];
            const noteText = (b.notes || '').trim();
            if (notesList.length > 0 || noteText) {
                document.getElementById('practice-note').classList.remove('hidden');
                const rendered = [
                    ...notesList.map(n => ` ${n.type === 'voice' ? '[Voice]' : '[Text]'} ${n.text || ''}`.trim()),
                    ...(noteText ? [` ${noteText}`] : [])
                ];
                document.getElementById('practice-note-text').textContent = rendered.join('\n');
            } else {
                document.getElementById('practice-note').classList.add('hidden');
            }

            // Next button
            if (idx < blocks.length - 1) {
                const next = blocks[idx + 1];
                document.getElementById('practice-next-btn').classList.remove('hidden');
                document.getElementById('practice-next-title').textContent = next.drillTitle;
                document.getElementById('practice-next-meta').textContent = `${next.duration} min \u00b7 ${next.type}`;
            } else {
                document.getElementById('practice-next-btn').classList.add('hidden');
            }

            // Progress
            const totalMin = blocks.reduce((s, bl) => s + (bl.duration || 0), 0);
            const elapsedMin = blocks.slice(0, idx).reduce((s, bl) => s + (bl.duration || 0), 0);
            document.getElementById('practice-progress-text').textContent = `${elapsedMin} of ${totalMin} min`;
            document.getElementById('practice-progress-bar').style.width = totalMin ? `${(elapsedMin / totalMin) * 100}%` : '0%';
        }

        function practiceToggle() {
            if (state.canvasBlocks.length === 0) return;
            state.practiceRunning = !state.practiceRunning;
            const icon = document.getElementById('practice-play-icon');
            if (state.practiceRunning) {
                icon.innerHTML = '<path d="M6 4h4v16H6V4zm8 0h4v16h-4V4z"/>';
                state.practiceTimer = setInterval(() => {
                    if (state.practiceSecondsLeft <= 0) {
                        practiceNext();
                        return;
                    }
                    state.practiceSecondsLeft--;
                    updateTimerDisplay();
                }, 1000);
            } else {
                icon.innerHTML = '<path d="M8 5v14l11-7z"/>';
                clearInterval(state.practiceTimer);
            }
        }

        function updateTimerDisplay() {
            const m = Math.floor(state.practiceSecondsLeft / 60);
            const s = state.practiceSecondsLeft % 60;
            document.getElementById('practice-timer').textContent = `${m}:${s.toString().padStart(2, '0')}`;
        }

        function practiceNext() {
            if (state.practiceIndex < state.canvasBlocks.length - 1) {
                stopActiveVoiceRecognition();
                state.practiceIndex++;
                state.practiceRunning = false;
                clearInterval(state.practiceTimer);
                document.getElementById('practice-play-icon').innerHTML = '<path d="M8 5v14l11-7z"/>';
                renderPracticeDrill();
            }
        }

        function practicePrev() {
            if (state.practiceIndex > 0) {
                stopActiveVoiceRecognition();
                state.practiceIndex--;
                state.practiceRunning = false;
                clearInterval(state.practiceTimer);
                document.getElementById('practice-play-icon').innerHTML = '<path d="M8 5v14l11-7z"/>';
                renderPracticeDrill();
            }
        }

        function appendPracticeNote(text, type = 'text') {
            const block = state.canvasBlocks[state.practiceIndex];
            if (!block) return false;
            const clean = (text || '').trim();
            if (!clean) return false;
            if (!Array.isArray(block.notesLog)) block.notesLog = [];
            block.notesLog.push({
                type,
                text: clean,
                createdAt: new Date().toISOString()
            });
            block.notes = `${(block.notes || '').trim()}${block.notes ? '\n' : ''}${clean}`.trim();
            renderPracticeDrill();
            persistActiveBlockNotes().catch(err => console.warn('Failed to persist note:', err));
            return true;
        }

        async function persistActiveBlockNotes() {
            if (!state.sessionId) return;
            await updatePracticeSession(state.teamId, state.sessionId, {
                blocks: state.canvasBlocks.map((b, i) => ({ ...b, order: i }))
            });
        }

        function addFreeTextNote() {
            const input = document.getElementById('practice-free-note-input');
            if (!input) return;
            const text = input.value.trim();
            if (!text) return;
            const ok = appendPracticeNote(text, 'text');
            if (ok) {
                input.value = '';
                showToast('Text note added');
            }
        }

        function startVoiceNote() {
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                showToast('Voice notes not supported in this browser', 'error');
                return;
            }
            const hint = document.getElementById('voice-note-hint');

            if (state.voiceListening && state.activeVoiceRecognition) {
                try {
                    state.activeVoiceRecognition.stop();
                    showToast('Stopping voice note...');
                } catch (err) {
                    console.warn('Voice stop failed:', err);
                }
                return;
            }

            const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
            const recognition = new SR();
            state.activeVoiceRecognition = recognition;
            state.voiceListening = true;
            recognition.lang = 'en-US';
            recognition.interimResults = false;
            recognition.continuous = false;

            setVoiceNoteButtonLabel(true);
            if (hint) hint.textContent = 'Recording... tap Stop voice note when finished.';

            recognition.onresult = (e) => {
                const transcript = e.results?.[0]?.[0]?.transcript || '';
                if (appendPracticeNote(transcript, 'voice')) {
                    showToast('Voice note saved');
                } else {
                    showToast('No speech detected', 'error');
                }
            };
            recognition.onerror = (event) => {
                console.warn('Voice recognition error:', event);
                if (event?.error !== 'no-speech' && event?.error !== 'aborted') {
                    showToast('Voice recognition failed', 'error');
                }
            };
            recognition.onend = () => {
                state.voiceListening = false;
                state.activeVoiceRecognition = null;
                setVoiceNoteButtonLabel(false);
                if (hint) hint.textContent = 'Tap Start voice note, speak, then tap Stop voice note.';
            };

            recognition.start();
            showToast('Listening...');
        }

        // ==================== TOAST ====================
        function showToast(msg, type = 'success') {
            const toast = document.getElementById('toast');
            toast.textContent = msg;
            toast.className = `fixed bottom-6 right-6 z-50 px-4 py-3 rounded-xl shadow-lg text-sm font-medium ${type === 'error' ? 'bg-red-600 text-white' : 'bg-gray-800 text-white'}`;
            setTimeout(() => toast.classList.add('hidden'), 3000);
        }
    </script>
</body>
</html>
