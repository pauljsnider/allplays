<!DOCTYPE html>
<html lang="en">

<head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-3J13LHWFT3"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-3J13LHWFT3');
  </script>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" href="img/logo_small.png">
    <title>Edit Schedule - ALL PLAYS</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="css/styles.css">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: {
                            50: '#eef2ff',
                            100: '#e0e7ff',
                            500: '#6366f1',
                            600: '#4f46e5',
                            700: '#4338ca',
                            800: '#3730a3',
                            900: '#312e81'
                        }
                    }
                }
            }
        }
    </script>
</head>

<body class="bg-gray-50 text-gray-900">
    <div id="header-container"></div>

    <main class="container mx-auto px-4 py-8">
        <div id="team-admin-banner" class="mb-6"></div>

        <!-- Calendar Management -->
        <div class="mb-6 bg-indigo-50 border border-indigo-200 rounded-lg p-4">
            <div class="flex justify-between items-center mb-3">
                <h3 class="font-semibold text-indigo-900">üìÖ Calendar Links</h3>
                <button id="add-calendar-btn"
                    class="text-sm bg-indigo-600 text-white px-3 py-1 rounded hover:bg-indigo-700">
                    + Add Calendar
                </button>
            </div>
            <div id="calendar-list" class="space-y-2">
                <!-- Calendar URLs will be listed here -->
            </div>
            <div id="add-calendar-form" class="hidden mt-3 p-3 bg-white rounded border border-indigo-200">
                <input type="url" id="calendar-url-input" placeholder="https://example.com/calendar.ics"
                    class="w-full px-3 py-2 border border-gray-300 rounded mb-2 text-sm">
                <div class="flex gap-2">
                    <button id="save-calendar-btn"
                        class="bg-green-600 text-white px-3 py-1 rounded text-sm hover:bg-green-700">Save</button>
                    <button id="cancel-calendar-btn"
                        class="bg-gray-500 text-white px-3 py-1 rounded text-sm hover:bg-gray-600">Cancel</button>
                </div>
            </div>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            <!-- Add Game Form -->
            <div class="lg:col-span-1">
                <div class="bg-white rounded-lg shadow-md overflow-visible md:overflow-hidden sticky top-8">
                    <!-- Tab Navigation -->
                    <div class="flex border-b border-gray-200">
                        <button id="tab-add-game" class="flex-1 px-3 py-3 text-sm font-medium text-indigo-600 border-b-2 border-indigo-600 bg-indigo-50">
                            Game
                        </button>
                        <button id="tab-add-practice" class="flex-1 px-3 py-3 text-sm font-medium text-gray-600 hover:text-gray-800 hover:bg-gray-50">
                            Practice
                        </button>
                        <button id="tab-bulk-ai" class="flex-1 px-3 py-3 text-sm font-medium text-gray-600 hover:text-gray-800 hover:bg-gray-50">
                            ‚ú® AI
                        </button>
                    </div>

                    <!-- Add Game Tab Content -->
                    <div id="content-add-game" class="p-6">
                        <h2 class="text-xl font-bold mb-4">Add Game</h2>
                        <form id="add-game-form" class="space-y-4">
                        <div>
                            <label class="block text-sm font-medium text-gray-700">Date & Time</label>
                            <input type="datetime-local" id="gameDate" required
                                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 border p-2">
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700">Opponent</label>
                            <div class="relative">
                                <input type="text" id="opponent" required
                                    class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 border p-2"
                                    placeholder="Search or type opponent name">
                                <div id="opponent-search-results"
                                    class="hidden absolute z-10 mt-1 w-full bg-white border border-gray-200 rounded-md shadow-lg max-h-60 overflow-auto text-sm">
                                </div>
                            </div>
                            <div id="linked-opponent-chip"
                                class="hidden mt-2 inline-flex items-center gap-2 text-xs font-medium bg-indigo-50 text-indigo-700 border border-indigo-200 rounded-full px-3 py-1">
                                <span>Linked:</span>
                                <span id="linked-opponent-name" class="font-semibold"></span>
                                <button type="button" id="clear-linked-opponent" class="text-indigo-600 hover:text-indigo-800">Remove</button>
                            </div>
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700">Location</label>
                            <input type="text" id="location"
                                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 border p-2">
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700">Home / Away</label>
                            <div class="mt-1 flex gap-2">
                                <button type="button" id="homeAwayHome" class="flex-1 px-3 py-2 border border-gray-300 rounded-md text-sm font-medium text-gray-700 hover:bg-indigo-50 focus:outline-none transition" onclick="setHomeAway('home')">Home</button>
                                <button type="button" id="homeAwayAway" class="flex-1 px-3 py-2 border border-gray-300 rounded-md text-sm font-medium text-gray-700 hover:bg-indigo-50 focus:outline-none transition" onclick="setHomeAway('away')">Away</button>
                                <button type="button" id="homeAwayClear" class="px-3 py-2 border border-gray-300 rounded-md text-sm text-gray-400 hover:bg-gray-50 focus:outline-none transition" onclick="setHomeAway(null)">Clear</button>
                            </div>
                            <input type="hidden" id="isHome" value="">
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700">Kit Color</label>
                            <input type="text" id="kitColor" placeholder="e.g. White home kit"
                                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 border p-2">
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700">Arrival Time</label>
                            <input type="datetime-local" id="arrivalTime"
                                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 border p-2">
                            <p class="text-xs text-gray-500 mt-1">When players should arrive (if different from game time)</p>
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700">Notes</label>
                            <textarea id="gameNotes" rows="2" placeholder="Optional game notes..."
                                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 border p-2"></textarea>
                        </div>
                        <!-- Assignments Section -->
                        <div id="assignments-section">
                            <label class="block text-sm font-medium text-gray-700 mb-1">Assignments</label>
                            <div id="assignment-rows" class="space-y-2"></div>
                            <button type="button" id="add-assignment-btn" class="mt-2 text-sm text-indigo-600 hover:text-indigo-800 font-medium">+ Add Assignment</button>
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700">Stat Config</label>
                            <select id="statConfig"
                                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 border p-2">
                                <option value="">Default (None)</option>
                                <!-- Configs loaded here -->
                            </select>
                            <p class="text-xs text-gray-500 mt-1">Create configs in <a href="#" id="config-link"
                                    class="text-indigo-600 hover:underline">Edit Configs</a></p>
                        </div>
                        <div class="flex gap-2">
                            <button type="submit" id="submit-game-btn"
                                class="flex-1 bg-indigo-600 text-white py-2 px-4 rounded-md hover:bg-indigo-700 transition">Add
                                Game</button>
                            <button type="button" id="cancel-edit-game-btn"
                                class="hidden px-4 py-2 bg-gray-500 text-white rounded-md hover:bg-gray-600 transition">Cancel</button>
                        </div>
                    </form>
                    </div>

                    <!-- Add Practice Tab Content -->
                    <div id="content-add-practice" class="p-6 hidden">
                        <h2 class="text-xl font-bold mb-4">Add Practice</h2>
                        <form id="add-practice-form" class="space-y-4">
                            <div>
                                <label class="block text-sm font-medium text-gray-700">Title</label>
                                <input type="text" id="practiceTitle" value="Practice"
                                    class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 border p-2">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700">Start Date & Time</label>
                                <input type="datetime-local" id="practiceStart" required
                                    class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 border p-2">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700">End Time</label>
                                <input type="datetime-local" id="practiceEnd"
                                    class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 border p-2">
                                <p class="text-xs text-gray-500 mt-1">Defaults to 1.5 hours after start</p>
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700">Location</label>
                                <input type="text" id="practiceLocation"
                                    class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 border p-2">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700">Notes</label>
                                <textarea id="practiceNotes" rows="2"
                                    class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 border p-2"
                                    placeholder="Optional notes..."></textarea>
                            </div>

                            <!-- Recurrence Builder (Phase 2) -->
                            <div class="border-t border-gray-200 pt-4 mt-4">
                                <label class="flex items-center gap-2 cursor-pointer">
                                    <input type="checkbox" id="practiceRecurring" class="rounded text-indigo-600">
                                    <span class="text-sm font-medium text-gray-700">Make this a recurring practice</span>
                                </label>

                                <div id="recurrence-builder" class="hidden mt-4 space-y-4 p-4 bg-gray-50 rounded-lg">
                                    <div class="grid grid-cols-2 gap-4">
                                        <div>
                                            <label class="block text-sm font-medium text-gray-700">Repeat</label>
                                            <select id="recurrenceFreq"
                                                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 border p-2">
                                                <option value="weekly">Weekly</option>
                                                <option value="daily">Daily</option>
                                            </select>
                                        </div>
                                        <div>
                                            <label class="block text-sm font-medium text-gray-700">Every</label>
                                            <div class="flex items-center gap-2 mt-1">
                                                <input type="number" id="recurrenceInterval" value="1" min="1" max="12"
                                                    class="w-16 rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 border p-2">
                                                <span class="text-sm text-gray-600" id="interval-label">week(s)</span>
                                            </div>
                                        </div>
                                    </div>

                                    <div id="day-selector">
                                        <label class="block text-sm font-medium text-gray-700 mb-2">On days</label>
                                        <div class="flex flex-wrap gap-2">
                                            <label class="inline-flex items-center">
                                                <input type="checkbox" value="SU" class="day-checkbox rounded text-indigo-600">
                                                <span class="ml-1 text-sm">Sun</span>
                                            </label>
                                            <label class="inline-flex items-center">
                                                <input type="checkbox" value="MO" class="day-checkbox rounded text-indigo-600">
                                                <span class="ml-1 text-sm">Mon</span>
                                            </label>
                                            <label class="inline-flex items-center">
                                                <input type="checkbox" value="TU" class="day-checkbox rounded text-indigo-600">
                                                <span class="ml-1 text-sm">Tue</span>
                                            </label>
                                            <label class="inline-flex items-center">
                                                <input type="checkbox" value="WE" class="day-checkbox rounded text-indigo-600">
                                                <span class="ml-1 text-sm">Wed</span>
                                            </label>
                                            <label class="inline-flex items-center">
                                                <input type="checkbox" value="TH" class="day-checkbox rounded text-indigo-600">
                                                <span class="ml-1 text-sm">Thu</span>
                                            </label>
                                            <label class="inline-flex items-center">
                                                <input type="checkbox" value="FR" class="day-checkbox rounded text-indigo-600">
                                                <span class="ml-1 text-sm">Fri</span>
                                            </label>
                                            <label class="inline-flex items-center">
                                                <input type="checkbox" value="SA" class="day-checkbox rounded text-indigo-600">
                                                <span class="ml-1 text-sm">Sat</span>
                                            </label>
                                        </div>
                                    </div>

                                    <div>
                                        <label class="block text-sm font-medium text-gray-700 mb-2">Ends</label>
                                        <div class="space-y-2">
                                            <label class="flex items-center gap-2">
                                                <input type="radio" name="recurrenceEnd" value="never" checked class="text-indigo-600">
                                                <span class="text-sm">Never</span>
                                            </label>
                                            <label class="flex items-center gap-2">
                                                <input type="radio" name="recurrenceEnd" value="until" class="text-indigo-600">
                                                <span class="text-sm">On date:</span>
                                                <input type="date" id="recurrenceUntil"
                                                    class="rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 border p-1 text-sm">
                                            </label>
                                            <label class="flex items-center gap-2">
                                                <input type="radio" name="recurrenceEnd" value="count" class="text-indigo-600">
                                                <span class="text-sm">After</span>
                                                <input type="number" id="recurrenceCount" value="10" min="1" max="100"
                                                    class="w-16 rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 border p-1 text-sm">
                                                <span class="text-sm">occurrences</span>
                                            </label>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="flex gap-2">
                                <button type="submit" id="submit-practice-btn"
                                    class="flex-1 bg-green-600 text-white py-2 px-4 rounded-md hover:bg-green-700 transition">Add Practice</button>
                                <button type="button" id="cancel-edit-practice-btn"
                                    class="hidden px-4 py-2 bg-gray-500 text-white rounded-md hover:bg-gray-600 transition">Cancel</button>
                            </div>
                        </form>
                    </div>

                    <!-- Bulk AI Update Tab Content -->
                    <div id="content-bulk-ai" class="p-6 hidden">
                        <div class="flex items-start justify-between gap-3 mb-2">
                            <div>
                                <h2 class="text-xl font-bold">Bulk AI Update</h2>
                                <p class="text-sm text-gray-600">Upload an image (and add text hints), or skip the image and just paste raw schedule text. Short instructions help steer the results.</p>
                            </div>
                            <span class="text-xs text-gray-500 bg-gray-100 px-2 py-1 rounded">Image optional</span>
                        </div>

                        <div class="space-y-5">
                            <div class="bg-gray-50 border border-gray-200 rounded-lg p-4 space-y-3">
                                <div>
                                    <label class="block text-sm font-semibold text-gray-800 mb-1">
                                        Upload schedule image (optional)
                                    </label>
                                    <p class="text-xs text-gray-600 mb-2">Screenshot or photo of the schedule. You can still add text instructions below to guide the AI (e.g., ‚Äúonly home games‚Äù).</p>
                                    <input type="file" id="schedule-image-input" accept="image/*"
                                        class="w-full text-sm text-gray-700 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100">
                                    <div id="schedule-image-preview" class="hidden mt-3">
                                        <img id="schedule-image-preview-img" class="max-w-full h-auto rounded-lg border border-gray-300" alt="Schedule preview">
                                        <button type="button" id="remove-schedule-image" class="mt-2 text-sm text-red-600 hover:text-red-800">‚úï Remove image</button>
                                    </div>
                                </div>
                                <div>
                                    <label class="block text-sm font-semibold text-gray-800 mb-1">
                                        Paste schedule text (or use text-only)
                                    </label>
                                    <p class="text-xs text-gray-600 mb-2">Raw text works by itself, or alongside an image for extra context. Add a short instruction like ‚Äúonly home games‚Äù, ‚Äúignore scrimmages‚Äù, or ‚Äújust March dates‚Äù.</p>
                                    <textarea id="bulk-text-input" rows="5"
                                        class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:border-indigo-500 focus:ring-indigo-500 text-sm"
                                        placeholder="Example:&#10;Sat 11/15 8:30 AM | Home vs Wildcats | Main Field&#10;Tue 11/18 6:00 PM | Away @ Tigers | East Gym"></textarea>
                                </div>
                            </div>

                            <button id="process-ai-btn" type="button"
                                class="w-full bg-indigo-600 text-white py-2 px-4 rounded-md hover:bg-indigo-700 transition flex items-center justify-center gap-2">
                                <span>‚ú®</span>
                                <span>Process with AI</span>
                            </button>

                            <div id="ai-loading" class="hidden mt-4 text-sm text-indigo-600 flex items-center gap-2 justify-center">
                                <svg class="animate-spin h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                </svg>
                                Processing with AI...
                            </div>

                            <!-- Proposed Changes Preview -->
                            <div id="proposed-changes-section" class="hidden mt-6">
                                <div class="flex justify-between items-center mb-3">
                                    <h3 class="font-semibold text-gray-900">Proposed Changes</h3>
                                    <span id="changes-count" class="text-sm text-gray-600"></span>
                                </div>

                                <div id="proposed-changes-list" class="space-y-2 max-h-96 overflow-y-auto">
                                    <!-- Proposed changes will be rendered here -->
                                </div>

                                <div class="flex gap-2 mt-4">
                                    <button id="cancel-changes-btn" type="button"
                                        class="flex-1 px-4 py-2 border border-gray-300 rounded-md text-gray-700 hover:bg-gray-50">
                                        Cancel
                                    </button>
                                    <button id="apply-changes-btn" type="button"
                                        class="flex-1 bg-green-600 text-white px-4 py-2 rounded-md hover:bg-green-700">
                                        ‚úÖ Apply Changes
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Schedule List -->
            <div class="lg:col-span-2">
                <div class="bg-white rounded-lg shadow-md overflow-hidden">
                    <div class="p-6 border-b border-gray-200 flex justify-between items-center">
                        <h2 class="text-xl font-bold">Schedule</h2>
                        <div class="flex gap-4 items-center">
                            <label class="flex items-center gap-2 text-sm text-gray-600 cursor-pointer">
                                <input type="checkbox" id="show-practices" class="rounded text-indigo-600">
                                <span>Show Practices</span>
                            </label>
                            <span id="team-name-display" class="text-gray-500"></span>
                        </div>
                    </div>
                    <div class="px-6 py-3 border-b border-gray-100 bg-gray-50">
                        <div class="flex flex-wrap items-center gap-2">
                            <button data-schedule-filter="upcoming-all" class="schedule-filter-btn px-3 py-1.5 text-xs font-semibold rounded-full border border-indigo-200 bg-indigo-50 text-indigo-700">All Upcoming</button>
                            <button data-schedule-filter="upcoming-games" class="schedule-filter-btn px-3 py-1.5 text-xs font-semibold rounded-full border border-gray-200 bg-white text-gray-600 hover:bg-gray-100">Upcoming Games</button>
                            <button data-schedule-filter="upcoming-practices" class="schedule-filter-btn px-3 py-1.5 text-xs font-semibold rounded-full border border-gray-200 bg-white text-gray-600 hover:bg-gray-100">Upcoming Practices</button>
                            <button data-schedule-filter="past-all" class="schedule-filter-btn px-3 py-1.5 text-xs font-semibold rounded-full border border-gray-200 bg-white text-gray-600 hover:bg-gray-100">Past Events</button>
                        </div>
                    </div>
                    <div id="schedule-list" class="divide-y divide-gray-200">
                        <!-- Games -->
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- RSVP Detail Modal -->
    <div id="rsvp-modal" class="hidden fixed inset-0 z-50">
        <div class="absolute inset-0 bg-black/50" onclick="document.getElementById('rsvp-modal').classList.add('hidden')"></div>
        <div class="absolute inset-y-0 right-0 w-full max-w-md bg-white shadow-2xl overflow-y-auto">
            <div class="sticky top-0 bg-white border-b border-gray-200 px-6 py-4 flex items-center justify-between z-10">
                <h3 class="text-lg font-bold text-gray-900">RSVPs</h3>
                <button onclick="document.getElementById('rsvp-modal').classList.add('hidden')" class="text-gray-400 hover:text-gray-700">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
            <div id="rsvp-modal-content" class="px-6 py-5"></div>
        </div>
    </div>

    <div id="footer-container"></div>

    <!-- Track Calendar Event Modal -->
    <div id="track-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-white rounded-lg p-6 max-w-md w-full mx-4">
            <h3 class="text-xl font-bold mb-4">Track This Game</h3>
            <div id="track-event-details" class="mb-4 text-sm text-gray-600">
                <!-- Event details will be shown here -->
            </div>
            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Opponent Name</label>
                <input type="text" id="track-opponent-input" class="w-full px-3 py-2 border border-gray-300 rounded">
            </div>
            <div class="flex gap-2 justify-end">
                <button id="cancel-track-btn"
                    class="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600">Cancel</button>
                <button id="confirm-track-btn"
                    class="px-4 py-2 bg-indigo-600 text-white rounded hover:bg-indigo-700">Track Game</button>
            </div>
        </div>
    </div>

    <!-- Basketball Tracker Choice Modal -->
    <div id="basketball-tracker-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-white rounded-lg p-6 max-w-sm w-full mx-4">
            <h3 class="text-xl font-bold mb-2">Choose Tracker</h3>
            <p class="text-sm text-gray-600 mb-4">This game uses a Basketball stat config. Which tracker do you want?</p>
            <div class="space-y-2">
                <button id="basketball-tracker-standard"
                    class="w-full px-4 py-3 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition font-semibold">
                    Standard
                </button>
                <button id="basketball-tracker-beta"
                    class="w-full px-4 py-3 bg-gray-100 text-gray-800 rounded-lg hover:bg-gray-200 transition font-semibold">
                    Beta
                </button>
                <button id="basketball-tracker-live"
                    class="w-full px-4 py-3 bg-red-600 text-white rounded-lg hover:bg-red-700 transition font-semibold flex items-center justify-center gap-2">
                    <span class="inline-flex items-center gap-1 bg-white/20 text-white text-[10px] font-bold px-2 py-0.5 rounded-full">
                        <span class="w-1.5 h-1.5 bg-white rounded-full animate-pulse"></span>
                        LIVE
                    </span>
                    Live Broadcast Tracker
                </button>
                <button id="basketball-tracker-photo"
                    class="w-full px-4 py-3 bg-amber-100 text-amber-800 rounded-lg hover:bg-amber-200 transition font-semibold">
                    Photo Score Sheet
                </button>
            </div>
            <div class="flex justify-end mt-4">
                <button id="basketball-tracker-cancel" class="px-4 py-2 text-gray-600 hover:text-gray-800">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Occurrence Choice Modal (Phase 2) -->
    <div id="occurrence-choice-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-white rounded-lg p-6 max-w-md w-full mx-4">
            <h3 class="text-xl font-bold mb-2">Manage Recurring Practice</h3>
            <p class="text-sm text-gray-600 mb-4">
                Select what to change for <span id="occurrence-choice-date" class="font-semibold text-gray-800"></span>.
            </p>
            <div class="space-y-2">
                <button id="edit-this-occurrence-btn"
                    class="w-full px-4 py-3 text-left bg-gray-50 hover:bg-gray-100 rounded-lg border border-gray-200 transition">
                    <span class="font-medium">Edit this date</span>
                    <p class="text-sm text-gray-500">Change only this occurrence</p>
                </button>
                <button id="edit-series-btn"
                    class="w-full px-4 py-3 text-left bg-gray-50 hover:bg-gray-100 rounded-lg border border-gray-200 transition">
                    <span class="font-medium">Edit entire series</span>
                    <p class="text-sm text-gray-500">Update all future dates</p>
                </button>
                <button id="cancel-this-occurrence-btn"
                    class="w-full px-4 py-3 text-left bg-amber-50 hover:bg-amber-100 rounded-lg border border-amber-200 transition">
                    <span class="font-medium text-amber-800">Cancel this date</span>
                    <p class="text-sm text-amber-600">Skip this occurrence only</p>
                </button>
                <button id="delete-series-btn"
                    class="w-full px-4 py-3 text-left bg-red-50 hover:bg-red-100 rounded-lg border border-red-200 transition">
                    <span class="font-medium text-red-700">Cancel entire series</span>
                    <p class="text-sm text-red-500">Remove all occurrences</p>
                </button>
            </div>
            <div class="flex justify-end mt-4">
                <button id="close-occurrence-choice-btn"
                    class="px-4 py-2 text-gray-600 hover:text-gray-800">Close</button>
            </div>
        </div>
    </div>

    <!-- Edit Single Occurrence Modal (Phase 2) -->
    <div id="edit-occurrence-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-white rounded-lg p-6 max-w-md w-full mx-4">
            <h3 class="text-xl font-bold mb-2">Edit Practice</h3>
            <p class="text-sm text-gray-600 mb-4">
                Editing <span id="occurrence-date-display" class="font-semibold"></span> only.
                Other occurrences will not be affected.
            </p>

            <form id="edit-occurrence-form" class="space-y-4">
                <input type="hidden" id="occurrence-master-id">
                <input type="hidden" id="occurrence-iso-date">

                <div>
                    <label class="block text-sm font-medium text-gray-700">Title</label>
                    <input type="text" id="occurrence-title"
                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 border p-2">
                </div>

                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <label class="block text-sm font-medium text-gray-700">Start Time</label>
                        <input type="time" id="occurrence-start-time"
                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 border p-2">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700">End Time</label>
                        <input type="time" id="occurrence-end-time"
                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 border p-2">
                    </div>
                </div>

                <div>
                    <label class="block text-sm font-medium text-gray-700">Location</label>
                    <input type="text" id="occurrence-location"
                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 border p-2">
                </div>

                <div>
                    <label class="block text-sm font-medium text-gray-700">Notes</label>
                    <textarea id="occurrence-notes" rows="2"
                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 border p-2"></textarea>
                </div>

                <div class="flex gap-2 justify-end pt-2">
                    <button type="button" id="cancel-occurrence-edit-btn"
                        class="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600">Cancel</button>
                    <button type="button" id="revert-occurrence-btn"
                        class="px-4 py-2 border border-gray-300 text-gray-700 rounded hover:bg-gray-50">Revert to Series</button>
                    <button type="submit"
                        class="px-4 py-2 bg-indigo-600 text-white rounded hover:bg-indigo-700">Save</button>
                </div>
            </form>
        </div>
    </div>

    <script type="module">
        import { getTeam, getTeams, getGames, getEvents, addGame, updateGame, deleteGame, addPractice, updateEvent, deleteEvent, getConfigs, addCalendarToTeam, removeCalendarFromTeam, getTrackedCalendarEventUids, cancelOccurrence, updateOccurrence, restoreOccurrence, clearOccurrenceOverride, updateSeries, deleteSeries, getUnreadChatCount, getPracticeSessions, cancelGame, getLatestGameAssignments, postChatMessage, getRsvpBreakdownByPlayer } from './js/db.js?v=20';
        import { renderHeader, renderFooter, getUrlParams, formatDate, formatShortDate, formatTime, formatTimeRange, getDefaultEndTime, fetchAndParseCalendar, extractOpponent, isPracticeEvent, generateSeriesId, expandRecurrence, formatRecurrence, shareOrCopy, escapeHtml } from './js/utils.js?v=8';
        import { checkAuth } from './js/auth.js?v=9';
        import { renderTeamAdminBanner } from './js/team-admin-banner.js';
        import { Timestamp } from "./js/firebase.js?v=9";
        import { getApp } from './js/vendor/firebase-app.js';
        import { getAI, getGenerativeModel, GoogleAIBackend, Schema } from './js/vendor/firebase-ai.js';

        renderFooter(document.getElementById('footer-container'));

        let currentTeamId = null;
        let currentUser = null;
        let showPractices = false;
        let scheduleViewFilter = 'upcoming-all';
        let selectedCalendarEvent = null;
        let allConfigs = [];
        let practicePlansByEventId = {};
        let editingPracticeId = null; // For editing existing practice
        let editingSeriesId = null; // For editing existing recurring series
        let editingOccurrence = null; // { masterId, isoDate, master } for recurring practice editing
        let seriesMasters = {}; // Cache of series master docs by id
        let allTeamsCache = null;
        let selectedOpponentTeam = null;

        const opponentInput = document.getElementById('opponent');
        const opponentResults = document.getElementById('opponent-search-results');
        const linkedOpponentChip = document.getElementById('linked-opponent-chip');
        const linkedOpponentName = document.getElementById('linked-opponent-name');
        const clearLinkedOpponentBtn = document.getElementById('clear-linked-opponent');

        function mapLink(locationText) {
            if (!locationText) return null;
            return `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(locationText)}`;
        }

        async function ensureTeamsCache() {
            if (allTeamsCache) return;
            const teams = await getTeams();
            allTeamsCache = (teams || []).filter(team => team.id !== currentTeamId);
        }

        function setLinkedOpponent(team) {
            selectedOpponentTeam = team || null;
            if (selectedOpponentTeam) {
                linkedOpponentName.textContent = selectedOpponentTeam.name || '';
                linkedOpponentChip.classList.remove('hidden');
                if (selectedOpponentTeam.name) {
                    opponentInput.value = selectedOpponentTeam.name;
                }
            } else {
                linkedOpponentName.textContent = '';
                linkedOpponentChip.classList.add('hidden');
            }
        }

        function clearLinkedOpponent() {
            selectedOpponentTeam = null;
            linkedOpponentName.textContent = '';
            linkedOpponentChip.classList.add('hidden');
        }

        function renderOpponentResults(matches, term) {
            if (!matches.length) {
                opponentResults.innerHTML = `
                    <div class="px-3 py-2 text-gray-500">No teams found. Keep typing to add manually.</div>
                `;
            } else {
                opponentResults.innerHTML = matches.map(team => `
                    <button type="button" class="w-full text-left px-3 py-2 hover:bg-indigo-50 flex items-center gap-2" data-team-id="${team.id}">
                        ${team.photoUrl ? `<img src="${team.photoUrl}" alt="" class="w-6 h-6 rounded-full object-cover">` : `<div class="w-6 h-6 rounded-full bg-indigo-100 text-indigo-600 text-xs flex items-center justify-center font-semibold">${(team.name || '?')[0]}</div>`}
                        <div>
                            <div class="font-medium text-gray-900">${team.name || 'Unnamed Team'}</div>
                            <div class="text-xs text-gray-500">${team.sport || 'Sport not set'}</div>
                        </div>
                    </button>
                `).join('');
            }
            opponentResults.classList.remove('hidden');
            opponentResults.querySelectorAll('[data-team-id]').forEach(btn => {
                btn.addEventListener('click', () => {
                    const team = (matches || []).find(t => t.id === btn.dataset.teamId);
                    if (team) {
                        setLinkedOpponent(team);
                        opponentResults.classList.add('hidden');
                    }
                });
            });
        }

        checkAuth((user) => {
            if (!user) {
                window.location.href = 'login.html';
                return;
            }
            currentUser = user;
            renderHeader(document.getElementById('header-container'), user);
            init();
        }, { skipEmailVerificationCheck: true });

        let currentTeam = null;
        function hasAccess(team, user) {
            if (!team || !user) return false;
            if (team.ownerId === user.uid) return true;
            if (user.isAdmin) return true;
            const email = (user.email || '').toLowerCase();
            return (team.adminEmails || []).map(e => e.toLowerCase()).includes(email);
        }

        async function init() {
            const { teamId } = getUrlParams();
            if (!teamId) {
                window.location.href = 'dashboard.html';
                return;
            }
            currentTeamId = teamId;
            document.getElementById('config-link').href = `edit-config.html#teamId=${teamId}`;

            const team = await getTeam(teamId);
            if (!hasAccess(team, currentUser)) {
                alert("Team not found or access denied.");
                window.location.href = 'dashboard.html';
                return;
            }

            currentTeam = team;
            setupOpponentSearch();
            document.getElementById('team-name-display').textContent = team.name;

            // Fetch unread count and render banner
            let unreadCount = 0;
            try {
                unreadCount = await getUnreadChatCount(currentUser.uid, teamId);
            } catch (e) {
                console.warn('Failed to get unread count:', e);
            }
            renderTeamAdminBanner(document.getElementById('team-admin-banner'), { team, teamId, active: 'schedule', unreadCount });

            // Respect persisted checkbox state on reloads
            const practiceToggle = document.getElementById('show-practices');
            showPractices = practiceToggle?.checked || false;

            loadConfigs();
            renderCalendarManagement();
            loadSchedule();
        }

        function setupOpponentSearch() {
            if (!opponentInput || !opponentResults) return;

            opponentInput.addEventListener('input', async () => {
                const term = opponentInput.value.trim();
                if (selectedOpponentTeam && term.toLowerCase() !== (selectedOpponentTeam.name || '').toLowerCase()) {
                    clearLinkedOpponent();
                }
                if (!term) {
                    opponentResults.classList.add('hidden');
                    return;
                }
                await ensureTeamsCache();
                const matches = allTeamsCache
                    .filter(team => (team.name || '').toLowerCase().includes(term.toLowerCase()))
                    .slice(0, 6);
                renderOpponentResults(matches, term);
            });

            opponentInput.addEventListener('focus', () => {
                if (opponentResults.innerHTML.trim()) {
                    opponentResults.classList.remove('hidden');
                }
            });

            opponentInput.addEventListener('blur', () => {
                setTimeout(() => opponentResults.classList.add('hidden'), 150);
            });

            if (clearLinkedOpponentBtn) {
                clearLinkedOpponentBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    clearLinkedOpponent();
                });
            }
        }

        async function loadConfigs() {
            allConfigs = await getConfigs(currentTeamId);
            console.log('Loaded configs:', allConfigs);
            const select = document.getElementById('statConfig');

            // Find the default config based on team sport
            let defaultConfigId = null;
            if (currentTeam && currentTeam.sport) {
                const sportLower = currentTeam.sport.toLowerCase();
                console.log('Team sport:', currentTeam.sport, 'lowercase:', sportLower);
                const defaultConfigName = sportLower === 'basketball' ? 'Basketball Standard' :
                    sportLower === 'soccer' ? 'Soccer Standard' : null;
                console.log('Looking for default config:', defaultConfigName);

                if (defaultConfigName) {
                    // Use the configs we just fetched; avoid crashing when defaults are missing
                    const defaultConfig = allConfigs.find(c => c.name === defaultConfigName);
                    console.log('Found default config:', defaultConfig);
                    if (defaultConfig) {
                        defaultConfigId = defaultConfig.id;
                    }
                }
            }

            allConfigs.forEach(config => {
                console.log('Adding config option:', config.name, 'columns:', config.columns);
                const option = document.createElement('option');
                option.value = config.id;
                option.textContent = config.name;
                if (config.id === defaultConfigId) {
                    option.selected = true;
                    console.log('Auto-selected config:', config.name);
                }
                select.appendChild(option);
            });
        }

        function renderCalendarManagement() {
            const calendarList = document.getElementById('calendar-list');
            const calendarUrls = currentTeam.calendarUrls || [];

            if (calendarUrls.length === 0) {
                calendarList.innerHTML = '<p class="text-sm text-gray-600 italic">No calendars added yet.</p>';
            } else {
                calendarList.innerHTML = calendarUrls.map((url) => `
                    <div class="flex items-center justify-between bg-white p-2 rounded border border-gray-200">
                        <span class="text-sm text-gray-700 truncate flex-grow mr-2">${url}</span>
                        <button onclick="window.removeCalendar('${url}')" class="text-red-600 hover:text-red-800 text-sm">
                            üóëÔ∏è
                        </button>
                    </div>
                `).join('');
            }
        }

        async function loadSchedule() {
            // Get all events (games and practices) from DB
            const dbEvents = await getEvents(currentTeamId);
            const practiceSessions = await getPracticeSessions(currentTeamId);
            practicePlansByEventId = {};
            (practiceSessions || []).forEach(session => {
                if (session.eventId) practicePlansByEventId[session.eventId] = session;
            });
            const container = document.getElementById('schedule-list');
            let allEvents = [];
            // Reset series master cache for this load
            seriesMasters = {};

            // Get tracked calendar event UIDs
            const trackedUids = await getTrackedCalendarEventUids(currentTeamId);

            // Fetch calendar events
            if (currentTeam.calendarUrls && currentTeam.calendarUrls.length > 0) {
                for (const calendarUrl of currentTeam.calendarUrls) {
                    try {
                        const calendarEvents = await fetchAndParseCalendar(calendarUrl);

                        calendarEvents.forEach(event => {
                            // Skip if already tracked
                            if (trackedUids.includes(event.uid)) return;

                            // Check if event is cancelled (standard iCal STATUS or TeamSnap [CANCELED] prefix)
                            const isCancelled = event.status?.toUpperCase() === 'CANCELLED' ||
                                event.summary?.includes('[CANCELED]');

                            // Skip if conflicts with DB event
                            const hasConflict = dbEvents.some(dbEvent => {
                                const dbDate = dbEvent.date?.toDate ? dbEvent.date.toDate() : new Date(dbEvent.date);
                                const eventDate = event.dtstart;
                                return Math.abs(dbDate - eventDate) < 60000;
                            });
                            if (hasConflict) return;

                            const isPractice = isPracticeEvent(event.summary);
                            // Clean [CANCELED] prefix from summary before extracting opponent
                            const cleanSummary = event.summary?.replace(/\[CANCELED\]\s*/gi, '') || '';
                            const opponent = extractOpponent(cleanSummary, currentTeam.name);

                            allEvents.push({
                                source: 'calendar',
                                eventType: isPractice ? 'practice' : 'game',
                                date: event.dtstart,
                                opponent: opponent,
                                location: event.location || 'TBD',
                                isPractice: isPractice,
                                isCancelled: isCancelled,
                                calendarEvent: event
                            });
                        });
                    } catch (error) {
                        console.error('Error fetching calendar:', calendarUrl, error);
                    }
                }
            }

            // Add DB events (games and practices), expanding recurring series
            dbEvents.forEach(event => {
                // Cache series masters for later lookup
                if (event.isSeriesMaster) {
                    seriesMasters[event.id] = event;
                }

                // Expand recurring practices into individual occurrences
                if (event.isSeriesMaster && event.recurrence) {
                    const occurrences = expandRecurrence(event);
                    occurrences.forEach(occ => {
                        const occDate = occ.date?.toDate ? occ.date.toDate() : new Date(occ.date);
                        allEvents.push({
                            source: 'db',
                            eventType: 'practice',
                            date: occDate,
                            end: occ.end,
                            title: occ.title,
                            location: occ.location || 'TBD',
                            notes: occ.notes,
                            isPractice: true,
                            isRecurring: true,
                            isInstance: occ.isInstance,
                            isModified: occ.isModified,
                            instanceDate: occ.instanceDate,
                            masterId: occ.masterId,
                            master: event, // Keep reference to master for editing
                            id: event.id,
                            startTime: occ.startTime,
                            endTime: occ.endTime
                        });
                    });
                } else {
                    // Single event (game or practice)
                    const eventDate = event.date?.toDate ? event.date.toDate() : new Date(event.date);
                    const eventType = event.type || 'game';
                    allEvents.push({
                        source: 'db',
                        eventType: eventType,
                        date: eventDate,
                        end: event.end,
                        opponent: event.opponent,
                        opponentTeamId: event.opponentTeamId || null,
                        opponentTeamName: event.opponentTeamName || null,
                        opponentTeamPhoto: event.opponentTeamPhoto || null,
                        title: event.title,
                        location: event.location || 'TBD',
                        notes: event.notes,
                        status: event.status,
                        homeScore: event.homeScore,
                        awayScore: event.awayScore,
                            id: event.id,
                            eventId: event.id,
                            isPractice: eventType === 'practice',
                            isRecurring: false
                        });
                }
            });

            // Sort by date
            allEvents.sort((a, b) => a.date - b.date);

            const hiddenPracticeCount = allEvents.filter(event => event.isPractice).length;
            console.log('Aggregated events', { total: allEvents.length, hiddenPracticeCount, showPractices });

            const now = new Date();

            // Filter by practice checkbox + schedule view
            const forcePracticeVisibility = scheduleViewFilter === 'upcoming-practices';
            let filteredEvents = allEvents.filter(event => {
                if (event.isPractice && !showPractices && !forcePracticeVisibility) return false;
                return true;
            });
            if (scheduleViewFilter === 'upcoming-all') {
                filteredEvents = filteredEvents.filter(event => event.date >= now);
                filteredEvents.sort((a, b) => a.date - b.date);
            } else if (scheduleViewFilter === 'upcoming-games') {
                filteredEvents = filteredEvents.filter(event => !event.isPractice && event.date >= now);
                filteredEvents.sort((a, b) => a.date - b.date);
            } else if (scheduleViewFilter === 'upcoming-practices') {
                filteredEvents = filteredEvents.filter(event => event.isPractice && event.date >= now);
                filteredEvents.sort((a, b) => a.date - b.date);
            } else if (scheduleViewFilter === 'past-all') {
                filteredEvents = filteredEvents.filter(event => event.date < now);
                filteredEvents.sort((a, b) => b.date - a.date);
            }

            const practiceNotice = (!showPractices && !forcePracticeVisibility && hiddenPracticeCount > 0)
                ? `<div class="p-4 bg-yellow-50 text-yellow-800 text-sm border-b border-yellow-200">
                        ${hiddenPracticeCount} practice event${hiddenPracticeCount === 1 ? ' is' : 's are'} hidden. Toggle "Show Practices" to view them.
                   </div>`
                : '';

            if (filteredEvents.length === 0) {
                container.innerHTML = practiceNotice + '<div class="p-6 text-center text-gray-500">No events scheduled.</div>';
                return;
            }

            const nextUpcomingIndex = filteredEvents.findIndex(event => event.date >= now);
            container.innerHTML = practiceNotice + filteredEvents.map((event, index) => {
                const cardHtml = (() => {
                if (event.source === 'calendar') {
                    return renderCalendarEvent(event);
                } else if (event.eventType === 'practice') {
                    return renderPractice(event);
                } else {
                    return renderDbGame(event);
                }
                })();
                const nextMarker = index === nextUpcomingIndex
                    ? '<div class="px-6 py-2 bg-indigo-50 border-y border-indigo-100 text-xs font-semibold text-indigo-700 uppercase tracking-wide">Next Up</div>'
                    : '';
                return `${nextMarker}<div data-schedule-row="${index}" ${index === nextUpcomingIndex ? 'data-next-up="true"' : ''}>${cardHtml}</div>`;
            }).join('');

            // Auto-scroll to the next upcoming event when in upcoming-focused filters.
            if (scheduleViewFilter.startsWith('upcoming')) {
                const nextEl = container.querySelector('[data-next-up="true"]');
                if (nextEl) {
                    requestAnimationFrame(() => {
                        nextEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    });
                }
            }

            // Attach delete button handlers for games
            document.querySelectorAll('.delete-btn').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    if (confirm('Are you sure you want to delete this game?')) {
                        await deleteGame(currentTeamId, e.target.dataset.id);
                        loadSchedule();
                    }
                });
            });

            // Attach edit button handlers for games
            document.querySelectorAll('.edit-game-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const gameId = e.target.dataset.gameId;
                    startEditGame(gameId);
                });
            });

            // Attach track button handlers for games (basketball chooser modal)
            document.querySelectorAll('.track-game-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const gameId = e.target.dataset.gameId;
                    handleTrackClick(gameId);
                });
            });

            // Attach cancel game button handlers
            document.querySelectorAll('.cancel-game-btn').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    const gameId = e.target.dataset.gameId;
                    const game = gamesCache[gameId];
                    if (!game) return;
                    if (!confirm(`Cancel the game vs. ${game.opponent}? This will notify the team via chat.`)) return;
                    try {
                        await cancelGame(currentTeamId, gameId, currentUser.uid);
                        // Post cancellation to team chat
                        const gameDate = game.date?.toDate ? game.date.toDate() : new Date(game.date);
                        const dateStr = gameDate.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });
                        await postChatMessage(currentTeamId, {
                            text: `‚ö†Ô∏è Game cancelled: vs. ${game.opponent} on ${dateStr}`,
                            senderId: currentUser.uid,
                            senderName: currentUser.displayName || currentUser.email,
                            senderEmail: currentUser.email
                        });
                        loadSchedule();
                    } catch (err) {
                        console.error('Failed to cancel game:', err);
                        alert('Error cancelling game: ' + err.message);
                    }
                });
            });

            // Attach RSVP view button handlers
            document.querySelectorAll('.view-rsvps-btn').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    const gameId = e.target.dataset.gameId;
                    const modal = document.getElementById('rsvp-modal');
                    const content = document.getElementById('rsvp-modal-content');
                    content.innerHTML = '<div class="text-center py-8"><div class="animate-spin rounded-full h-8 w-8 border-b-2 border-indigo-600 mx-auto"></div></div>';
                    modal.classList.remove('hidden');
                    try {
                        const breakdown = await getRsvpBreakdownByPlayer(currentTeamId, gameId);
                        const grouped = breakdown.grouped;
                        const counts = breakdown.counts;
                        const renderRows = (rows) => rows.length
                            ? rows.map((row) => {
                                const name = escapeHtml(row.playerName || 'Unknown Player');
                                const jersey = row.playerNumber ? ` <span class="text-gray-400 text-xs">#${escapeHtml(row.playerNumber)}</span>` : '';
                                const note = row.note ? ` <span class="text-gray-400 text-xs">- ${escapeHtml(row.note)}</span>` : '';
                                return `<div class="text-sm py-1">${name}${jersey}${note}</div>`;
                            }).join('')
                            : '<p class="text-xs text-gray-400">None</p>';
                        content.innerHTML = `
                            <div class="space-y-4">
                                <div>
                                    <h4 class="text-sm font-bold text-green-700 mb-2">Going (${counts.going})</h4>
                                    ${renderRows(grouped.going)}
                                </div>
                                <div>
                                    <h4 class="text-sm font-bold text-yellow-700 mb-2">Maybe (${counts.maybe})</h4>
                                    ${renderRows(grouped.maybe)}
                                </div>
                                <div>
                                    <h4 class="text-sm font-bold text-red-700 mb-2">Can't Go (${counts.notGoing})</h4>
                                    ${renderRows(grouped.not_going)}
                                </div>
                                <div>
                                    <h4 class="text-sm font-bold text-gray-700 mb-2">Not Responded (${counts.notResponded})</h4>
                                    ${renderRows(grouped.not_responded)}
                                </div>
                            </div>
                        `;
                    } catch (err) {
                        content.innerHTML = `<p class="text-red-600 text-center py-8">Error loading RSVPs: ${err.message}</p>`;
                    }
                });
            });
        }

        // Render practice events (single or recurring instance)
        function renderPractice(practice) {
            const timeDisplay = practice.startTime && practice.endTime
                ? `${practice.startTime} - ${practice.endTime}`
                : formatTimeRange(practice.date, practice.end);

            // Build badge HTML
            let badges = '<span class="text-xs bg-green-100 text-green-800 px-2 py-0.5 rounded font-semibold">Practice</span>';
            if (practice.isRecurring) {
                badges += ' <span class="text-xs bg-purple-100 text-purple-800 px-2 py-0.5 rounded font-semibold">Recurring</span>';
            }
            if (practice.isModified) {
                badges += ' <span class="text-xs bg-yellow-100 text-yellow-800 px-2 py-0.5 rounded font-semibold">Modified</span>';
            }

            // Build action buttons
            let actions = '';
            const practicePlanEventId = practice.isInstance
                ? `${practice.masterId}__${practice.instanceDate}`
                : (practice.eventId || practice.id);
            const planSummary = renderPracticePlanSummary(practicePlanEventId);
            const planHref = buildPracticePlanHref({
                eventId: practicePlanEventId,
                date: practice.date,
                end: practice.end,
                location: practice.location,
                title: practice.title || 'Practice'
            });
            if (practice.isInstance) {
                // Recurring occurrence - edit opens occurrence choice modal
                actions = `
                    <a href="${planHref}"
                        class="px-3 py-1 bg-indigo-100 text-indigo-700 rounded text-sm hover:bg-indigo-200">Plan Practice</a>
                    <button data-game-id="${practice.masterId}" class="view-rsvps-btn px-3 py-1 bg-green-100 text-green-700 rounded text-sm hover:bg-green-200">Availability</button>
                    <button onclick="editOccurrence('${practice.masterId}', '${practice.instanceDate}')"
                        class="px-3 py-1 bg-blue-100 text-blue-700 rounded text-sm hover:bg-blue-200">Manage</button>
                `;
            } else {
                // Single practice
                actions = `
                    <a href="${planHref}"
                        class="px-3 py-1 bg-indigo-100 text-indigo-700 rounded text-sm hover:bg-indigo-200">Plan Practice</a>
                    <button data-game-id="${practice.eventId}" class="view-rsvps-btn px-3 py-1 bg-green-100 text-green-700 rounded text-sm hover:bg-green-200">Availability</button>
                    <button onclick="editPractice('${practice.eventId}')"
                        class="px-3 py-1 bg-blue-100 text-blue-700 rounded text-sm hover:bg-blue-200">Edit</button>
                    <button onclick="deletePractice('${practice.eventId}')"
                        class="px-3 py-1 border border-red-300 text-red-600 rounded text-sm hover:bg-red-50">Delete</button>
                `;
            }

            return `
                <div class="p-6 hover:bg-gray-50 flex flex-col md:flex-row justify-between items-start md:items-center gap-4 border-l-4 border-green-500">
                    <div>
                        <div class="flex items-center gap-2 mb-1">
                            ${badges}
                        </div>
                        <div class="text-sm text-gray-500 font-semibold uppercase tracking-wide mb-1">${formatDate(practice.date)} ‚Ä¢ ${timeDisplay || formatTime(practice.date)}</div>
                        <div class="text-lg font-bold text-gray-900">${practice.title || 'Practice'}</div>
                        <div class="text-sm text-gray-600">
                            ${mapLink(practice.location) ? `<a class="text-indigo-600 hover:underline" target="_blank" rel="noopener noreferrer" href="${mapLink(practice.location)}">${practice.location || 'TBD'}</a>` : (practice.location || 'TBD')}
                        </div>
                        ${practice.notes ? `<div class="text-sm text-gray-500 mt-1">${practice.notes}</div>` : ''}
                        ${planSummary}
                    </div>
                    <div class="flex space-x-2">
                        ${actions}
                    </div>
                </div>
            `;
        }

        function renderCalendarEvent(event) {
            const isPractice = event.isPractice;
            const isCancelled = event.isCancelled;
            const borderColor = isCancelled ? 'border-gray-400' : (isPractice ? 'border-yellow-500' : 'border-blue-500');
            const calendarPracticeEventId = event.calendarEvent?.id || event.calendarEvent?.uid || `calendar_${event.date?.toISOString?.() || Date.now()}`;
            const planSummary = isPractice ? renderPracticePlanSummary(calendarPracticeEventId) : '';
            const calendarPlanHref = buildPracticePlanHref({
                eventId: calendarPracticeEventId,
                date: event.date,
                end: event.end,
                location: event.location,
                title: event.opponent || 'Practice'
            });
            return `
                <div class="p-6 hover:bg-gray-50 flex flex-col md:flex-row justify-between items-start md:items-center gap-4 border-l-4 ${borderColor} ${isCancelled ? 'opacity-60' : ''}">
                    <div>
                        <div class="flex items-center gap-2 mb-1">
                            <span class="text-xs bg-blue-100 text-blue-800 px-2 py-0.5 rounded font-semibold">üìÖ Calendar</span>
                            ${isCancelled ? '<span class="text-xs bg-red-100 text-red-800 px-2 py-0.5 rounded font-semibold">Cancelled</span>' : ''}
                            ${isPractice ? '<span class="text-xs bg-yellow-100 text-yellow-800 px-2 py-0.5 rounded font-semibold">Practice</span>' : ''}
                        </div>
                        <div class="text-sm text-gray-500 font-semibold uppercase tracking-wide mb-1 ${isCancelled ? 'line-through' : ''}">${formatDate(event.date)} ‚Ä¢ ${formatTime(event.date)}</div>
                        <div class="text-lg font-bold text-gray-900 ${isCancelled ? 'line-through' : ''}">${isPractice ? event.opponent : `vs. ${event.opponent}`}</div>
                        <div class="text-sm text-gray-600">
                            ${mapLink(event.location) ? `<a class="text-indigo-600 hover:underline" target="_blank" rel="noopener noreferrer" href="${mapLink(event.location)}">${event.location || 'TBD'}</a>` : (event.location || 'TBD')}
                        </div>
                        ${planSummary}
                    </div>
                    ${!isCancelled ? `
                        <div class="flex space-x-2">
                            ${isPractice ? `
                                <a href="${calendarPlanHref}"
                                   class="px-3 py-1 bg-indigo-100 text-indigo-700 rounded text-sm hover:bg-indigo-200">
                                   Plan Practice
                                </a>
                            ` : `
                                <button onclick="window.trackCalendarEvent(${JSON.stringify(event.calendarEvent).replace(/"/g, '&quot;')})" class="px-3 py-1 bg-indigo-100 text-indigo-700 rounded text-sm hover:bg-indigo-200">
                                    Track
                                </button>
                            `}
                        </div>
                    ` : ''}
                </div>
            `;
        }

        function buildPracticePlanHref({ eventId, date, end, location, title }) {
            const normalizeDate = (value) => {
                if (!value) return null;
                if (value instanceof Date) return Number.isNaN(value.getTime()) ? null : value;
                if (typeof value?.toDate === 'function') {
                    const d = value.toDate();
                    return Number.isNaN(d?.getTime?.()) ? null : d;
                }
                const parsed = new Date(value);
                return Number.isNaN(parsed.getTime()) ? null : parsed;
            };

            const startDate = normalizeDate(date);
            const endDate = normalizeDate(end);
            const params = new URLSearchParams();
            params.set('teamId', currentTeamId);
            params.set('eventId', eventId || '');
            params.set('source', 'edit-schedule');
            if (startDate) {
                params.set('eventDate', startDate.toISOString().split('T')[0]);
            }
            if (startDate && endDate) {
                const durationMinutes = Math.max(15, Math.round((endDate.getTime() - startDate.getTime()) / 60000));
                params.set('eventDuration', String(durationMinutes));
            }
            if (location) params.set('eventLocation', location);
            if (title) params.set('eventTitle', title);
            return `drills.html#${params.toString()}`;
        }

        function renderPracticePlanSummary(eventId) {
            const session = practicePlansByEventId[eventId];
            if (!session) return '<div class="mt-2 text-xs text-gray-400">No linked practice plan yet</div>';
            const status = session.status || 'draft';
            const blocks = Array.isArray(session.blocks) ? session.blocks.length : 0;
            const duration = session.duration || 0;
            const statusClass = status === 'completed'
                ? 'bg-green-100 text-green-800'
                : status === 'active'
                    ? 'bg-blue-100 text-blue-800'
                    : 'bg-gray-100 text-gray-700';
            return `
                <div class="mt-2 flex flex-wrap items-center gap-2">
                    <span class="text-xs ${statusClass} px-2 py-0.5 rounded font-semibold uppercase">${status}</span>
                    <span class="text-xs bg-indigo-50 text-indigo-700 px-2 py-0.5 rounded font-semibold">Plan: ${blocks} block${blocks === 1 ? '' : 's'} ‚Ä¢ ${duration} min</span>
                </div>
            `;
        }

        let editingGameId = null;
        let gamesCache = {};
        let pendingTrackGameId = null;

        // Helper function to check if a stat config is for basketball
        function isBasketballConfig(configId) {
            if (configId) {
                const config = allConfigs.find(c => c.id === configId);
                if (config) {
                    return (config.baseType || '').toLowerCase() === 'basketball';
                }
            }
            // If no config, infer from team sport
            return (currentTeam?.sport || '').toLowerCase().includes('basketball');
        }

        function isBasketballForGame(game) {
            if (!game) return false;
            return isBasketballConfig(game.statTrackerConfigId);
        }

        function closeBasketballTrackerModal() {
            document.getElementById('basketball-tracker-modal')?.classList.add('hidden');
            pendingTrackGameId = null;
        }

        function handleTrackClick(gameId) {
            const game = gamesCache[gameId];
            if (!game) return;

            if (isBasketballForGame(game)) {
                pendingTrackGameId = gameId;
                document.getElementById('basketball-tracker-modal')?.classList.remove('hidden');
                return;
            }

            window.location.href = `track.html#teamId=${currentTeamId}&gameId=${gameId}`;
        }

        function renderDbGame(game) {
            const isCompleted = game.status === 'completed';
            // Cache game data for later retrieval
            gamesCache[game.id] = game;
            return `
                <div class="p-6 hover:bg-gray-50 flex flex-col md:flex-row justify-between items-start md:items-center gap-4">
                    <div>
                        <div class="text-sm text-gray-500 font-semibold uppercase tracking-wide mb-1">${formatDate(game.date)} ‚Ä¢ ${formatTime(game.date)}</div>
                        <div class="text-lg font-bold text-gray-900">vs. ${escapeHtml(game.opponent || 'TBD')}</div>
                        <div class="text-sm text-gray-600">
                            ${mapLink(game.location) ? `<a class="text-indigo-600 hover:underline" target="_blank" rel="noopener noreferrer" href="${mapLink(game.location)}">${escapeHtml(game.location || 'TBD')}</a>` : escapeHtml(game.location || 'TBD')}
                        </div>
                        <div class="flex flex-wrap gap-1 mt-1">
                            ${game.isHome === true ? '<span class="inline-block bg-blue-100 text-blue-800 text-xs px-2 py-0.5 rounded-full font-semibold">HOME</span>' : ''}
                            ${game.isHome === false ? '<span class="inline-block bg-gray-100 text-gray-700 text-xs px-2 py-0.5 rounded-full font-semibold">AWAY</span>' : ''}
                            ${game.kitColor ? `<span class="inline-block bg-purple-100 text-purple-800 text-xs px-2 py-0.5 rounded-full font-semibold">${escapeHtml(game.kitColor)}</span>` : ''}
                        </div>
                        ${game.arrivalTime ? `<div class="text-xs text-amber-700 mt-1">Arrive: ${formatTime(game.arrivalTime)}</div>` : ''}
                        ${game.notes ? `<div class="text-xs text-gray-500 mt-1 italic">${escapeHtml(game.notes)}</div>` : ''}
                        ${game.assignments && game.assignments.length > 0 ? `<div class="mt-1 text-xs text-gray-600">${game.assignments.map(a => `<span class="inline-block bg-gray-100 rounded px-1.5 py-0.5 mr-1 mb-1"><b>${escapeHtml(a.role)}:</b> ${escapeHtml(a.value || 'TBD')}</span>`).join('')}</div>` : ''}
                        ${isCompleted ? `<span class="inline-block bg-green-100 text-green-800 text-xs px-2 py-1 rounded-full font-semibold mt-2">Final: ${game.homeScore}-${game.awayScore}</span>` : ''}
                        ${game.status === 'cancelled' ? '<div class="mt-1"><span class="inline-block bg-red-100 text-red-800 text-xs px-2 py-1 rounded-full font-semibold">CANCELLED</span></div>' : ''}
                        ${game.rsvpSummary ? `<div class="text-xs text-gray-500 mt-1">${game.rsvpSummary.going || 0} going ¬∑ ${game.rsvpSummary.maybe || 0} maybe ¬∑ ${game.rsvpSummary.notGoing || 0} can't go ¬∑ ${game.rsvpSummary.notResponded || 0} no response</div>` : ''}
                    </div>
                    <div class="flex flex-wrap gap-2">
                        <button data-game-id="${game.id}" class="edit-game-btn px-3 py-1 bg-blue-100 text-blue-700 rounded text-sm hover:bg-blue-200">Edit</button>
                        ${!isCompleted ? `<button data-game-id="${game.id}" class="track-game-btn px-3 py-1 bg-indigo-100 text-indigo-700 rounded text-sm hover:bg-indigo-200">Track</button>` : ''}
                        ${!isCompleted ? `<a href="live-game.html?teamId=${currentTeamId}&gameId=${game.id}" class="px-3 py-1 ${game.liveStatus === 'live' ? 'bg-red-100 text-red-700 hover:bg-red-200' : 'bg-slate-100 text-slate-700 hover:bg-slate-200'} rounded text-sm">${game.liveStatus === 'live' ? 'Live Now' : 'View Live'}</a>` : ''}
                        ${!isCompleted ? `<button data-live-link="${game.id}" class="copy-live-link-btn px-3 py-1 bg-rose-100 text-rose-700 rounded text-sm hover:bg-rose-200">Share</button>` : ''}
                        ${isCompleted ? `<a href="game.html#teamId=${currentTeamId}&gameId=${game.id}" class="px-3 py-1 bg-green-100 text-green-700 rounded text-sm hover:bg-green-200">Report</a>` : ''}
                        ${game.liveStatus === 'completed' ? `<a href="live-game.html?teamId=${currentTeamId}&gameId=${game.id}&replay=true" class="px-3 py-1 bg-teal-100 text-teal-700 rounded text-sm hover:bg-teal-200">Watch Replay</a>` : ''}
                        <a href="game-plan.html#teamId=${currentTeamId}&gameId=${game.id}" class="px-3 py-1 bg-primary-100 text-primary-700 rounded text-sm hover:bg-primary-200">Game Plan</a>
                        <button data-game-id="${game.id}" class="view-rsvps-btn px-3 py-1 bg-green-100 text-green-700 rounded text-sm hover:bg-green-200">RSVPs</button>
                        ${game.status !== 'cancelled' ? `<button data-game-id="${game.id}" class="cancel-game-btn px-3 py-1 border border-orange-300 text-orange-600 rounded text-sm hover:bg-orange-50">Cancel</button>` : '<span class="px-3 py-1 bg-red-100 text-red-700 rounded text-sm font-semibold">Cancelled</span>'}
                        <button data-id="${game.id}" class="px-3 py-1 border border-red-300 text-red-600 rounded text-sm hover:bg-red-50 delete-btn">Delete</button>
                    </div>
                </div>
            `;
        }

        function startEditGame(gameId) {
            const game = gamesCache[gameId];
            if (!game) return;
            editingGameId = game.id;

            // Switch to Add Game tab
            switchTab('tab-add-game');

            // Populate form
            const date = game.date.toDate ? game.date.toDate() : new Date(game.date);
            // Format for datetime-local input: YYYY-MM-DDThh:mm
            const dateStr = new Date(date.getTime() - date.getTimezoneOffset() * 60000).toISOString().slice(0, 16);

            document.getElementById('gameDate').value = dateStr;
            document.getElementById('opponent').value = game.opponent || '';
            document.getElementById('location').value = game.location || '';
            document.getElementById('statConfig').value = game.statTrackerConfigId || '';
            if (game.opponentTeamId) {
                setLinkedOpponent({
                    id: game.opponentTeamId,
                    name: game.opponentTeamName || game.opponent || 'Opponent',
                    photoUrl: game.opponentTeamPhoto || '',
                    sport: game.opponentTeamSport || ''
                });
            } else {
                clearLinkedOpponent();
            }

            // Populate new fields
            setHomeAway(game.isHome === true ? 'home' : (game.isHome === false ? 'away' : null));
            document.getElementById('kitColor').value = game.kitColor || '';
            if (game.arrivalTime) {
                const at = game.arrivalTime.toDate ? game.arrivalTime.toDate() : new Date(game.arrivalTime);
                const atStr = new Date(at.getTime() - at.getTimezoneOffset() * 60000).toISOString().slice(0, 16);
                document.getElementById('arrivalTime').value = atStr;
            } else {
                document.getElementById('arrivalTime').value = '';
            }
            document.getElementById('gameNotes').value = game.notes || '';
            populateAssignments(game.assignments || []);

            // Update UI
            document.getElementById('submit-game-btn').textContent = 'Update Game';
            document.getElementById('cancel-edit-game-btn').classList.remove('hidden');

            // Scroll to form
            document.getElementById('add-game-form').scrollIntoView({ behavior: 'smooth' });
        };

        // ===== HOME/AWAY TOGGLE =====
        window.setHomeAway = function(val) {
            document.getElementById('isHome').value = val === null ? '' : val;
            document.getElementById('homeAwayHome').className = `flex-1 px-3 py-2 border rounded-md text-sm font-medium focus:outline-none transition ${val === 'home' ? 'border-indigo-600 bg-indigo-600 text-white' : 'border-gray-300 text-gray-700 hover:bg-indigo-50'}`;
            document.getElementById('homeAwayAway').className = `flex-1 px-3 py-2 border rounded-md text-sm font-medium focus:outline-none transition ${val === 'away' ? 'border-indigo-600 bg-indigo-600 text-white' : 'border-gray-300 text-gray-700 hover:bg-indigo-50'}`;
        };

        // ===== ASSIGNMENT ROWS =====
        function addAssignmentRow(role = '', value = '') {
            const container = document.getElementById('assignment-rows');
            const row = document.createElement('div');
            row.className = 'flex gap-2 items-center';
            row.innerHTML = `
                <input type="text" placeholder="Role (e.g. Snack)" value="${role}" class="assignment-role flex-1 rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 border p-2 text-sm">
                <input type="text" placeholder="Assigned to" value="${value}" class="assignment-value flex-1 rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 border p-2 text-sm">
                <button type="button" class="text-red-400 hover:text-red-600 text-lg font-bold" onclick="this.parentElement.remove()">&times;</button>
            `;
            container.appendChild(row);
        }

        document.getElementById('add-assignment-btn').addEventListener('click', () => addAssignmentRow());

        function getAssignmentsFromForm() {
            const rows = document.querySelectorAll('#assignment-rows .flex');
            const assignments = [];
            rows.forEach(row => {
                const role = row.querySelector('.assignment-role').value.trim();
                const value = row.querySelector('.assignment-value').value.trim();
                if (role) assignments.push({ role, value });
            });
            return assignments;
        }

        function populateAssignments(assignments) {
            const container = document.getElementById('assignment-rows');
            container.innerHTML = '';
            if (assignments && assignments.length > 0) {
                assignments.forEach(a => addAssignmentRow(a.role, a.value));
            }
        }

        function resetGameForm() {
            editingGameId = null;
            document.getElementById('add-game-form').reset();
            document.getElementById('submit-game-btn').textContent = 'Add Game';
            document.getElementById('cancel-edit-game-btn').classList.add('hidden');
            clearLinkedOpponent();
            setHomeAway(null);
            document.getElementById('kitColor').value = '';
            document.getElementById('arrivalTime').value = '';
            document.getElementById('gameNotes').value = '';
            document.getElementById('assignment-rows').innerHTML = '';
        }

        // Pre-populate assignments for new games from the latest game
        async function prefillAssignments() {
            if (editingGameId) return; // Don't prefill when editing
            try {
                const latest = await getLatestGameAssignments(currentTeamId);
                if (latest && latest.length > 0) {
                    populateAssignments(latest.map(a => ({ role: a.role, value: '' })));
                }
            } catch (e) {
                console.log('Could not prefill assignments:', e);
            }
        }

        document.getElementById('cancel-edit-game-btn').addEventListener('click', resetGameForm);

        document.getElementById('add-game-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            const dateVal = document.getElementById('gameDate').value;
            const opponent = document.getElementById('opponent').value;
            const location = document.getElementById('location').value;
            const configId = document.getElementById('statConfig').value;

            if (!dateVal) return;

            try {
                const isHomeVal = document.getElementById('isHome').value;
                const arrivalVal = document.getElementById('arrivalTime').value;
                const gameData = {
                    type: 'game',
                    date: Timestamp.fromDate(new Date(dateVal)),
                    opponent,
                    location,
                    statTrackerConfigId: configId || null,
                    opponentTeamId: selectedOpponentTeam ? selectedOpponentTeam.id : null,
                    opponentTeamName: selectedOpponentTeam ? selectedOpponentTeam.name || opponent : null,
                    opponentTeamPhoto: selectedOpponentTeam ? selectedOpponentTeam.photoUrl || null : null,
                    isHome: isHomeVal === 'home' ? true : (isHomeVal === 'away' ? false : null),
                    kitColor: document.getElementById('kitColor').value.trim() || null,
                    arrivalTime: arrivalVal ? Timestamp.fromDate(new Date(arrivalVal)) : null,
                    notes: document.getElementById('gameNotes').value.trim() || null,
                    assignments: getAssignmentsFromForm()
                };

                if (editingGameId) {
                    await updateGame(currentTeamId, editingGameId, gameData);
                } else {
                    gameData.status = 'scheduled';
                    gameData.homeScore = 0;
                    gameData.awayScore = 0;
                    await addGame(currentTeamId, gameData);
                }

                resetGameForm();
                loadSchedule();
            } catch (error) {
                console.error(error);
                alert('Error saving game: ' + error.message);
            }
        });

        // ===== PRACTICE FORM HANDLERS =====

        function resetPracticeForm() {
            document.getElementById('add-practice-form').reset();
            document.getElementById('practiceTitle').value = 'Practice';
            document.getElementById('practiceRecurring').checked = false;
            document.getElementById('recurrence-builder').classList.add('hidden');
            document.querySelectorAll('.day-checkbox').forEach(cb => cb.checked = false);
            editingPracticeId = null;
            editingSeriesId = null;
            document.getElementById('submit-practice-btn').textContent = 'Add Practice';
            document.getElementById('cancel-edit-practice-btn').classList.add('hidden');
        }

        function startEditPractice(practice) {
            editingPracticeId = practice.id;
            editingSeriesId = practice.seriesId || null;
            switchTab('tab-add-practice');

            const date = practice.date?.toDate ? practice.date.toDate() : new Date(practice.date);
            document.getElementById('practiceTitle').value = practice.title || 'Practice';
            document.getElementById('practiceStart').value = date.toISOString().slice(0, 16);

            if (practice.end) {
                const endDate = practice.end?.toDate ? practice.end.toDate() : new Date(practice.end);
                document.getElementById('practiceEnd').value = endDate.toISOString().slice(0, 16);
            }

            document.getElementById('practiceLocation').value = practice.location || '';
            document.getElementById('practiceNotes').value = practice.notes || '';

            // Handle recurring practice edit - load series settings
            if (practice.isSeriesMaster && practice.recurrence) {
                document.getElementById('practiceRecurring').checked = true;
                document.getElementById('recurrence-builder').classList.remove('hidden');
                document.getElementById('recurrenceFreq').value = practice.recurrence.freq || 'weekly';
                document.getElementById('recurrenceInterval').value = practice.recurrence.interval || 1;

                // Set day checkboxes
                document.querySelectorAll('.day-checkbox').forEach(cb => {
                    cb.checked = (practice.recurrence.byDays || []).includes(cb.value);
                });

                // Set end condition
                if (practice.recurrence.until) {
                    document.querySelector('input[name="recurrenceEnd"][value="until"]').checked = true;
                    const untilDate = practice.recurrence.until?.toDate ? practice.recurrence.until.toDate() : new Date(practice.recurrence.until);
                    document.getElementById('recurrenceUntil').value = untilDate.toISOString().split('T')[0];
                } else if (practice.recurrence.count) {
                    document.querySelector('input[name="recurrenceEnd"][value="count"]').checked = true;
                    document.getElementById('recurrenceCount').value = practice.recurrence.count;
                } else {
                    document.querySelector('input[name="recurrenceEnd"][value="never"]').checked = true;
                }
            }

            document.getElementById('submit-practice-btn').textContent = 'Update Practice';
            document.getElementById('cancel-edit-practice-btn').classList.remove('hidden');
        }

        document.getElementById('cancel-edit-practice-btn').addEventListener('click', resetPracticeForm);

        document.getElementById('add-practice-form').addEventListener('submit', async (e) => {
            e.preventDefault();

            const title = document.getElementById('practiceTitle').value || 'Practice';
            const startVal = document.getElementById('practiceStart').value;
            const endVal = document.getElementById('practiceEnd').value;
            const location = document.getElementById('practiceLocation').value;
            const notes = document.getElementById('practiceNotes').value;
            const isRecurring = document.getElementById('practiceRecurring').checked;

            if (!startVal) {
                alert('Please enter a start date and time');
                return;
            }

            try {
                const startDate = new Date(startVal);
                const endDate = endVal ? new Date(endVal) : getDefaultEndTime(startDate, 'practice');

                const practiceData = {
                    title,
                    date: Timestamp.fromDate(startDate),
                    end: Timestamp.fromDate(endDate),
                    location,
                    notes
                };

                // Handle recurring practice
                if (isRecurring) {
                    const freq = document.getElementById('recurrenceFreq').value;
                    const interval = parseInt(document.getElementById('recurrenceInterval').value) || 1;
                    const byDays = Array.from(document.querySelectorAll('.day-checkbox:checked')).map(cb => cb.value);
                    const endType = document.querySelector('input[name="recurrenceEnd"]:checked').value;

                    practiceData.isSeriesMaster = true;
                    // Preserve existing seriesId on edit; generate new on create
                    practiceData.seriesId = editingPracticeId
                        ? (editingSeriesId || practiceData.seriesId || generateSeriesId())
                        : generateSeriesId();

                    // Store start/end as time strings for recurring (HH:mm)
                    practiceData.startTime = startDate.toTimeString().slice(0, 5);
                    practiceData.endTime = endDate.toTimeString().slice(0, 5);

                    practiceData.recurrence = { freq, interval, byDays };

                    if (endType === 'until') {
                        const untilVal = document.getElementById('recurrenceUntil').value;
                        if (untilVal) {
                            practiceData.recurrence.until = Timestamp.fromDate(new Date(untilVal));
                        }
                    } else if (endType === 'count') {
                        practiceData.recurrence.count = parseInt(document.getElementById('recurrenceCount').value) || 10;
                    }

                    // Initialize empty exDates and overrides
                    if (!editingPracticeId) {
                        practiceData.exDates = [];
                        practiceData.overrides = {};
                    }
                }

                if (editingPracticeId) {
                    await updateEvent(currentTeamId, editingPracticeId, practiceData);
                } else {
                    await addPractice(currentTeamId, practiceData);
                }

                resetPracticeForm();
                loadSchedule();
            } catch (error) {
                console.error(error);
                alert('Error saving practice: ' + error.message);
            }
        });

        // ===== OCCURRENCE MODAL HANDLERS (Phase 2) =====

        function showOccurrenceChoiceModal(masterId, isoDate, master) {
            editingOccurrence = { masterId, isoDate, master };
            const dateText = new Date(isoDate).toLocaleDateString();
            const dateEl = document.getElementById('occurrence-choice-date');
            if (dateEl) {
                dateEl.textContent = dateText;
            }
            document.getElementById('occurrence-choice-modal').classList.remove('hidden');
        }

        // Close occurrence choice modal
        document.getElementById('close-occurrence-choice-btn').addEventListener('click', () => {
            document.getElementById('occurrence-choice-modal').classList.add('hidden');
            editingOccurrence = null;
        });

        // Edit this occurrence only
        document.getElementById('edit-this-occurrence-btn').addEventListener('click', () => {
            document.getElementById('occurrence-choice-modal').classList.add('hidden');

            const { masterId, isoDate, master } = editingOccurrence;
            const override = master.overrides?.[isoDate] || {};

            // Populate occurrence form
            document.getElementById('occurrence-master-id').value = masterId;
            document.getElementById('occurrence-iso-date').value = isoDate;
            document.getElementById('occurrence-date-display').textContent = new Date(isoDate).toLocaleDateString();
            document.getElementById('occurrence-title').value = override.title || master.title || 'Practice';
            document.getElementById('occurrence-start-time').value = override.startTime || master.startTime || '';
            document.getElementById('occurrence-end-time').value = override.endTime || master.endTime || '';
            document.getElementById('occurrence-location').value = override.location || master.location || '';
            document.getElementById('occurrence-notes').value = override.notes || master.notes || '';

            document.getElementById('edit-occurrence-modal').classList.remove('hidden');
        });

        // Edit entire series
        document.getElementById('edit-series-btn').addEventListener('click', () => {
            document.getElementById('occurrence-choice-modal').classList.add('hidden');
            // Load the series master into the practice form
            startEditPractice(editingOccurrence.master);
        });

        // Cancel entire series from manage modal
        document.getElementById('delete-series-btn').addEventListener('click', async () => {
            const { masterId } = editingOccurrence || {};
            if (!masterId) return;

            if (confirm('Cancel this entire series? All occurrences will be removed.')) {
                try {
                    await deleteSeries(currentTeamId, masterId);
                    document.getElementById('occurrence-choice-modal').classList.add('hidden');
                    editingOccurrence = null;
                    loadSchedule();
                } catch (error) {
                    alert('Error canceling series: ' + error.message);
                }
            }
        });

        // Cancel this occurrence
        document.getElementById('cancel-this-occurrence-btn').addEventListener('click', async () => {
            const { masterId, isoDate } = editingOccurrence;

            if (confirm(`Cancel practice on ${new Date(isoDate).toLocaleDateString()}? This occurrence will be removed from the schedule.`)) {
                try {
                    await cancelOccurrence(currentTeamId, masterId, isoDate);
                    document.getElementById('occurrence-choice-modal').classList.add('hidden');
                    editingOccurrence = null;
                    loadSchedule();
                } catch (error) {
                    alert('Error canceling occurrence: ' + error.message);
                }
            }
        });

        // Cancel edit occurrence modal
        document.getElementById('cancel-occurrence-edit-btn').addEventListener('click', () => {
            document.getElementById('edit-occurrence-modal').classList.add('hidden');
        });

        // Revert occurrence to series defaults
        document.getElementById('revert-occurrence-btn').addEventListener('click', async () => {
            const masterId = document.getElementById('occurrence-master-id').value;
            const isoDate = document.getElementById('occurrence-iso-date').value;

            if (confirm('Revert this occurrence to use the series defaults?')) {
                try {
                    await clearOccurrenceOverride(currentTeamId, masterId, isoDate);
                    document.getElementById('edit-occurrence-modal').classList.add('hidden');
                    loadSchedule();
                } catch (error) {
                    alert('Error reverting occurrence: ' + error.message);
                }
            }
        });

        // Save single occurrence override
        document.getElementById('edit-occurrence-form').addEventListener('submit', async (e) => {
            e.preventDefault();

            const masterId = document.getElementById('occurrence-master-id').value;
            const isoDate = document.getElementById('occurrence-iso-date').value;

            const changes = {
                title: document.getElementById('occurrence-title').value,
                startTime: document.getElementById('occurrence-start-time').value,
                endTime: document.getElementById('occurrence-end-time').value,
                location: document.getElementById('occurrence-location').value,
                notes: document.getElementById('occurrence-notes').value
            };

            try {
                await updateOccurrence(currentTeamId, masterId, isoDate, changes);
                document.getElementById('edit-occurrence-modal').classList.add('hidden');
                loadSchedule();
            } catch (error) {
                alert('Error updating occurrence: ' + error.message);
            }
        });

        // Global functions for practice actions (called from rendered HTML)
        window.editPractice = (practiceId) => {
            getEvents(currentTeamId).then(events => {
                const practice = events.find(e => e.id === practiceId);
                if (practice) {
                    if (practice.isSeriesMaster) {
                        // Show occurrence choice modal for recurring practices
                        const today = new Date().toISOString().split('T')[0];
                        showOccurrenceChoiceModal(practiceId, today, practice);
                    } else {
                        startEditPractice(practice);
                    }
                }
            });
        };

        window.editOccurrence = (masterId, isoDate) => {
            const master = seriesMasters[masterId];
            if (!master) {
                alert('Series data not found. Please reload and try again.');
                return;
            }
            showOccurrenceChoiceModal(masterId, isoDate, master);
        };

        window.deletePractice = async (practiceId) => {
            if (confirm('Delete this practice?')) {
                try {
                    await deleteEvent(currentTeamId, practiceId);
                    loadSchedule();
                } catch (error) {
                    alert('Error deleting practice: ' + error.message);
                }
            }
        };

        window.deleteSeries = async (masterId) => {
            if (confirm('Delete this entire recurring series? All occurrences will be removed.')) {
                try {
                    await deleteSeries(currentTeamId, masterId);
                    loadSchedule();
                } catch (error) {
                    alert('Error deleting series: ' + error.message);
                }
            }
        };

        window.restoreOccurrence = async (masterId, isoDate) => {
            try {
                await restoreOccurrence(currentTeamId, masterId, isoDate);
                loadSchedule();
            } catch (error) {
                alert('Error restoring occurrence: ' + error.message);
            }
        };

        // Calendar Management Event Handlers
        document.getElementById('add-calendar-btn').addEventListener('click', () => {
            document.getElementById('add-calendar-form').classList.remove('hidden');
            document.getElementById('calendar-url-input').focus();
        });

        document.getElementById('cancel-calendar-btn').addEventListener('click', () => {
            document.getElementById('add-calendar-form').classList.add('hidden');
            document.getElementById('calendar-url-input').value = '';
        });

        document.getElementById('save-calendar-btn').addEventListener('click', async () => {
            const url = document.getElementById('calendar-url-input').value.trim();
            if (!url) {
                alert('Please enter a calendar URL');
                return;
            }

            if (!url.includes('.ics')) {
                alert('Please enter a valid .ics calendar URL (must include .ics)');
                return;
            }

            try {
                await addCalendarToTeam(currentTeamId, url);
                document.getElementById('add-calendar-form').classList.add('hidden');
                document.getElementById('calendar-url-input').value = '';

                // Reload team and schedule
                currentTeam = await getTeam(currentTeamId);
                renderCalendarManagement();
                loadSchedule();
            } catch (error) {
                alert('Error adding calendar: ' + error.message);
            }
        });

        window.removeCalendar = async (url) => {
            if (!confirm('Remove this calendar?')) return;

            try {
                await removeCalendarFromTeam(currentTeamId, url);
                currentTeam = await getTeam(currentTeamId);
                renderCalendarManagement();
                loadSchedule();
            } catch (error) {
                alert('Error removing calendar: ' + error.message);
            }
        };

        // Practice filter
        document.getElementById('show-practices').addEventListener('change', (e) => {
            showPractices = e.target.checked;
            loadSchedule();
        });

        function setScheduleFilter(nextFilter) {
            scheduleViewFilter = nextFilter || 'upcoming-all';
            document.querySelectorAll('.schedule-filter-btn').forEach(btn => {
                const active = btn.dataset.scheduleFilter === scheduleViewFilter;
                btn.classList.toggle('bg-indigo-50', active);
                btn.classList.toggle('text-indigo-700', active);
                btn.classList.toggle('border-indigo-200', active);
                btn.classList.toggle('bg-white', !active);
                btn.classList.toggle('text-gray-600', !active);
                btn.classList.toggle('border-gray-200', !active);
            });
            loadSchedule();
        }

        document.querySelectorAll('.schedule-filter-btn').forEach(btn => {
            btn.addEventListener('click', () => setScheduleFilter(btn.dataset.scheduleFilter));
        });

        // Track calendar event - create game and redirect to tracker
        window.trackCalendarEvent = async (calendarEvent) => {
            try {
                const opponent = extractOpponent(calendarEvent.summary, currentTeam.name);
                const configId = document.getElementById('statConfig').value;

                // Create game in DB
                const eventDate = calendarEvent.dtstart;
                const timestamp = Timestamp.fromDate(new Date(eventDate));

                const gameId = await addGame(currentTeamId, {
                    type: 'game',
                    date: timestamp,
                    opponent: opponent,
                    location: calendarEvent.location || '',
                    statTrackerConfigId: configId || null,
                    status: 'scheduled',
                    homeScore: 0,
                    awayScore: 0,
                    calendarEventUid: calendarEvent.uid
                });

                // Check if this is a basketball game using shared helper
                if (isBasketballConfig(configId)) {
                    pendingTrackGameId = gameId;
                    document.getElementById('basketball-tracker-modal')?.classList.remove('hidden');
                } else {
                    window.location.href = `track.html#teamId=${currentTeamId}&gameId=${gameId}`;
                }
            } catch (error) {
                console.error('Error tracking game:', error);
                alert('Error tracking game: ' + error.message);
            }
        };

        // ===== BULK AI UPDATE FUNCTIONALITY =====

        let proposedOperations = [];

        // Tab switching helper
        function switchTab(activeTab) {
            const tabs = ['tab-add-game', 'tab-add-practice', 'tab-bulk-ai'];
            const contents = ['content-add-game', 'content-add-practice', 'content-bulk-ai'];

            tabs.forEach((tabId, index) => {
                const tab = document.getElementById(tabId);
                const content = document.getElementById(contents[index]);

                if (tabId === activeTab) {
                    tab.classList.add('text-indigo-600', 'border-b-2', 'border-indigo-600', 'bg-indigo-50');
                    tab.classList.remove('text-gray-600');
                    content.classList.remove('hidden');
                } else {
                    tab.classList.remove('text-indigo-600', 'border-b-2', 'border-indigo-600', 'bg-indigo-50');
                    tab.classList.add('text-gray-600');
                    content.classList.add('hidden');
                }
            });
        }

        document.getElementById('tab-add-game').addEventListener('click', () => {
            switchTab('tab-add-game');
            if (!editingGameId) prefillAssignments();
        });
        document.getElementById('tab-add-practice').addEventListener('click', () => switchTab('tab-add-practice'));
        document.getElementById('tab-bulk-ai').addEventListener('click', () => switchTab('tab-bulk-ai'));

        // Recurrence builder toggle
        document.getElementById('practiceRecurring').addEventListener('change', (e) => {
            const builder = document.getElementById('recurrence-builder');
            const daySelector = document.getElementById('day-selector');
            if (e.target.checked) {
                builder.classList.remove('hidden');
            } else {
                builder.classList.add('hidden');
            }
        });

        // Update interval label based on frequency
        document.getElementById('recurrenceFreq').addEventListener('change', (e) => {
            const label = document.getElementById('interval-label');
            const daySelector = document.getElementById('day-selector');
            if (e.target.value === 'daily') {
                label.textContent = 'day(s)';
                daySelector.classList.add('hidden');
            } else {
                label.textContent = 'week(s)';
                daySelector.classList.remove('hidden');
            }
        });

        // Image upload and preview handlers
        document.getElementById('schedule-image-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    document.getElementById('schedule-image-preview-img').src = event.target.result;
                    document.getElementById('schedule-image-preview').classList.remove('hidden');
                };
                reader.readAsDataURL(file);
            }
        });

        document.getElementById('remove-schedule-image').addEventListener('click', () => {
            document.getElementById('schedule-image-input').value = '';
            document.getElementById('schedule-image-preview').classList.add('hidden');
        });

        // Helper function to convert file to generative part for Gemini
        async function fileToGenerativePart(file) {
            const base64EncodedDataPromise = new Promise((resolve) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result.split(',')[1]);
                reader.readAsDataURL(file);
            });
            return {
                inlineData: { data: await base64EncodedDataPromise, mimeType: file.type },
            };
        }

        function normalizeIsHome(value) {
            if (value === true || value === false || value === null) return value;
            if (typeof value === 'string') {
                const v = value.trim().toLowerCase();
                if (v === 'home') return true;
                if (v === 'away') return false;
                if (v === '' || v === 'unknown' || v === 'null') return null;
            }
            return null;
        }

        function formatIsoForInput(value) {
            if (!value) return '';
            const d = value?.toDate ? value.toDate() : new Date(value);
            if (Number.isNaN(d.getTime())) return '';
            return new Date(d.getTime() - d.getTimezoneOffset() * 60000).toISOString().slice(0, 16);
        }

        function normalizeAssignments(value) {
            if (!Array.isArray(value)) return [];
            const normalized = value
                .map((a) => ({
                    role: String(a?.role || '').trim(),
                    value: String(a?.value || '').trim()
                }))
                .filter((a) => a.role);
            if (value.length > normalized.length) {
                console.warn('Bulk AI assignments: dropped malformed entries', {
                    provided: value.length,
                    kept: normalized.length
                });
            }
            return normalized;
        }

        function formatAssignmentsForInput(assignments) {
            const normalized = normalizeAssignments(assignments);
            return normalized.map((a) => `${a.role}:${a.value || ''}`).join('; ');
        }

        function parseAssignmentsInput(text) {
            if (!text || !text.trim()) return [];
            return text
                .split(';')
                .map((chunk) => {
                    const [rolePart, ...valueParts] = chunk.split(':');
                    return {
                        role: (rolePart || '').trim(),
                        value: valueParts.join(':').trim()
                    };
                })
                .filter((a) => a.role);
        }

        function normalizeBulkGameForAdd(game) {
            const normalizedIsHome = normalizeIsHome(game?.isHome);
            const rawKitColor = typeof game?.kitColor === 'string' ? game.kitColor.trim() : '';
            const kitColor = rawKitColor || (normalizedIsHome === true ? 'Home kit' : (normalizedIsHome === false ? 'Away kit' : 'TBD kit'));
            return {
                ...game,
                isHome: normalizedIsHome,
                kitColor,
                notes: game?.notes ? String(game.notes).trim() : null,
                assignments: normalizeAssignments(game?.assignments || [])
            };
        }

        // Process with AI
        document.getElementById('process-ai-btn').addEventListener('click', async () => {
            const textInput = document.getElementById('bulk-text-input').value.trim();
            const imageInput = document.getElementById('schedule-image-input');
            const imageFile = imageInput.files[0];

            if (!textInput && !imageFile) {
                alert('Please upload an image or enter additional instructions');
                return;
            }

            const loadingDiv = document.getElementById('ai-loading');
            const processBtn = document.getElementById('process-ai-btn');

            try {
                // Show loading state
                loadingDiv.classList.remove('hidden');
                processBtn.disabled = true;
                processBtn.classList.add('opacity-50');

                // Get current games for context
                const currentGames = await getGames(currentTeamId);

                // Build context for AI
                const gamesContext = currentGames.map(g => {
                    const date = g.date.toDate ? g.date.toDate() : new Date(g.date);
                    return {
                        id: g.id,
                        date: date.toISOString(),
                        opponent: g.opponent,
                        location: g.location || '',
                        status: g.status || 'scheduled'
                    };
                });

                // Get current date for year context
                const now = new Date();
                const currentYear = now.getFullYear();
                const currentMonth = now.getMonth() + 1;

                // Define JSON schema for structured output
                const jsonSchema = Schema.object({
                    properties: {
                        operations: Schema.array({
                            items: Schema.object({
                                properties: {
                                    action: Schema.string(),
                                    game: Schema.object({
                                        properties: {
                                            date: Schema.string(),
                                            opponent: Schema.string(),
                                            location: Schema.string(),
                                            isHome: Schema.boolean(),
                                            kitColor: Schema.string(),
                                            arrivalTime: Schema.string(),
                                            notes: Schema.string(),
                                            assignments: Schema.array({
                                                items: Schema.object({
                                                    properties: {
                                                        role: Schema.string(),
                                                        value: Schema.string()
                                                    }
                                                })
                                            }),
                                            status: Schema.string(),
                                            homeScore: Schema.number(),
                                            awayScore: Schema.number()
                                        },
                                        optionalProperties: ["isHome", "kitColor", "arrivalTime", "notes", "assignments", "status", "homeScore", "awayScore"]
                                    }),
                                    gameId: Schema.string(),
                                    changes: Schema.object({
                                        properties: {
                                            date: Schema.string(),
                                            opponent: Schema.string(),
                                            location: Schema.string(),
                                            isHome: Schema.boolean(),
                                            kitColor: Schema.string(),
                                            arrivalTime: Schema.string(),
                                            notes: Schema.string(),
                                            assignments: Schema.array({
                                                items: Schema.object({
                                                    properties: {
                                                        role: Schema.string(),
                                                        value: Schema.string()
                                                    }
                                                })
                                            })
                                        },
                                        optionalProperties: ["date", "opponent", "location", "isHome", "kitColor", "arrivalTime", "notes", "assignments"]
                                    }),
                                    reason: Schema.string()
                                },
                                optionalProperties: ["game", "gameId", "changes", "reason"]
                            })
                        })
                    }
                });

                // Create AI prompt
                let promptText = `Parse this sports schedule and extract game information.

CONTEXT:
- Today: ${now.toISOString().split('T')[0]}
- Team: ${currentTeam.name}
- Current games in DB: ${gamesContext.length}

${imageFile ? 'The schedule is provided as an image. Extract all game information from it.' : 'SCHEDULE TEXT:\n' + textInput}

${textInput && imageFile ? '\nADDITIONAL INSTRUCTIONS:\n' + textInput : ''}

PARSING RULES:
1. Extract all games from the ${imageFile ? 'image' : 'text'} (look for Date/Time/Home/Away/Location columns or any game entries)
2. Skip headers, "Week X", "Thanksgiving", and non-game text
3. Team variations: "${currentTeam.name}", "${currentTeam.name}10", "${currentTeam.name}22" = same team
4. Opponent: The team that is NOT ${currentTeam.name} (check Home/Away columns)
5. Date format: Convert to ISO 8601 YYYY-MM-DDTHH:mm:ss (e.g., "2024-12-06T08:30:00")
   - "11/15" = November 15, "Sat 11/22" = November 22
   - Use year ${currentYear} for future dates, ${currentYear + 1} for past dates
6. Time: "8:30 AM" = 08:30:00, "2:20 PM" = 14:20:00, "12:00 PM" = 12:00:00
7. Extract extra fields when available:
   - Home/Away -> isHome (true for home, false for away)
   - Kit/Uniform color -> kitColor
   - Arrival/check-in time -> arrivalTime (ISO 8601 datetime)
   - Notes/comments -> notes
   - Assignments (snack, carpool, etc.) -> assignments array: [{ role, value }]
8. For each game, create an operation with action="add" and game object with date, opponent, location, status="scheduled", homeScore=0, awayScore=0`;

                // Call Firebase AI with structured output
                const firebaseApp = getApp();
                const ai = getAI(firebaseApp, { backend: new GoogleAIBackend() });
                const model = getGenerativeModel(ai, {
                    model: "gemini-2.5-flash",
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: jsonSchema
                    }
                });

                // Build prompt parts (text + optional image)
                let promptParts = [promptText];
                if (imageFile) {
                    const imagePart = await fileToGenerativePart(imageFile);
                    promptParts.push(imagePart);
                }

                const result = await model.generateContent(promptParts);

                // Parse the JSON response
                const responseText = result.response.text();
                const aiResponse = JSON.parse(responseText);

                if (!aiResponse.operations || !Array.isArray(aiResponse.operations)) {
                    throw new Error('Invalid AI response format - missing "operations" array. Response: ' + JSON.stringify(aiResponse));
                }

                // Store operations and render preview
                proposedOperations = aiResponse.operations.map((op) => {
                    if (op.action === 'add' && op.game) {
                        return { ...op, game: normalizeBulkGameForAdd(op.game) };
                    }
                    return op;
                });

                if (proposedOperations.length === 0) {
                    alert('AI did not find any games to add/update/delete in the text. Please try being more specific with dates and opponents.');
                }

                await renderProposedChanges();

            } catch (error) {
                console.error('Error processing with AI:', error);
                alert('Error processing schedule with AI:\n\n' + error.message);
            } finally {
                // Hide loading state
                loadingDiv.classList.add('hidden');
                processBtn.disabled = false;
                processBtn.classList.remove('opacity-50');
            }
        });

        // Render proposed changes with edit/delete capabilities
        async function renderProposedChanges() {
            const section = document.getElementById('proposed-changes-section');
            const list = document.getElementById('proposed-changes-list');
            const countSpan = document.getElementById('changes-count');

            if (proposedOperations.length === 0) {
                section.classList.add('hidden');
                return;
            }

            section.classList.remove('hidden');
            countSpan.textContent = `${proposedOperations.length} change${proposedOperations.length === 1 ? '' : 's'}`;

            // Check conflicts for all ADD operations first
            const conflictChecks = await Promise.all(
                proposedOperations.map(async (op) => {
                    if (op.action === 'add') {
                        return await checkForConflict(op.game);
                    }
                    return false;
                })
            );

            list.innerHTML = proposedOperations.map((op, index) => {
                if (op.action === 'add') {
                    const game = op.game;
                    const date = new Date(game.date);
                    const dateStr = formatDate(date);
                    const timeStr = formatTime(date);
                    const hasConflict = conflictChecks[index];

                    return `
                        <div class="border ${hasConflict ? 'border-yellow-400 bg-yellow-50' : 'border-green-300 bg-green-50'} rounded-lg p-3" data-index="${index}">
                            <div class="flex justify-between items-start gap-2">
                                <div class="flex-1">
                                    <div class="flex items-center gap-2 mb-1">
                                        <span class="text-xs font-bold ${hasConflict ? 'text-yellow-700' : 'text-green-700'} uppercase">
                                            ${hasConflict ? '‚ö†Ô∏è Add (Conflict)' : '‚ûï Add'}
                                        </span>
                                    </div>
                                    <div class="text-sm">
                                        <input type="text" value="${game.opponent}"
                                            onchange="updateOperation(${index}, 'opponent', this.value)"
                                            class="font-semibold bg-white border border-gray-300 rounded px-2 py-1 w-full mb-1">
                                        <input type="datetime-local" value="${date.toISOString().slice(0, 16)}"
                                            onchange="updateOperation(${index}, 'date', this.value)"
                                            class="text-xs bg-white border border-gray-300 rounded px-2 py-1 w-full mb-1">
                                        <input type="text" value="${game.location || ''}" placeholder="Location"
                                            onchange="updateOperation(${index}, 'location', this.value)"
                                            class="text-xs bg-white border border-gray-300 rounded px-2 py-1 w-full">
                                        <select onchange="updateOperation(${index}, 'isHome', this.value)"
                                            class="text-xs bg-white border border-gray-300 rounded px-2 py-1 w-full mt-1">
                                            <option value="" ${game.isHome === null || game.isHome === undefined ? 'selected' : ''}>Home/Away Unknown</option>
                                            <option value="home" ${game.isHome === true ? 'selected' : ''}>Home</option>
                                            <option value="away" ${game.isHome === false ? 'selected' : ''}>Away</option>
                                        </select>
                                        <input type="text" value="${game.kitColor || ''}" placeholder="Kit color"
                                            onchange="updateOperation(${index}, 'kitColor', this.value)"
                                            class="text-xs bg-white border border-gray-300 rounded px-2 py-1 w-full mt-1">
                                        <input type="datetime-local" value="${formatIsoForInput(game.arrivalTime)}"
                                            onchange="updateOperation(${index}, 'arrivalTime', this.value)"
                                            class="text-xs bg-white border border-gray-300 rounded px-2 py-1 w-full mt-1">
                                        <textarea rows="2" placeholder="Notes"
                                            onchange="updateOperation(${index}, 'notes', this.value)"
                                            class="text-xs bg-white border border-gray-300 rounded px-2 py-1 w-full mt-1">${game.notes || ''}</textarea>
                                        <input type="text" value="${formatAssignmentsForInput(game.assignments)}" placeholder="Assignments: Role:Value; Role2:Value2"
                                            onchange="updateOperation(${index}, 'assignments', this.value)"
                                            class="text-xs bg-white border border-gray-300 rounded px-2 py-1 w-full mt-1">
                                    </div>
                                    ${hasConflict ? `<div class="text-xs text-yellow-700 mt-1">‚ö†Ô∏è Similar game exists within 24 hours</div>` : ''}
                                </div>
                                <button onclick="removeOperation(${index})"
                                    class="text-red-600 hover:text-red-800 text-sm font-bold">‚úï</button>
                            </div>
                        </div>
                    `;
                } else if (op.action === 'update') {
                    return `
                        <div class="border border-blue-300 bg-blue-50 rounded-lg p-3" data-index="${index}">
                            <div class="flex justify-between items-start gap-2">
                                <div class="flex-1">
                                    <div class="text-xs font-bold text-blue-700 uppercase mb-1">‚úèÔ∏è Update</div>
                                    <div class="text-sm">
                                        Game ID: ${op.gameId}<br>
                                        Changes: ${JSON.stringify(op.changes)}<br>
                                        <span class="text-xs text-gray-600">${op.reason || ''}</span>
                                    </div>
                                </div>
                                <button onclick="removeOperation(${index})"
                                    class="text-red-600 hover:text-red-800 text-sm font-bold">‚úï</button>
                            </div>
                        </div>
                    `;
                } else if (op.action === 'delete') {
                    return `
                        <div class="border border-red-300 bg-red-50 rounded-lg p-3" data-index="${index}">
                            <div class="flex justify-between items-start gap-2">
                                <div class="flex-1">
                                    <div class="text-xs font-bold text-red-700 uppercase mb-1">üóëÔ∏è Delete</div>
                                    <div class="text-sm">
                                        Game ID: ${op.gameId}<br>
                                        <span class="text-xs text-gray-600">${op.reason || 'Removed from schedule'}</span>
                                    </div>
                                </div>
                                <button onclick="removeOperation(${index})"
                                    class="text-gray-600 hover:text-gray-800 text-sm font-bold">‚úï</button>
                            </div>
                        </div>
                    `;
                }
            }).join('');
        }

        // Check for conflicts with existing games
        async function checkForConflict(newGame) {
            const currentGames = await getGames(currentTeamId);
            const newDate = new Date(newGame.date);

            return currentGames.some(existingGame => {
                const existingDate = existingGame.date.toDate ? existingGame.date.toDate() : new Date(existingGame.date);
                const timeDiff = Math.abs(newDate - existingDate);
                const hoursDiff = timeDiff / (1000 * 60 * 60);

                // Check if within 24 hours and similar opponent
                if (hoursDiff < 24) {
                    const opponent1 = (newGame.opponent || '').toLowerCase();
                    const opponent2 = (existingGame.opponent || '').toLowerCase();
                    return opponent1.includes(opponent2) || opponent2.includes(opponent1);
                }
                return false;
            });
        }

        // Update operation when user edits
        window.updateOperation = function(index, field, value) {
            if (proposedOperations[index].action === 'add') {
                if (field === 'date') {
                    proposedOperations[index].game[field] = new Date(value).toISOString();
                } else if (field === 'arrivalTime') {
                    proposedOperations[index].game[field] = value ? new Date(value).toISOString() : null;
                } else if (field === 'isHome') {
                    proposedOperations[index].game[field] = normalizeIsHome(value);
                } else if (field === 'assignments') {
                    proposedOperations[index].game[field] = parseAssignmentsInput(value);
                } else {
                    proposedOperations[index].game[field] = value;
                }
            }
        };

        // Remove operation from list
        window.removeOperation = async function(index) {
            proposedOperations.splice(index, 1);
            await renderProposedChanges();
        };

        // Cancel changes
        document.getElementById('cancel-changes-btn').addEventListener('click', () => {
            proposedOperations = [];
            document.getElementById('proposed-changes-section').classList.add('hidden');
            document.getElementById('bulk-text-input').value = '';
        });

        // Apply changes to database
        document.getElementById('apply-changes-btn').addEventListener('click', async () => {
            if (proposedOperations.length === 0) return;

            const confirmMsg = `Apply ${proposedOperations.length} change${proposedOperations.length === 1 ? '' : 's'} to the schedule?`;
            if (!confirm(confirmMsg)) return;

            const applyBtn = document.getElementById('apply-changes-btn');
            const cancelBtn = document.getElementById('cancel-changes-btn');

            try {
                applyBtn.disabled = true;
                cancelBtn.disabled = true;
                applyBtn.textContent = 'Applying...';

                let successCount = 0;
                let errorCount = 0;

                for (const op of proposedOperations) {
                    try {
                        if (op.action === 'add') {
                            const normalizedGame = normalizeBulkGameForAdd(op.game);
                            const gameData = {
                                ...normalizedGame,
                                type: 'game',
                                date: Timestamp.fromDate(new Date(normalizedGame.date)),
                                isHome: normalizedGame.isHome,
                                kitColor: normalizedGame.kitColor,
                                arrivalTime: normalizedGame.arrivalTime ? Timestamp.fromDate(new Date(normalizedGame.arrivalTime)) : null,
                                notes: normalizedGame.notes,
                                assignments: normalizedGame.assignments,
                                status: normalizedGame.status || 'scheduled',
                                homeScore: normalizedGame.homeScore || 0,
                                awayScore: normalizedGame.awayScore || 0
                            };
                            await addGame(currentTeamId, gameData);
                            successCount++;
                        } else if (op.action === 'update') {
                            const changes = { ...op.changes };
                            if (changes.date) {
                                changes.date = Timestamp.fromDate(new Date(changes.date));
                            }
                            if ('arrivalTime' in changes) {
                                changes.arrivalTime = changes.arrivalTime ? Timestamp.fromDate(new Date(changes.arrivalTime)) : null;
                            }
                            if ('isHome' in changes) {
                                changes.isHome = normalizeIsHome(changes.isHome);
                            }
                            if ('kitColor' in changes) {
                                changes.kitColor = changes.kitColor ? String(changes.kitColor).trim() : null;
                            }
                            if ('notes' in changes) {
                                changes.notes = changes.notes ? String(changes.notes).trim() : null;
                            }
                            if ('assignments' in changes) {
                                changes.assignments = normalizeAssignments(changes.assignments);
                            }
                            await updateGame(currentTeamId, op.gameId, changes);
                            successCount++;
                        } else if (op.action === 'delete') {
                            await deleteGame(currentTeamId, op.gameId);
                            successCount++;
                        }
                    } catch (error) {
                        console.error(`Error applying operation:`, op, error);
                        errorCount++;
                    }
                }

                // Show results
                alert(`Applied ${successCount} change${successCount === 1 ? '' : 's'} successfully.${errorCount > 0 ? `\n${errorCount} error${errorCount === 1 ? '' : 's'} occurred.` : ''}`);

                // Reset and reload
                proposedOperations = [];
                document.getElementById('proposed-changes-section').classList.add('hidden');
                document.getElementById('bulk-text-input').value = '';
                await loadSchedule();

            } catch (error) {
                console.error('Error applying changes:', error);
                alert('Error applying changes: ' + error.message);
            } finally {
                applyBtn.disabled = false;
                cancelBtn.disabled = false;
                applyBtn.textContent = '‚úÖ Apply Changes';
            }
        });

        // Basketball tracker choice modal handlers
        document.getElementById('basketball-tracker-cancel')?.addEventListener('click', closeBasketballTrackerModal);
        document.getElementById('basketball-tracker-standard')?.addEventListener('click', () => {
            if (!pendingTrackGameId) return closeBasketballTrackerModal();
            const gameId = pendingTrackGameId;
            closeBasketballTrackerModal();
            window.location.href = `track.html#teamId=${currentTeamId}&gameId=${gameId}`;
        });
        document.getElementById('basketball-tracker-beta')?.addEventListener('click', () => {
            if (!pendingTrackGameId) return closeBasketballTrackerModal();
            const gameId = pendingTrackGameId;
            closeBasketballTrackerModal();
            window.location.href = `track-basketball.html#teamId=${currentTeamId}&gameId=${gameId}`;
        });
        document.getElementById('basketball-tracker-live')?.addEventListener('click', () => {
            if (!pendingTrackGameId) return closeBasketballTrackerModal();
            const gameId = pendingTrackGameId;
            closeBasketballTrackerModal();
            window.location.href = `live-tracker.html#teamId=${currentTeamId}&gameId=${gameId}`;
        });
        document.getElementById('basketball-tracker-photo')?.addEventListener('click', () => {
            if (!pendingTrackGameId) return closeBasketballTrackerModal();
            const gameId = pendingTrackGameId;
            closeBasketballTrackerModal();
            window.location.href = `track-statsheet.html#teamId=${currentTeamId}&gameId=${gameId}`;
        });
        function showToast(message) {
            const toast = document.createElement('div');
            toast.className = 'fixed bottom-6 right-6 bg-gray-900 text-white text-sm px-4 py-2 rounded-lg shadow-lg z-50';
            toast.textContent = message;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 2000);
        }

        function buildLiveShareText(game, url) {
            const teamName = currentTeam?.name || 'Team';
            const opponent = game?.opponent || 'Opponent';
            const dateLabel = formatShortDate(game?.date);
            const timeLabel = formatTime(game?.date);
            const when = dateLabel ? `${dateLabel}${timeLabel ? ` at ${timeLabel}` : ''}` : '';
            const line = `Watch ${teamName} vs ${opponent}${when ? ` ‚Äî ${when}` : ''}`;
            return `${line}\n${url}`;
        }

        document.addEventListener('click', (event) => {
            const btn = event.target.closest('[data-live-link]');
            if (!btn) return;
            const gameId = btn.dataset.liveLink;
            const url = `${window.location.origin}/live-game.html?teamId=${currentTeamId}&gameId=${gameId}`;
            const game = gamesCache[gameId];
            const shareText = buildLiveShareText(game, url);
            shareOrCopy({
                title: `Watch ${currentTeam?.name || 'Team'}`,
                text: shareText.split('\n')[0],
                url,
                clipboardText: shareText
            }).then((result) => {
                if (result.status === 'shared') showToast('Share sheet opened!');
                if (result.status === 'copied') showToast('Share text copied!');
                if (result.status === 'failed') showToast('Failed to share.');
            });
        });
    </script>
</body>

</html>
