<!DOCTYPE html>
<html lang="en">

<head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-3J13LHWFT3"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-3J13LHWFT3');
  </script>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" href="img/logo_small.png">
    <title>Parent Dashboard - ALL PLAYS</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="css/styles.css">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: {
                            50: '#eef2ff',
                            100: '#e0e7ff',
                            500: '#6366f1',
                            600: '#4f46e5',
                            700: '#4338ca',
                            800: '#3730a3',
                            900: '#312e81'
                        }
                    }
                }
            }
        }
    </script>
</head>

<body class="bg-gradient-to-br from-gray-50 to-gray-100 text-gray-900">
    <div id="header-container"></div>

    <main class="container mx-auto px-4 py-8 md:py-12">
        <!-- Page Header -->
        <div class="mb-8 md:mb-12">
            <h1 class="text-3xl md:text-4xl lg:text-5xl font-bold mb-2 bg-gradient-to-r from-primary-600 to-primary-800 bg-clip-text text-transparent">Parent Dashboard</h1>
            <p class="text-gray-600 text-sm md:text-base">Track your athletes' schedules and stats.</p>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            <!-- Left Column: My Players -->
            <div class="lg:col-span-1 space-y-6">
                <div class="bg-white rounded-2xl shadow-md border border-gray-200 overflow-hidden">
                    <div class="p-4 border-b border-gray-100 bg-gray-50">
                        <h2 class="text-lg font-bold text-gray-900">My Players</h2>
                    </div>
                    <div id="my-players-list" class="p-4 space-y-4">
                        <div class="text-center py-8">
                            <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-primary-600 mx-auto mb-2"></div>
                            <p class="text-sm text-gray-500">Loading players...</p>
                        </div>
                    </div>
                </div>
                
                <!-- My Teams -->
                <div class="bg-white rounded-2xl shadow-md border border-gray-200 overflow-hidden">
                    <div class="p-4 border-b border-gray-100 bg-gray-50">
                        <h2 class="text-lg font-bold text-gray-900">My Teams</h2>
                    </div>
                    <div id="team-chats-list" class="p-4 space-y-2">
                        <div class="text-center py-4 text-gray-500 text-sm">Loading...</div>
                    </div>
                </div>

                <!-- Coach Invite Info -->
                <div class="bg-blue-50 rounded-2xl p-6 border border-blue-100">
                    <h3 class="font-semibold text-blue-900 mb-2">Need to add another player?</h3>
                    <p class="text-sm text-blue-800">Ask the coach to send you an invite code for that player. Once you have it, you can redeem it here.</p>
                    <div class="mt-4">
                        <input type="text" id="redeem-code-input" placeholder="Enter Invite Code" class="w-full px-3 py-2 border border-blue-200 rounded-lg text-sm mb-2 uppercase">
                        <button id="redeem-code-btn" class="w-full bg-blue-600 text-white py-2 rounded-lg text-sm font-medium hover:bg-blue-700 transition">Redeem Code</button>
                    </div>
                </div>
            </div>

            <!-- Right Column: Combined Schedule -->
            <div class="lg:col-span-2">
                <div class="bg-white rounded-2xl shadow-md border border-gray-200 overflow-hidden min-h-[500px]">
                    <div class="p-6 border-b border-gray-100 bg-gray-50 flex justify-between items-center gap-3">
                        <h2 class="text-xl font-bold text-gray-900">Schedule</h2>
                        <div class="flex items-center gap-2">
                            <select id="player-filter" class="text-xs font-medium bg-white px-2 py-1 rounded border border-gray-200 text-gray-600 focus:outline-none focus:ring-1 focus:ring-primary-500 focus:border-primary-500">
                                <option value="">All Players</option>
                            </select>
                            <button id="download-ics" class="inline-flex items-center gap-1 px-3 py-1.5 text-xs font-medium text-primary-600 bg-primary-50 rounded-lg hover:bg-primary-100 transition border border-primary-200">
                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path>
                                </svg>
                                .ics
                            </button>
                        </div>
                    </div>
                    <div class="px-6 py-3 border-b border-gray-100 bg-gray-50">
                        <div class="flex flex-wrap items-center gap-2">
                            <button id="schedule-filter-upcoming-all" onclick="setScheduleFilter('upcoming-all')" class="px-2.5 py-1 text-xs font-semibold rounded-full border border-primary-200 bg-primary-50 text-primary-700">All Upcoming</button>
                            <button id="schedule-filter-upcoming-games" onclick="setScheduleFilter('upcoming-games')" class="px-2.5 py-1 text-xs font-semibold rounded-full border border-gray-200 bg-white text-gray-600 hover:bg-gray-100">Upcoming Games</button>
                            <button id="schedule-filter-upcoming-practices" onclick="setScheduleFilter('upcoming-practices')" class="px-2.5 py-1 text-xs font-semibold rounded-full border border-gray-200 bg-white text-gray-600 hover:bg-gray-100">Upcoming Practices</button>
                            <button id="schedule-filter-past-all" onclick="setScheduleFilter('past-all')" class="px-2.5 py-1 text-xs font-semibold rounded-full border border-gray-200 bg-white text-gray-600 hover:bg-gray-100">Past Events</button>
                        </div>
                    </div>
                    <div id="schedule-list" class="divide-y divide-gray-100">
                        <div class="text-center py-12">
                            <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-primary-600 mx-auto mb-2"></div>
                            <p class="text-sm text-gray-500">Loading schedule...</p>
                        </div>
                    </div>
                </div>
                <div id="practice-packets-card" class="bg-white rounded-2xl shadow-md border border-gray-200 overflow-hidden mt-6">
                    <div class="p-6 border-b border-gray-100 bg-gray-50">
                        <div class="flex items-center justify-between gap-3">
                            <div>
                                <h2 class="text-xl font-bold text-gray-900">Practice Attendance & Home Packet</h2>
                                <p class="text-xs text-gray-500 mt-1">Session-based view for families</p>
                            </div>
                            <div class="flex items-center gap-2">
                                <button id="packet-filter-recent" onclick="setPracticePacketFilter('recent_upcoming')" class="px-2.5 py-1 text-xs font-semibold rounded-full border border-primary-200 bg-primary-50 text-primary-700">Recent + Upcoming</button>
                                <button id="packet-filter-past" onclick="setPracticePacketFilter('past')" class="px-2.5 py-1 text-xs font-semibold rounded-full border border-gray-200 bg-white text-gray-600 hover:bg-gray-100">Past</button>
                            </div>
                        </div>
                    </div>
                    <div id="practice-packets-list" class="divide-y divide-gray-100"></div>
                </div>
            </div>
        </div>
    </main>

    <div id="footer-container"></div>
    <div id="packet-preview-modal" class="hidden fixed inset-0 z-50">
        <div class="absolute inset-0 bg-black/50" onclick="closePracticePacketPreview()"></div>
        <div class="absolute inset-y-0 right-0 w-full max-w-lg bg-white shadow-2xl overflow-y-auto">
            <div class="sticky top-0 bg-white border-b border-gray-200 px-6 py-4 flex items-center justify-between z-10">
                <h3 class="text-lg font-bold text-gray-900">Home Packet</h3>
                <button onclick="closePracticePacketPreview()" class="text-gray-400 hover:text-gray-700">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div id="packet-preview-content" class="px-6 py-5"></div>
        </div>
    </div>

    <script type="module">
        import { getParentDashboardData, redeemParentInvite, getTeam, getGames, getTrackedCalendarEventUids, getUnreadChatCounts, getPracticeSessions, getPracticePacketCompletions, upsertPracticePacketCompletion, updateUserProfile, getUserProfile } from './js/db.js?v=19';
        import { renderHeader, renderFooter, escapeHtml, fetchAndParseCalendar, extractOpponent, isPracticeEvent } from './js/utils.js?v=8';
        import { requireAuth, checkAuth } from './js/auth.js?v=9';

        renderFooter(document.getElementById('footer-container'));

        let allScheduleEvents = [];
        let currentUserId = null;
        let currentUser = null;
        let allPracticePacketSessions = [];
        let practicePacketFilter = 'recent_upcoming';
        let scheduleViewFilter = 'upcoming-all';
        const practicePacketSessionMap = new Map();
        window.setPracticePacketFilter = setPracticePacketFilter;
        window.setScheduleFilter = setScheduleFilter;
        window.openPracticePacketPreview = openPracticePacketPreview;
        window.closePracticePacketPreview = closePracticePacketPreview;
        window.markPracticePacketComplete = markPracticePacketComplete;

        function hasRecordedAttendance(attendance) {
            if (!attendance || !Array.isArray(attendance.players) || attendance.players.length === 0) return false;
            if (attendance.editedAt) return true;
            if ((attendance.checkedInCount ?? attendance.players.length) !== attendance.players.length) return true;
            return attendance.players.some(p => (p.status && p.status !== 'present') || (typeof p.note === 'string' && p.note.trim()));
        }

        function hasHomePacket(session) {
            const blocks = session?.homePacketContent?.blocks;
            return !!(session?.homePacketGenerated && Array.isArray(blocks) && blocks.length > 0);
        }

        function toDateSafe(value) {
            if (!value) return null;
            const d = value?.toDate ? value.toDate() : new Date(value);
            return Number.isNaN(d?.getTime?.()) ? null : d;
        }

        async function init() {
            try {
                const user = await requireAuth();
                currentUserId = user.uid;
                currentUser = user;

                // Allow checkAuth to populate user object fully
                checkAuth((updatedUser) => {
                     renderHeader(document.getElementById('header-container'), updatedUser);
                });

                const data = await getParentDashboardData(user.uid);
                renderPlayers(data.children);

                // Get unique team IDs and fetch unread counts
                const teamIds = [...new Set(data.children.map(c => c.teamId).filter(Boolean))];
                await ensureParentTeamAccess(user.uid, teamIds);
                const unreadCounts = await getUnreadChatCounts(user.uid, teamIds);
                renderTeamChats(data.children, unreadCounts);
                const combinedSchedule = await buildCombinedSchedule(data.children);
                allScheduleEvents = combinedSchedule;
                allPracticePacketSessions = await buildPracticePacketSessions(data.children);
                initPlayerFilter(data.children);
                setScheduleFilter('upcoming-all');
                renderScheduleFromControls();
                renderPracticePackets();

                // Redeem Code Logic
                document.getElementById('redeem-code-btn').addEventListener('click', async () => {
                    const code = document.getElementById('redeem-code-input').value.trim();
                    if(!code) return alert('Please enter a code');
                    
                    const btn = document.getElementById('redeem-code-btn');
                    const originalText = btn.textContent;
                    btn.textContent = 'Processing...';
                    btn.disabled = true;

                    try {
                        console.log('[parent-dashboard] redeem click', { code });
                        await redeemParentInvite(user.uid, code);
                        console.log('[parent-dashboard] redeem completed successfully');
                        alert('Player added successfully!');
                        location.reload();
                    } catch (e) {
                        console.error('[parent-dashboard] redeem error', e);
                        alert('Error: ' + e.message);
                        btn.textContent = originalText;
                        btn.disabled = false;
                    }
                });

            } catch (error) {
                console.error(error);
            }
        }

        async function ensureParentTeamAccess(userId, teamIds) {
            if (!userId || !Array.isArray(teamIds) || teamIds.length === 0) return;
            try {
                const profile = await getUserProfile(userId);
                const existing = Array.isArray(profile?.parentTeamIds) ? profile.parentTeamIds : [];
                const merged = [...new Set([...existing, ...teamIds])];
                const needsUpdate = merged.length !== existing.length;
                if (needsUpdate) {
                    await updateUserProfile(userId, { parentTeamIds: merged });
                }
            } catch (err) {
                console.warn('Failed to ensure parent team access:', err);
            }
        }

        async function buildCombinedSchedule(children) {
            if (!children || children.length === 0) return [];

            const byTeam = new Map();
            for (const child of children) {
                if (!child.teamId) continue;
                if (!byTeam.has(child.teamId)) {
                    byTeam.set(child.teamId, []);
                }
                byTeam.get(child.teamId).push(child);
            }

            const allEvents = [];

            for (const [teamId, teamChildren] of byTeam.entries()) {
                const team = await getTeam(teamId);
                if (!team) continue;

                const dbGames = await getGames(teamId);
                const trackedUids = await getTrackedCalendarEventUids(teamId);
                const practiceSessions = await getPracticeSessions(teamId);
                const sessionsByEventId = new Map();
                const sessions = [];
                const matchedSessionIds = new Set();
                practiceSessions.forEach((session) => {
                    if (!session?.eventId) return;
                    sessionsByEventId.set(session.eventId, session);
                    sessions.push({
                        ...session,
                        _parsedDate: toDateSafe(session.date)
                    });
                });

                const resolvePracticeSession = (event, eventDate) => {
                    const candidates = [
                        event?.id,
                        event?.eventId,
                        event?.calendarEventUid,
                        event?.uid
                    ].filter(Boolean);
                    for (const key of candidates) {
                        if (sessionsByEventId.has(key)) {
                            const found = sessionsByEventId.get(key);
                            if (found?.id) matchedSessionIds.add(found.id);
                            return found;
                        }
                    }
                    // Recurring instance fallback: session eventId may be `${masterId}__YYYY-MM-DD`
                    const masterId = event?.id || event?.eventId;
                    if (!masterId) return null;
                    const recurringMatches = sessions.filter(s => typeof s.eventId === 'string' && s.eventId.startsWith(`${masterId}__`));
                    if (!recurringMatches.length) return null;
                    if (!eventDate) return recurringMatches[0];
                    const target = eventDate.getTime();
                    recurringMatches.sort((a, b) => {
                        const at = a._parsedDate?.getTime?.() || 0;
                        const bt = b._parsedDate?.getTime?.() || 0;
                        return Math.abs(at - target) - Math.abs(bt - target);
                    });
                    if (recurringMatches[0]?.id) matchedSessionIds.add(recurringMatches[0].id);
                    return recurringMatches[0];
                };

                // DB games for this team
                for (const game of dbGames) {
                    const date = game.date?.toDate ? game.date.toDate() : new Date(game.date);
                    const isPractice = game.type === 'practice';
                    const type = isPractice ? 'practice' : 'game';
                    const location = game.location || 'TBD';
                    const opponent = game.opponent || 'TBD';
                    const id = game.id || game.gameId;
                    const session = isPractice ? resolvePracticeSession(game, date) : null;

                    for (const child of teamChildren) {
                        allEvents.push({
                            type,
                            date,
                            location,
                            opponent,
                            teamId,
                            id,
                            childId: child.playerId,
                            childName: child.playerName,
                            practiceAttendance: isPractice && hasRecordedAttendance(session?.attendance) ? session.attendance : null,
                            practiceHomePacket: isPractice && hasHomePacket(session) ? session.homePacketContent : null
                        });
                    }
                }

                // Calendar (ICS) events for this team
                if (team.calendarUrls && team.calendarUrls.length > 0) {
                    console.log(`[parent-dashboard] Team ${team.name} has ${team.calendarUrls.length} calendar URL(s)`);
                    for (const calendarUrl of team.calendarUrls) {
                        try {
                            console.log(`[parent-dashboard] Fetching calendar: ${calendarUrl}`);
                            const calendarEvents = await fetchAndParseCalendar(calendarUrl);
                            console.log(`[parent-dashboard] Got ${calendarEvents.length} events from calendar`);

                            calendarEvents.forEach(event => {
                                if (trackedUids.includes(event.uid)) return;

                                // Check if event is cancelled (standard iCal STATUS or TeamSnap [CANCELED] prefix)
                                const isCancelled = event.status?.toUpperCase() === 'CANCELLED' ||
                                    event.summary?.includes('[CANCELED]');

                                const eventDate = event.dtstart;
                                if (!eventDate) return;

                                // Skip if a DB game already occupies this slot (within 1 minute)
                                const hasConflict = dbGames.some(dbGame => {
                                    const dbDate = dbGame.date?.toDate ? dbGame.date.toDate() : new Date(dbGame.date);
                                    return Math.abs(dbDate - eventDate) < 60000;
                                });
                                if (hasConflict) return;

                                const isPractice = isPracticeEvent(event.summary);
                                // Clean [CANCELED] prefix from summary before extracting opponent
                                const cleanSummary = event.summary?.replace(/\[CANCELED\]\s*/gi, '') || '';
                                const opponent = extractOpponent(cleanSummary, team.name);
                                const location = event.location || 'TBD';
                                const type = isPractice ? 'practice' : 'game';
                                const session = isPractice ? resolvePracticeSession(event, eventDate) : null;

                                for (const child of teamChildren) {
                                    allEvents.push({
                                        type,
                                        date: eventDate,
                                        location,
                                        opponent,
                                        teamId,
                                        id: event.uid || null,
                                        childId: child.playerId,
                                        childName: child.playerName,
                                        isCancelled,
                                        practiceAttendance: isPractice && hasRecordedAttendance(session?.attendance) ? session.attendance : null,
                                        practiceHomePacket: isPractice && hasHomePacket(session) ? session.homePacketContent : null
                                    });
                                }
                            });
                        } catch (err) {
                            console.error('Error fetching calendar for parent dashboard:', calendarUrl, err);
                        }
                    }
                }

                // Include upcoming draft/planned sessions that don't currently map to a schedule event.
                sessions
                    .filter((session) => {
                        const d = session._parsedDate;
                        if (!d) return false;
                        if (session.id && matchedSessionIds.has(session.id)) return false;
                        return true;
                    })
                    .forEach((session) => {
                        for (const child of teamChildren) {
                            allEvents.push({
                                type: 'practice',
                                date: session._parsedDate,
                                location: session.location || 'TBD',
                                opponent: null,
                                teamId,
                                id: session.eventId || session.id,
                                childId: child.playerId,
                                childName: child.playerName,
                                title: session.title || 'Practice',
                                practiceAttendance: hasRecordedAttendance(session?.attendance) ? session.attendance : null,
                                practiceHomePacket: hasHomePacket(session) ? session.homePacketContent : null
                            });
                        }
                    });
            }

            allEvents.sort((a, b) => a.date - b.date);
            return allEvents;
        }

        function initPlayerFilter(children) {
            const select = document.getElementById('player-filter');
            if (!select) return;

            // Populate options
            select.innerHTML = `
                <option value="">All Players</option>
                ${children.map(child => `
                    <option value="${child.playerId}">${escapeHtml(child.playerName)}</option>
                `).join('')}
            `;

            select.addEventListener('change', (e) => {
                const playerId = e.target.value || '';
                renderScheduleFromControls(playerId);
                renderPracticePackets(playerId);
            });
        }

        function getFilteredScheduleEvents(selectedPlayerId = '') {
            const now = new Date();
            let events = selectedPlayerId
                ? allScheduleEvents.filter(ev => ev.childId === selectedPlayerId)
                : [...allScheduleEvents];
            if (scheduleViewFilter === 'upcoming-all') {
                events = events.filter(ev => (ev.date?.toDate ? ev.date.toDate() : new Date(ev.date)) >= now);
                events.sort((a, b) => a.date - b.date);
            } else if (scheduleViewFilter === 'upcoming-games') {
                events = events.filter(ev => ev.type === 'game' && (ev.date?.toDate ? ev.date.toDate() : new Date(ev.date)) >= now);
                events.sort((a, b) => a.date - b.date);
            } else if (scheduleViewFilter === 'upcoming-practices') {
                events = events.filter(ev => ev.type === 'practice' && (ev.date?.toDate ? ev.date.toDate() : new Date(ev.date)) >= now);
                events.sort((a, b) => a.date - b.date);
            } else if (scheduleViewFilter === 'past-all') {
                events = events.filter(ev => (ev.date?.toDate ? ev.date.toDate() : new Date(ev.date)) < now);
                events.sort((a, b) => b.date - a.date);
            }
            return events;
        }

        function renderScheduleFromControls(selectedPlayerId = '') {
            const playerId = selectedPlayerId || (document.getElementById('player-filter')?.value || '');
            renderSchedule(getFilteredScheduleEvents(playerId));
        }

        function setScheduleFilter(next) {
            scheduleViewFilter = next || 'upcoming-all';
            const ids = ['upcoming-all', 'upcoming-games', 'upcoming-practices', 'past-all'];
            ids.forEach((id) => {
                const btn = document.getElementById(`schedule-filter-${id}`);
                if (!btn) return;
                const active = id === scheduleViewFilter;
                btn.className = `px-2.5 py-1 text-xs font-semibold rounded-full border ${active ? 'border-primary-200 bg-primary-50 text-primary-700' : 'border-gray-200 bg-white text-gray-600 hover:bg-gray-100'}`;
            });
            renderScheduleFromControls();
        }

        async function buildPracticePacketSessions(children) {
            const rows = [];
            const byTeam = new Map();
            (children || []).forEach((child) => {
                if (!child?.teamId) return;
                if (!byTeam.has(child.teamId)) byTeam.set(child.teamId, []);
                byTeam.get(child.teamId).push(child);
            });
            for (const [teamId, teamChildren] of byTeam.entries()) {
                const sessions = await getPracticeSessions(teamId);
                const completionsBySessionId = new Map();
                await Promise.all((sessions || []).map(async (session) => {
                    try {
                        const completions = await getPracticePacketCompletions(teamId, session.id);
                        completionsBySessionId.set(session.id, completions || []);
                    } catch (err) {
                        completionsBySessionId.set(session.id, []);
                    }
                }));
                (sessions || []).forEach((session) => {
                    const d = session?.date?.toDate ? session.date.toDate() : new Date(session?.date);
                    if (!d || Number.isNaN(d.getTime())) return;
                    const hasAttendance = hasRecordedAttendance(session?.attendance);
                    const hasPacket = hasHomePacket(session);
                    if (!hasAttendance && !hasPacket) return;
                    rows.push({
                        sessionId: session.id,
                        teamId,
                        eventId: session.eventId || session.id,
                        title: session.title || 'Practice',
                        date: d,
                        location: session.location || 'TBD',
                        attendance: hasAttendance ? session.attendance : null,
                        homePacket: hasPacket ? session.homePacketContent : null,
                        completions: completionsBySessionId.get(session.id) || [],
                        childNames: teamChildren.map(c => c.playerName).filter(Boolean),
                        childIds: teamChildren.map(c => c.playerId).filter(Boolean),
                        children: teamChildren.map(c => ({ id: c.playerId, name: c.playerName }))
                    });
                });
            }
            rows.sort((a, b) => a.date - b.date);
            return rows;
        }

        function renderPracticePackets(selectedPlayerId = '') {
            const card = document.getElementById('practice-packets-card');
            const list = document.getElementById('practice-packets-list');
            if (!card || !list) return;
            const now = new Date();
            const recentCutoff = new Date(now.getTime() - 14 * 24 * 60 * 60 * 1000);
            let rows = (allPracticePacketSessions || []).filter(row => !selectedPlayerId || row.childIds.includes(selectedPlayerId));
            if (practicePacketFilter === 'recent_upcoming') {
                rows = rows.filter(row => row.date >= recentCutoff);
                rows.sort((a, b) => a.date - b.date);
            } else {
                rows = rows.filter(row => row.date < recentCutoff);
                rows.sort((a, b) => b.date - a.date);
            }
            if (!rows.length) {
                card.classList.remove('hidden');
                list.innerHTML = `<div class="p-6 text-sm text-gray-500">No ${practicePacketFilter === 'past' ? 'past' : 'recent/upcoming'} practice attendance or home packet records.</div>`;
                return;
            }
            card.classList.remove('hidden');
            practicePacketSessionMap.clear();
            list.innerHTML = rows.map((row) => {
                const dateStr = row.date.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });
                const timeStr = row.date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
                const blocks = Array.isArray(row.homePacket?.blocks) ? row.homePacket.blocks : [];
                const homePacketReady = blocks.length > 0;
                const totalMinutes = row.homePacket?.totalMinutes || blocks.reduce((sum, b) => sum + (parseInt(b?.duration, 10) || 0), 0);
                const preview = blocks.slice(0, 3).map(b => b?.drillTitle || b?.title).filter(Boolean);
                const names = [...row.childNames];
                const att = row.attendance;
                const attendanceReady = !!(att && Array.isArray(att.players) && att.players.length > 0);
                const attSummary = attendanceReady
                    ? `${att.players.filter(p => p.status === 'present' || p.status === 'late').length}/${att.players.length} present`
                    : null;
                const completionChildIds = new Set((row.completions || []).filter(c => c.status === 'completed').map(c => c.childId));
                const completedCount = (row.children || []).filter(c => completionChildIds.has(c.id)).length;
                practicePacketSessionMap.set(row.sessionId, row);
                return `
                    <div class="p-5">
                        <div class="flex items-start justify-between gap-3">
                            <div>
                                <p class="text-xs text-gray-500 font-semibold uppercase tracking-wide">${dateStr} · ${timeStr}</p>
                                <p class="text-sm font-bold text-gray-900">${escapeHtml(row.title)}</p>
                                <p class="text-xs text-gray-500 mt-0.5">${escapeHtml(row.location)}</p>
                            </div>
                            ${homePacketReady
                                ? `<button onclick="openPracticePacketPreview('${row.sessionId}')" class="text-xs font-semibold text-primary-700 bg-primary-50 border border-primary-200 px-2 py-1 rounded hover:bg-primary-100">Open Packet</button>`
                                : ''
                            }
                        </div>
                        <div class="mt-2 text-xs ${homePacketReady ? 'text-blue-800 bg-blue-50 border-blue-100' : 'text-gray-600 bg-gray-50 border-gray-200'} border rounded px-2 py-1 inline-block">
                            ${homePacketReady ? `Home Packet: ${blocks.length} drill${blocks.length === 1 ? '' : 's'} · ${totalMinutes} min` : 'Home Packet: Not ready yet'}
                        </div>
                        <div class="mt-2 text-xs ${attendanceReady ? 'text-amber-800 bg-amber-50 border-amber-100' : 'text-gray-600 bg-gray-50 border-gray-200'} border rounded px-2 py-1 inline-block">
                            ${attendanceReady ? `Attendance: ${attSummary}` : 'Attendance: Not recorded yet'}
                        </div>
                        ${homePacketReady ? `<div class="mt-2 text-xs text-emerald-800 bg-emerald-50 border border-emerald-100 rounded px-2 py-1 inline-block">Packet Completed: ${completedCount}/${(row.children || []).length}</div>` : ''}
                        ${preview.length ? `<p class="mt-2 text-xs text-gray-700">${escapeHtml(preview.join(' • '))}</p>` : ''}
                        ${names.length ? `<p class="mt-2 text-[11px] text-gray-500">Applies to: ${escapeHtml(names.join(', '))}</p>` : ''}
                        ${homePacketReady && (row.children || []).length ? `
                            <div class="mt-2 flex flex-wrap gap-2">
                                ${(row.children || []).map(child => {
                                    const done = completionChildIds.has(child.id);
                                    return `<button onclick="markPracticePacketComplete('${row.sessionId}', '${child.id}')" class="text-[11px] px-2 py-1 rounded border ${done ? 'bg-emerald-50 text-emerald-700 border-emerald-200' : 'bg-white text-gray-700 border-gray-200 hover:bg-gray-50'}">${done ? 'Completed' : 'Mark Complete'}: ${escapeHtml(child.name || 'Child')}</button>`;
                                }).join('')}
                            </div>
                        ` : ''}
                    </div>
                `;
            }).join('');
        }

        async function markPracticePacketComplete(sessionId, childId) {
            const row = practicePacketSessionMap.get(sessionId);
            if (!row || !childId) return;
            const child = (row.children || []).find(c => c.id === childId) || null;
            try {
                await ensureParentTeamAccess(currentUserId, [row.teamId]);
                await upsertPracticePacketCompletion(row.teamId, sessionId, {
                    parentUserId: currentUserId,
                    parentName: currentUser?.displayName || currentUser?.email || 'Parent',
                    childId,
                    childName: child?.name || null
                });
                const existing = Array.isArray(row.completions) ? row.completions : [];
                const next = existing.filter(c => !(c.childId === childId && c.parentUserId === currentUserId));
                next.push({
                    parentUserId: currentUserId,
                    parentName: currentUser?.displayName || currentUser?.email || 'Parent',
                    childId,
                    childName: child?.name || null,
                    status: 'completed'
                });
                row.completions = next;
                const idx = allPracticePacketSessions.findIndex(s => s.sessionId === sessionId);
                if (idx >= 0) allPracticePacketSessions[idx].completions = next;
                const selectedPlayerId = document.getElementById('player-filter')?.value || '';
                renderPracticePackets(selectedPlayerId);
            } catch (err) {
                console.error('Failed to mark packet complete:', err);
                alert(`Could not mark packet complete: ${err?.message || err?.code || 'permission or network issue'}`);
            }
        }

        function setPracticePacketFilter(next) {
            practicePacketFilter = next === 'past' ? 'past' : 'recent_upcoming';
            const recentBtn = document.getElementById('packet-filter-recent');
            const pastBtn = document.getElementById('packet-filter-past');
            if (recentBtn && pastBtn) {
                const recentActive = practicePacketFilter === 'recent_upcoming';
                recentBtn.className = `px-2.5 py-1 text-xs font-semibold rounded-full border ${recentActive ? 'border-primary-200 bg-primary-50 text-primary-700' : 'border-gray-200 bg-white text-gray-600 hover:bg-gray-100'}`;
                pastBtn.className = `px-2.5 py-1 text-xs font-semibold rounded-full border ${!recentActive ? 'border-primary-200 bg-primary-50 text-primary-700' : 'border-gray-200 bg-white text-gray-600 hover:bg-gray-100'}`;
            }
            const selectedPlayerId = document.getElementById('player-filter')?.value || '';
            renderPracticePackets(selectedPlayerId);
        }

        function openPracticePacketPreview(sessionId) {
            const row = practicePacketSessionMap.get(sessionId);
            if (!row || !row.homePacket || !Array.isArray(row.homePacket.blocks)) return;
            const content = document.getElementById('packet-preview-content');
            if (!content) return;
            const blocks = row.homePacket.blocks;
            const total = row.homePacket.totalMinutes || blocks.reduce((sum, b) => sum + (parseInt(b?.duration, 10) || 0), 0);
            const completionChildIds = new Set((row.completions || []).filter(c => c.status === 'completed').map(c => c.childId));
            const completionControls = (row.children || []).map(child => {
                const done = completionChildIds.has(child.id);
                return `<button onclick="markPracticePacketComplete('${row.sessionId}', '${child.id}')" class="text-[11px] px-2 py-1 rounded border ${done ? 'bg-emerald-50 text-emerald-700 border-emerald-200' : 'bg-white text-gray-700 border-gray-200 hover:bg-gray-50'}">${done ? 'Completed' : 'Mark Complete'}: ${escapeHtml(child.name || 'Child')}</button>`;
            }).join('');
            content.innerHTML = `
                <p class="text-sm text-gray-700 mb-3">${escapeHtml(row.title || 'Practice')} · ${escapeHtml(row.date.toLocaleDateString('en-US'))}</p>
                <div class="text-xs text-blue-800 bg-blue-50 border border-blue-100 rounded px-2 py-1 inline-block mb-4">Total: ${total} min</div>
                ${completionControls ? `<div class="mb-4 flex flex-wrap gap-2">${completionControls}</div>` : ''}
                <div class="space-y-2">
                    ${blocks.map((b, idx) => `
                        <div class="rounded-lg border border-gray-200 p-3 bg-gray-50">
                            <p class="text-xs text-gray-500 font-semibold uppercase tracking-wide">${escapeHtml(b.type || 'Drill')} · ${parseInt(b.duration, 10) || 0} min</p>
                            <p class="text-sm font-semibold text-gray-900">${escapeHtml(b.drillTitle || b.title || `Drill ${idx + 1}`)}</p>
                            ${b.description ? `<p class="text-xs text-gray-600 mt-1">${escapeHtml(b.description)}</p>` : ''}
                        </div>
                    `).join('')}
                </div>
            `;
            document.getElementById('packet-preview-modal')?.classList.remove('hidden');
        }

        function closePracticePacketPreview() {
            document.getElementById('packet-preview-modal')?.classList.add('hidden');
        }

        function renderPlayers(children) {
            const container = document.getElementById('my-players-list');
            if (!children || children.length === 0) {
                container.innerHTML = `<div class="text-center py-8 text-gray-500 text-sm">No players linked yet.</div>`;
                return;
            }

            container.innerHTML = children.map(child => `
                <a href="player.html?teamId=${child.teamId}&playerId=${child.playerId}" 
                   class="flex items-center gap-4 p-3 rounded-xl border border-gray-200 hover:border-primary-300 hover:bg-primary-50 transition group">
                    <div class="h-12 w-12 flex-shrink-0 rounded-full bg-gray-200 overflow-hidden border border-gray-300">
                        ${child.playerPhotoUrl 
                            ? `<img src="${escapeHtml(child.playerPhotoUrl)}" class="w-full h-full object-cover">` 
                            : `<div class="w-full h-full flex items-center justify-center text-gray-400 text-xs">No Img</div>`
                        }
                    </div>
                    <div class="flex-grow min-w-0">
                        <div class="font-bold text-gray-900 group-hover:text-primary-700 truncate">${escapeHtml(child.playerName)}</div>
                        <div class="text-xs text-gray-500 truncate">${escapeHtml(child.teamName)}</div>
                    </div>
                    <div class="flex-shrink-0 flex items-center gap-2 text-gray-300 group-hover:text-primary-400">
                        <span class="text-xs font-semibold text-primary-600 bg-primary-50 px-2 py-1 rounded-full border border-primary-100">
                            Edit
                        </span>
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                        </svg>
                    </div>
                </a>
            `).join('');
        }

        function renderTeamChats(children, unreadCounts = {}) {
            const container = document.getElementById('team-chats-list');
            if (!children || children.length === 0) {
                container.innerHTML = `<div class="text-center py-4 text-gray-500 text-sm">No teams available.</div>`;
                return;
            }

            // Get unique teams from children, collecting player names per team
            const teamsMap = new Map();
            children.forEach(child => {
                if (!teamsMap.has(child.teamId)) {
                    teamsMap.set(child.teamId, {
                        teamId: child.teamId,
                        teamName: child.teamName,
                        playerNames: []
                    });
                }
                teamsMap.get(child.teamId).playerNames.push(child.playerName);
            });

            const teams = Array.from(teamsMap.values());

            container.innerHTML = teams.map(team => {
                const unread = unreadCounts[team.teamId] || 0;
                const unreadBadge = unread > 0
                    ? `<span class="ml-1 inline-flex items-center justify-center px-1.5 py-0.5 text-xs font-bold text-white bg-red-500 rounded-full min-w-[18px]">${unread > 99 ? '99+' : unread}</span>`
                    : '';

                return `
                <div class="flex items-center gap-3 p-3 rounded-xl border border-gray-200">
                    <div class="flex-shrink-0 w-10 h-10 bg-primary-100 rounded-full flex items-center justify-center">
                        <span class="text-primary-700 font-bold text-sm">${escapeHtml(team.teamName.charAt(0).toUpperCase())}</span>
                    </div>
                    <div class="flex-grow min-w-0">
                        <div class="font-semibold text-gray-900 truncate">${escapeHtml(team.teamName)}</div>
                        <div class="text-xs text-gray-500 truncate">${escapeHtml(team.playerNames.join(', '))}</div>
                    </div>
                    <div class="flex items-center gap-2 flex-shrink-0">
                        <a href="team.html#teamId=${team.teamId}"
                           class="inline-flex items-center gap-1 px-3 py-1.5 text-xs font-medium text-primary-600 bg-primary-50 rounded-lg hover:bg-primary-100 transition">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path>
                            </svg>
                            View
                        </a>
                        <a href="team-chat.html#teamId=${team.teamId}"
                           class="inline-flex items-center gap-1 px-3 py-1.5 text-xs font-medium ${unread > 0 ? 'text-white bg-primary-600 hover:bg-primary-700' : 'text-gray-600 bg-gray-100 hover:bg-gray-200'} rounded-lg transition">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"></path>
                            </svg>
                            Chat${unreadBadge}
                        </a>
                    </div>
                </div>
            `}).join('');
        }

        function renderSchedule(games) {
            const container = document.getElementById('schedule-list');
            if (!games || games.length === 0) {
                container.innerHTML = `
                    <div class="text-center py-16">
                        <svg class="w-16 h-16 text-gray-300 mx-auto mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
                        </svg>
                        <p class="text-gray-500">No events in this filter.</p>
                    </div>
                `;
                return;
            }

            container.innerHTML = games.map(game => {
                const gameDate = game.date.toDate ? game.date.toDate() : new Date(game.date);
                const dateStr = gameDate.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });
                const timeStr = gameDate.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
                const typeLabel = game.type === 'practice' ? 'Practice' : 'Game';
                const typeColor = game.type === 'practice' ? 'bg-amber-100 text-amber-800' : 'bg-primary-100 text-primary-800';
                const isCancelled = game.isCancelled;
                const attendance = game.practiceAttendance || null;
                const attendanceRecorded = game.type === 'practice' && hasRecordedAttendance(attendance);
                const homePacket = game.practiceHomePacket || null;
                const homePacketBlocks = Array.isArray(homePacket?.blocks) ? homePacket.blocks : [];
                const homePacketReady = game.type === 'practice' && homePacketBlocks.length > 0;
                const homePacketMinutes = homePacket?.totalMinutes || homePacketBlocks.reduce((sum, b) => sum + (parseInt(b?.duration, 10) || 0), 0);
                const homePacketPreview = homePacketBlocks.slice(0, 2).map(b => b?.drillTitle || b?.title).filter(Boolean);
                const presentCount = attendanceRecorded
                    ? attendance.players.filter(p => p.status === 'present' || p.status === 'late').length
                    : 0;
                const lateCount = attendanceRecorded
                    ? attendance.players.filter(p => p.status === 'late').length
                    : 0;
                const absentCount = attendanceRecorded
                    ? attendance.players.filter(p => p.status === 'absent').length
                    : 0;
                const rosterSize = attendanceRecorded ? attendance.players.length : 0;

                return `
                <div class="p-6 hover:bg-gray-50 transition flex flex-col sm:flex-row gap-4 sm:items-center ${isCancelled ? 'opacity-60' : ''}">
                    <div class="flex-shrink-0 w-24 text-center sm:text-left">
                        <div class="text-sm font-bold text-gray-900 uppercase ${isCancelled ? 'line-through' : ''}">${dateStr}</div>
                        <div class="text-xs text-gray-500 ${isCancelled ? 'line-through' : ''}">${timeStr}</div>
                    </div>
                    <div class="flex-grow">
                        <div class="flex items-center gap-2 mb-1">
                            <span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-bold uppercase tracking-wide ${typeColor}">
                                ${typeLabel}
                            </span>
                            ${isCancelled ? '<span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-bold uppercase tracking-wide bg-red-100 text-red-800">Cancelled</span>' : ''}
                            <span class="text-xs text-gray-400 font-medium">For ${escapeHtml(game.childName || 'Player')}</span>
                        </div>
                        <div class="font-bold text-gray-900 text-lg ${isCancelled ? 'line-through' : ''}">
                            ${game.type === 'practice'
                                ? escapeHtml(game.title || 'Practice')
                                : `vs. ${escapeHtml(game.opponent || 'TBD')}`}
                        </div>
                        <div class="text-sm text-gray-500 flex items-center gap-1 mt-1">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"></path>
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"></path>
                            </svg>
                            ${escapeHtml(game.location || 'TBD')}
                        </div>
                        ${attendanceRecorded ? `
                            <div class="mt-3 rounded-lg border border-amber-200 bg-amber-50 px-3 py-2">
                                <div class="text-[11px] font-bold uppercase tracking-wide text-amber-800">Practice Attendance</div>
                                <div class="text-sm text-amber-900">
                                    ${presentCount}/${rosterSize} present
                                    ${lateCount > 0 ? `, ${lateCount} late` : ''}
                                    ${absentCount > 0 ? `, ${absentCount} absent` : ''}
                                </div>
                            </div>
                        ` : ''}
                        ${homePacketReady ? `
                            <div class="mt-2 rounded-lg border border-blue-200 bg-blue-50 px-3 py-2">
                                <div class="text-[11px] font-bold uppercase tracking-wide text-blue-800">Home Packet</div>
                                <div class="text-sm text-blue-900">${homePacketBlocks.length} drill${homePacketBlocks.length === 1 ? '' : 's'} · ${homePacketMinutes} min</div>
                                ${homePacketPreview.length ? `<div class="text-xs text-blue-700 mt-1">${escapeHtml(homePacketPreview.join(' • '))}</div>` : ''}
                            </div>
                        ` : ''}
                    </div>
                    ${!isCancelled ? `
                    <div class="flex-shrink-0 text-right">
                         <a href="game.html?teamId=${game.teamId}&gameId=${game.id}"
                            class="inline-flex items-center gap-1 text-sm font-medium text-primary-600 hover:text-primary-700">
                             View Details
                             <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                            </svg>
                         </a>
                    </div>
                    ` : ''}
                </div>
            `}).join('');
        }

        // ICS export helpers
        function formatIcsDate(date) {
            const pad = (n) => String(n).padStart(2, '0');
            return `${date.getUTCFullYear()}${pad(date.getUTCMonth() + 1)}${pad(date.getUTCDate())}T${pad(date.getUTCHours())}${pad(date.getUTCMinutes())}${pad(date.getUTCSeconds())}Z`;
        }

        function buildIcs(events) {
            const lines = ['BEGIN:VCALENDAR', 'VERSION:2.0', 'PRODID:-//ALL PLAYS//EN'];

            // Dedupe events by id to avoid duplicates for multiple kids on same team
            const seen = new Set();
            events.forEach((event) => {
                const eventKey = `${event.teamId}-${event.id}-${event.date.getTime()}`;
                if (seen.has(eventKey)) return;
                seen.add(eventKey);

                const date = event.date instanceof Date ? event.date : new Date(event.date);
                const start = formatIcsDate(date);
                const endDate = new Date(date.getTime() + 60 * 60 * 1000); // default 1 hour
                const end = formatIcsDate(endDate);
                const summary = event.type === 'practice'
                    ? `${event.childName} - Practice`
                    : `${event.childName} vs ${event.opponent || 'TBD'}`;
                const uid = `${event.id || eventKey}@allplays`;
                lines.push(
                    'BEGIN:VEVENT',
                    `UID:${uid}`,
                    `DTSTAMP:${formatIcsDate(new Date())}`,
                    `DTSTART:${start}`,
                    `DTEND:${end}`,
                    `SUMMARY:${summary}`,
                    `LOCATION:${(event.location || 'TBD').replace(/,/g, '\\,')}`,
                    `DESCRIPTION:For ${event.childName}`,
                    'END:VEVENT'
                );
            });

            lines.push('END:VCALENDAR');
            return lines.join('\r\n');
        }

        document.getElementById('download-ics')?.addEventListener('click', () => {
            if (!allScheduleEvents || allScheduleEvents.length === 0) {
                alert('No games to export yet.');
                return;
            }

            // Use filtered events if a player is selected
            const filterValue = document.getElementById('player-filter')?.value;
            const eventsToExport = filterValue
                ? allScheduleEvents.filter(ev => ev.childId === filterValue)
                : allScheduleEvents;

            if (eventsToExport.length === 0) {
                alert('No games to export for selected player.');
                return;
            }

            const ics = buildIcs(eventsToExport);
            const blob = new Blob([ics], { type: 'text/calendar' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            const filename = filterValue
                ? `${eventsToExport[0]?.childName || 'player'}-schedule.ics`.replace(/[^a-z0-9]+/gi, '-').toLowerCase()
                : 'family-schedule.ics';
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        });

        init();
    </script>
</body>

</html>
