rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Firestore Security Rules - Multi-level Access Control
    // - Public read access for browsing teams, games, and stats
    // - Write access restricted to: team owners, team admins, and global admins
    // - Global admins have full access to all resources

    // Helper functions
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function isGlobalAdmin() {
      return isSignedIn() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.isAdmin == true;
    }

    function isCoachForTeam(teamId) {
      let userPath = /databases/$(database)/documents/users/$(request.auth.uid);
      return isSignedIn() &&
             exists(userPath) &&
             teamId in get(userPath).data.get('coachOf', []);
    }

    function isTeamOwnerOrAdmin(teamId) {
      return isSignedIn() &&
             (get(/databases/$(database)/documents/teams/$(teamId)).data.ownerId == request.auth.uid ||
              (request.auth.token.email != null &&
               request.auth.token.email.lower() in get(/databases/$(database)/documents/teams/$(teamId)).data.get('adminEmails', [])) ||
              isCoachForTeam(teamId) ||
              isGlobalAdmin());
    }

    // Check if user is a parent for a specific player.
    // IMPORTANT: must validate both teamId AND playerId (least privilege).
    // Uses denormalized key `${teamId}::${playerId}` in users.parentPlayerKeys.
    function isParentForPlayer(teamId, playerId) {
      let userPath = /databases/$(database)/documents/users/$(request.auth.uid);
      let parentKey = teamId + "::" + playerId;
      return isSignedIn() &&
             exists(userPath) &&
             parentKey in get(userPath).data.get('parentPlayerKeys', []);
    }

    // Check if user is a parent for any player on a team (uses parentTeamIds)
    function isParentForTeam(teamId) {
      let userPath = /databases/$(database)/documents/users/$(request.auth.uid);
      return isSignedIn() &&
             exists(userPath) &&
             teamId in get(userPath).data.get('parentTeamIds', []);
    }

    // Chat access: team owner, team admins, global admins, or any parent linked to the team
    function canAccessTeamChat(teamId) {
      let team = get(/databases/$(database)/documents/teams/$(teamId)).data;

      // Check owner, admin email, or global admin first (no user doc needed)
      let isOwnerOrAdmin = team.ownerId == request.auth.uid ||
        (request.auth.token.email != null &&
         request.auth.token.email.lower() in team.get('adminEmails', [])) ||
        isCoachForTeam(teamId) ||
        isGlobalAdmin();

      return isSignedIn() && (isOwnerOrAdmin || isParentForTeam(teamId));
    }

    // Users collection - users should only write their own profile
    match /users/{userId} {
      allow read: if true;  // Public profiles
      allow write: if isOwner(userId) || isGlobalAdmin();  // Owner or global admin can update
    }

    // Access codes - allow public read for validation during signup
    match /accessCodes/{codeId} {
      // Allow anyone to read for code validation (needed for unauthenticated signup)
      // This is secure because users can only query by exact code match
      allow read: if true;
      allow create: if isSignedIn() && request.resource.data.generatedBy == request.auth.uid;
      // Only allow the code generator to update/delete, OR allow system to mark as used during signup
      allow update: if isSignedIn() &&
                       (resource.data.generatedBy == request.auth.uid ||
                        // Allow marking as used only if setting these specific fields
                        (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['used', 'usedBy', 'usedAt']) &&
                         request.resource.data.usedBy == request.auth.uid));
      allow delete: if isSignedIn() && resource.data.generatedBy == request.auth.uid;
    }

    // Collection group rule for games - allows cross-team queries (e.g., live games, recent games)
    match /{path=**}/games/{gameId} {
      allow read: if true;  // Public read for collection group queries
    }

    // Collection group rule for players - enables collectionGroup('players') queries.
    // SECURITY: deny reads of any player doc that still contains sensitive fields.
    match /{path=**}/players/{playerId} {
      allow read: if !resource.data.keys().hasAny(['medicalInfo', 'emergencyContact']);
    }

    // Drill Library (top-level collection)
    match /drillLibrary/{drillId} {
      // Community drills readable by any signed-in user; custom drills by their team's owner/admin
      allow read: if isSignedIn() &&
                    (resource.data.source == 'community' ||
                     resource.data.publishedToCommunity == true ||
                     isTeamOwnerOrAdmin(resource.data.teamId));
      // Create: global admin for community, team owner/admin for custom
      allow create: if isSignedIn() &&
                      (
                        (request.resource.data.source == 'community' && isGlobalAdmin()) ||
                        (
                          request.resource.data.source == 'custom' &&
                          request.resource.data.teamId != null &&
                          isTeamOwnerOrAdmin(request.resource.data.teamId) &&
                          request.resource.data.createdBy == request.auth.uid &&
                          (
                            request.resource.data.publishedToCommunity != true ||
                            request.resource.data.authorId == request.auth.uid
                          )
                        )
                      );
      // Update/delete: global admin for community, team owner/admin for custom
      allow update, delete: if isSignedIn() &&
                              (
                                (resource.data.source == 'community' && isGlobalAdmin()) ||
                                (
                                  resource.data.source == 'custom' &&
                                  request.resource.data.source == 'custom' &&
                                  request.resource.data.teamId == resource.data.teamId &&
                                  isTeamOwnerOrAdmin(resource.data.teamId) &&
                                  (
                                    // If publishing now, stamp current editor as author.
                                    !(resource.data.publishedToCommunity != true && request.resource.data.publishedToCommunity == true) ||
                                    request.resource.data.authorId == request.auth.uid
                                  )
                                )
                              );
    }

    // Teams - only owner or admins can modify
    match /teams/{teamId} {
      allow read: if true;  // Public teams for browsing
      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow update, delete: if isTeamOwnerOrAdmin(teamId);

	      // Players subcollection
	      match /players/{playerId} {
	        // Public player doc is only safe if it contains no sensitive fields.
	        // Team owner/admin/parent-of-player may still read legacy docs that contain sensitive fields.
	        allow read: if isTeamOwnerOrAdmin(teamId) ||
	                      isParentForPlayer(teamId, playerId) ||
	                      !resource.data.keys().hasAny(['medicalInfo', 'emergencyContact']);

	        // Writes: never allow sensitive fields on the public player doc.
	        // Coaches/admins can create/update/delete, but must keep the doc "public-safe".
	        allow create: if isTeamOwnerOrAdmin(teamId) &&
	                        !request.resource.data.keys().hasAny(['medicalInfo', 'emergencyContact']);
	        allow update: if isTeamOwnerOrAdmin(teamId) &&
	                        !request.resource.data.keys().hasAny(['medicalInfo', 'emergencyContact']);
	        allow delete: if isTeamOwnerOrAdmin(teamId);

	        // Limited write access for parents (only their linked player):
	        // - Public player doc: photo only
	        allow update: if isParentForPlayer(teamId, playerId) &&
	                         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['photoUrl', 'updatedAt']);

        // Private player profile (sensitive fields)
        match /private/profile {
          allow read: if isTeamOwnerOrAdmin(teamId) || isParentForPlayer(teamId, playerId);

          // Coaches/admins can write freely.
          allow create, update: if isTeamOwnerOrAdmin(teamId);

          // Parents can only write specific sensitive fields for their linked player.
          allow create: if isParentForPlayer(teamId, playerId) &&
                           request.resource.data.keys().hasOnly(['emergencyContact', 'medicalInfo', 'updatedAt']);
          allow update: if isParentForPlayer(teamId, playerId) &&
                           request.resource.data.diff(resource.data).affectedKeys().hasOnly(['emergencyContact', 'medicalInfo', 'updatedAt']);

          allow delete: if isTeamOwnerOrAdmin(teamId);
        }
      }

      // Games subcollection
      match /games/{gameId} {
        allow read: if true;  // Public game data
        allow write: if isTeamOwnerOrAdmin(teamId);

        // Events subcollection
        match /events/{eventId} {
          allow read: if true;
          allow write: if isSignedIn() &&
                          (get(/databases/$(database)/documents/teams/$(teamId)).data.ownerId == request.auth.uid ||
                           (request.auth.token.email != null &&
                            request.auth.token.email.lower() in get(/databases/$(database)/documents/teams/$(teamId)).data.get('adminEmails', [])) ||
                            isGlobalAdmin());
        }

        // Aggregated stats subcollection
        match /aggregatedStats/{statId} {
          allow read: if true;
          allow write: if isSignedIn() &&
                          (get(/databases/$(database)/documents/teams/$(teamId)).data.ownerId == request.auth.uid ||
                           (request.auth.token.email != null &&
                            request.auth.token.email.lower() in get(/databases/$(database)/documents/teams/$(teamId)).data.get('adminEmails', [])) ||
                            isGlobalAdmin());
        }

        // Live Events subcollection - for real-time game broadcasting
        match /liveEvents/{eventId} {
          allow read: if true;  // Public read for viewers
          allow create: if isTeamOwnerOrAdmin(teamId);  // Only stat tracker can write
          allow update, delete: if false;  // Events are immutable
        }

        // Live Chat subcollection - game-specific chat for live viewers
        match /liveChat/{messageId} {
          allow read: if true;  // Public read for all viewers
          allow create: if true;  // Anyone can post (anonymous or authenticated)
          allow update: if false;  // Messages are immutable
          allow delete: if isTeamOwnerOrAdmin(teamId);  // Moderation only
        }

        // Live Reactions subcollection - ephemeral reactions during live games
        match /liveReactions/{reactionId} {
          allow read: if true;  // Public read
          allow create: if true;  // Anyone can react
          allow update, delete: if false;  // Reactions are immutable
        }

        // RSVP subcollection - game attendance responses
        match /rsvps/{rsvpId} {
          allow read: if isTeamOwnerOrAdmin(teamId) || isParentForTeam(teamId);
          allow create, update: if (isTeamOwnerOrAdmin(teamId) || isParentForTeam(teamId)) &&
                                   isSignedIn() && rsvpId == request.auth.uid &&
                                   request.resource.data.userId == request.auth.uid;
          allow delete: if (isTeamOwnerOrAdmin(teamId) || isParentForTeam(teamId)) &&
                           isSignedIn() && rsvpId == request.auth.uid;
        }
      }

      // Stat tracker configs subcollection
      match /statTrackerConfigs/{configId} {
        allow read: if true;
        allow write: if isTeamOwnerOrAdmin(teamId);
      }

      // Drill Favorites subcollection
      match /drillFavorites/{favoriteId} {
        allow read: if isTeamOwnerOrAdmin(teamId) || isParentForTeam(teamId);
        allow create: if isTeamOwnerOrAdmin(teamId);
        allow delete: if isTeamOwnerOrAdmin(teamId);
        allow update: if false; // Immutable â€” add/remove only
      }

      // Practice Sessions subcollection
      match /practiceSessions/{sessionId} {
        allow read: if isTeamOwnerOrAdmin(teamId) || isParentForTeam(teamId);
        allow create, update, delete: if isTeamOwnerOrAdmin(teamId);

        // Parent packet completion check-ins
        match /packetCompletions/{completionId} {
          allow read: if isTeamOwnerOrAdmin(teamId) || isParentForTeam(teamId);
          allow create: if isTeamOwnerOrAdmin(teamId) ||
                           (isParentForTeam(teamId) &&
                            request.resource.data.parentUserId == request.auth.uid &&
                            completionId == request.auth.uid + "__" + request.resource.data.childId &&
                            isParentForPlayer(teamId, request.resource.data.childId));
          allow update: if isTeamOwnerOrAdmin(teamId) ||
                           (isParentForTeam(teamId) &&
                            resource.data.parentUserId == request.auth.uid &&
                            request.resource.data.parentUserId == request.auth.uid &&
                            resource.data.childId == request.resource.data.childId &&
                            completionId == request.auth.uid + "__" + request.resource.data.childId &&
                            isParentForPlayer(teamId, request.resource.data.childId));
          allow delete: if isTeamOwnerOrAdmin(teamId) ||
                           (isParentForTeam(teamId) &&
                            resource.data.parentUserId == request.auth.uid &&
                            completionId == request.auth.uid + "__" + resource.data.childId &&
                            isParentForPlayer(teamId, resource.data.childId));
        }
      }

      // Practice Templates subcollection
      match /practiceTemplates/{templateId} {
        allow read: if isTeamOwnerOrAdmin(teamId);
        allow create, update, delete: if isTeamOwnerOrAdmin(teamId);
      }

      // Chat messages subcollection
      match /chatMessages/{messageId} {
        // Read: any team member (owner, admin, global admin, parent)
        allow read: if canAccessTeamChat(teamId);

        // Create: any team member, must be their own senderId
        allow create: if canAccessTeamChat(teamId) &&
                         request.resource.data.senderId == request.auth.uid;

        // Update for editing: only message sender, only text and editedAt fields
        allow update: if canAccessTeamChat(teamId) &&
                         resource.data.senderId == request.auth.uid &&
                         request.resource.data.diff(resource.data).affectedKeys()
                             .hasOnly(['text', 'editedAt']);

        // Update for soft-delete: sender OR team owner/admin/global admin
        allow update: if canAccessTeamChat(teamId) &&
                         request.resource.data.diff(resource.data).affectedKeys()
                             .hasOnly(['deleted']) &&
                         request.resource.data.deleted == true &&
                         (resource.data.senderId == request.auth.uid ||
                          isTeamOwnerOrAdmin(teamId));

        // Update for reactions: any team member can add/remove reactions only
        allow update: if canAccessTeamChat(teamId) &&
                         (
                           // Current client writes nested reaction keys.
                           request.resource.data.diff(resource.data).affectedKeys()
                             .hasOnly([
                               'reactions.thumbs_up',
                               'reactions.heart',
                               'reactions.joy',
                               'reactions.wow',
                               'reactions.sad',
                               'reactions.clap'
                             ]) ||
                           // Backward compatibility for stale cached clients that write the full map.
                           (
                             request.resource.data.diff(resource.data).affectedKeys().hasOnly(['reactions']) &&
                             request.resource.data.get('reactions', {}).keys().hasOnly([
                               'thumbs_up',
                               'heart',
                               'joy',
                               'wow',
                               'sad',
                               'clap'
                             ])
                           )
                         );
      }
    }

    // Deny all other paths
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
